<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01-什么是JVM?</title>
    <url>/2022/07/10/01-%E4%BB%80%E4%B9%88%E6%98%AFJVM/</url>
    <content><![CDATA[<h2 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a><strong>什么是JVM？</strong></h2><p><strong>①. JVM 是 java虚拟机，是用来执行java字节码(二进制的形式)的虚拟计算机</strong></p>
<p><strong>②. jvm是运行在操作系统之上的，与硬件没有任何关系</strong></p>
<p><img src="/2022/07/10/01-%E4%BB%80%E4%B9%88%E6%98%AFJVM/1.png" alt="1"></p>
<h2 id="Java的跨平台及原理"><a href="#Java的跨平台及原理" class="headerlink" title="Java的跨平台及原理"></a><strong>Java的跨平台及原理</strong></h2><p><strong>①. 跨平台：由Java编写的程序可以在不同的操作系统上运行：一次编写，多处运行</strong></p>
<p><strong>②. 原理：编译之后的字节码文件和平台无关，需要在不同的操作系统上安装一个对应版本的虚拟机(JVM)</strong></p>
<h2 id="JVM的整体的理解"><a href="#JVM的整体的理解" class="headerlink" title="JVM的整体的理解"></a><strong>JVM的整体的理解</strong></h2><p><strong>①. 类加载子系统</strong></p>
<p><strong>②. 运行时数据区(我们核心关注这里 的栈、堆、方法区)</strong></p>
<p><strong>③. 执行引擎(一般都是JIT编译器和解释器共存)</strong></p>
<p><img src="/2022/07/10/01-%E4%BB%80%E4%B9%88%E6%98%AFJVM/2.png" alt="2"></p>
<h2 id="java代码执行流程"><a href="#java代码执行流程" class="headerlink" title="java代码执行流程"></a><strong>java代码执行流程</strong></h2><p>​	<strong>java源码—java编译器—生成字节码—进入java虚拟机（类加载器—字节码校验器—翻译字节码—JIT编译器）</strong></p>
<h2 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a><strong>JVM的架构模型</strong></h2><p><strong>Java编译器输入的指令流基木上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。</strong></p>
<p><strong>基于栈式架构的特点</strong></p>
<ul>
<li>跨平台性</li>
<li>指令集小</li>
<li>指令多</li>
<li>执行性能比寄存器差</li>
</ul>
<p><strong>基于寄存器架构的特点</strong></p>
<ul>
<li>指令集架构则完全依赖硬件，可移植性差</li>
<li>性能优秀和执行更高效</li>
</ul>
<p><strong>举例</strong></p>
<p><strong>同样执行2+3这种逻辑操作，其指令分别如下：</strong></p>
<p><strong>1、基于栈的计算流程（以Java虚拟机为例)</strong></p>
<p><img src="/2022/07/10/01-%E4%BB%80%E4%B9%88%E6%98%AFJVM/3.png" alt="3"></p>
<p><strong>2、基于寄存器的计算流程</strong></p>
<p><img src="/2022/07/10/01-%E4%BB%80%E4%B9%88%E6%98%AFJVM/4.png" alt="4"></p>
<p><strong>总结</strong></p>
<p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a><strong>JVM的生命周期</strong></h2><p><strong>虚拟机的启动</strong></p>
<p><strong>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</strong></p>
<p><strong>虚拟机的执行</strong></p>
<ul>
<li><strong>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</strong></li>
<li><strong>程序开始执行时他才运行，程序结束时他就停止。</strong></li>
<li><strong>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</strong></li>
</ul>
<p><strong>虚拟机的退出</strong></p>
<ul>
<li><strong>程序正常执行结束</strong></li>
<li><strong>程序在执行过程中遇到了异常或错误而异常终止</strong></li>
<li><strong>由于操作系统用现错误而导致Java虚拟机进程终止</strong></li>
<li><strong>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</strong></li>
<li><strong>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</strong></li>
</ul>
]]></content>
      <categories>
        <category>底层源码</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>02-类加载器和类加载过程</title>
    <url>/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a><strong>类加载过程</strong></h1><p><img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/1.png" alt="截图"></p>
<p><img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/20210311102359950.png" alt="20210311102359950"></p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a><strong>加载</strong></h2><p>1、通过一个类的全限定名获取定义此类的二进制字节流</p>
<p>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
<p>3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
<h2 id="链接：一共分为三个部分，验证、准备和解析"><a href="#链接：一共分为三个部分，验证、准备和解析" class="headerlink" title="链接：一共分为三个部分，验证、准备和解析"></a><strong>链接：一共分为三个部分，验证、准备和解析</strong></h2><h3 id="一、验证"><a href="#一、验证" class="headerlink" title="一、验证"></a><strong>一、验证</strong></h3><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身。</p>
<p>验证阶段是十分重要的，直接决定了Java虚拟机是否能承受恶意代码的攻击，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重。</p>
<p>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证</p>
<img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/%E6%88%AA%E5%9B%BE%20(1).png" alt="截图 (1)" style="zoom:67%;">

<h3 id="二、准备"><a href="#二、准备" class="headerlink" title="二、准备"></a><strong>二、准备</strong></h3><p>1、为类变量分配内存并且设置该变量的默认初始值，即零值。</p>
<p>2、这里不包括含用final修饰的static,因为final在编译的时候就会分配数值了，准备阶段会显式初始化。</p>
<p>3、这里不会为实例变量分配初始化，类变量会分配在方法区，而实例变量是会随着对象一起分配到java堆中。</p>
<h3 id="三、解析"><a href="#三、解析" class="headerlink" title="三、解析"></a><strong>三、解析</strong></h3><p>1、<strong>将常量池内的符号引用转换为直接引用过程</strong></p>
<p>2、实际上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</p>
<p>3、符号引用就是一组符号来描述所引用的目标。<strong>符号引用的字面形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</strong></p>
<p>4、主要解析动作针对类或接口、字段、类方法、接口方法、方法类型等。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h2><h3 id="1）初始化阶段就是执行类构造器方法-的过程"><a href="#1）初始化阶段就是执行类构造器方法-的过程" class="headerlink" title="1）初始化阶段就是执行类构造器方法()的过程"></a><strong>1）初始化阶段就是执行类构造器方法()的过程</strong></h3><p><strong>该方法不需要定义，而是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来的</strong></p>
<p><strong>构造器方法中的指令按照语句在源文件中出现的顺序来决定</strong></p>
<p><strong>变量已经赋过一次系统要求的初始零值，而在初始化阶段</strong></p>
<p><strong>则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。</strong></p>
<h3 id="2）若该类有父类，JVM会保证子子类的-执行前，父类的-已经执行完毕"><a href="#2）若该类有父类，JVM会保证子子类的-执行前，父类的-已经执行完毕" class="headerlink" title="2）若该类有父类，JVM会保证子子类的()执行前，父类的()已经执行完毕"></a>2）若该类有父类，JVM会保证子子类的()执行前，父类的()已经执行完毕</h3><p>虚拟机必须保证一个类的()方法在多线程下被同步加锁</p>
<img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/%E6%88%AA%E5%9B%BE%20(2).png" alt="截图 (2)" style="zoom:80%;">

<h3 id="3）在类加载的Linking链接的准备阶段，所有类变量以符号引用的方法存储在方法区"><a href="#3）在类加载的Linking链接的准备阶段，所有类变量以符号引用的方法存储在方法区" class="headerlink" title="3）在类加载的Linking链接的准备阶段，所有类变量以符号引用的方法存储在方法区"></a>3）在类加载的Linking链接的准备阶段，所有类变量以符号引用的方法存储在方法区</h3><p>而当静态代码尝试获取类变量时候需要通过直接引用，这就导致了编译的出错</p>
<h3 id="4）Java编译器并不会为所有的类都产生-初始化方法"><a href="#4）Java编译器并不会为所有的类都产生-初始化方法" class="headerlink" title="4）Java编译器并不会为所有的类都产生()初始化方法"></a>4）Java编译器并不会为所有的类都产生()初始化方法</h3><p>一个类中并没有声明任何的类变量,也没有静态代码块时</p>
<p>一个类中声明类变量,但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</p>
<p>一个类中包含static final修饰的基本数据类型的字段,这些类字段初始化语句采用编译时常量表达式 </p>
<p>(如果这个static final 不是通过方法或者构造器,则在链接阶段)</p>
<p>  <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/3.png" alt="截图 (3)"></p>
<h3 id="5）赋值的阶段性问题"><a href="#5）赋值的阶段性问题" class="headerlink" title="5）赋值的阶段性问题"></a><strong>5）赋值的阶段性问题</strong></h3><p> <strong>在链接阶段的准备环节赋值的情况:</strong></p>
<p><strong>1、对于基本数据类型的字段来说,如果使用static final修饰,则显式赋值(直接赋值常量,而非调用方法)通常是在链接阶段的准备环节进行</strong></p>
<p><strong>2、对于String来说,如果使用字面量的方式赋值,使用static final修饰的话,则显式赋值通常是在链接阶段的准备环节进行</strong></p>
<p><strong>3、使用static + final修饰,且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值,是在链接阶段的准备环节进行。</strong></p>
<p><strong>在初始化阶段()中赋值的情况:</strong></p>
<p><strong>排除上述的在准备环节赋值的情况之外的情况</strong></p>
<p><img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/4.png" alt="截图 (4)"></p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a><strong>类加载器</strong></h1> <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/%E6%88%AA%E5%9B%BE%20(5).png" alt="截图 (5)" style="zoom:80%;">

<h2 id="引导-启动-类加载器"><a href="#引导-启动-类加载器" class="headerlink" title="引导(启动)类加载器"></a><strong>引导(启动)类加载器</strong></h2><p>这个类加载使用C&#x2F;C++语言实现的,嵌套在JVM内部</p>
<p><strong>1、它用来加载Java的核心类库(JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resource.jar或sum.boot.class.path路径下的内容)</strong></p>
<p><strong>用于提供JVM自身需要的类(String类就是使用的这个类加载器)</strong></p>
<p>2、由于安全考虑,Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p>
<p>3、并不继承自java.lang.ClassLoader,没有父加载器</p>
<p><strong>4、加载扩展类和应用程序类加载器,并指定为他们的父类加载器</strong></p>
<p><strong>自定义加载器****（将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器）</strong></p>
<p>1、Java语言编写</p>
<p><strong>2、派生于ClassLoader类,父类加载器为启动类加载器</strong></p>
<p>3、从java.ext.dirs系统属性所指定的目录中加载类库,或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录(扩展目录)下加载类库。</p>
<p>如果用户创建的JAR放在此目录下,也会自动由扩展类加载器加载</p>
<h2 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a><strong>扩展类加载器</strong></h2><p>1、Java语言编写</p>
<p><strong>2、派生于ClassLoader类,父类加载器为启动类加载器</strong></p>
<p>3、从java.ext.dirs系统属性所指定的目录中加载类库,或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录(扩展目录)下加载类库</p>
<p>如果用户创建的JAR放在此目录下,也会自动由扩展类加载器加载</p>
<h2 id="应用程序-系统-类加载器-AppClassLoader"><a href="#应用程序-系统-类加载器-AppClassLoader" class="headerlink" title="应用程序(系统)类加载器 AppClassLoader"></a><strong>应用程序(系统)类加载器 AppClassLoader</strong></h2><p>1、java语言编写</p>
<p><strong>2、派生于ClassLoader类,父类加载器为扩展类加载器</strong></p>
<p><strong>3、它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</strong></p>
<p><strong>4、该类加载是程序中默认的类加载器</strong></p>
<p>5、通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</p>
<h2 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a><strong>用户自定义类加载器</strong></h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a><strong>目的</strong></h3><p>隔离记载类</p>
<p>修改类的加载方式</p>
<p>扩展加载源</p>
<p>防止源码泄露</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h3><p><strong>1）重写 loadClass() 方法（不推荐,这个方法会保证类的双亲委派机制）</strong></p>
<p><strong>2）重写 findClass() 方法 –&gt;推荐</strong></p>
<p><strong>这两种方法本质上差不多,毕竟loadClass()也会调用findClass(),但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法,根据参数指定类的名字,返回对应的Class对象的引用</strong></p>
<p><strong>获取ClassLoader的方法</strong></p>
<p><img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/6.png" alt="截图 (6)"></p>
<p>​    <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/7.png" alt="截图 (7)"></p>
<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a><strong>双亲委派机制</strong></h1><p><em>java虚拟机对class文件采用按需加载的方式进行加载，当需要使用该类时才会将它的class文件加载到内存中生成class对象</em></p>
<p><em>在加载这个类的时候，采用的就是双亲委派模式。</em></p>
<p><strong>1、如果</strong> <strong>一个类加载收到了类加载请求,它并不会自己先去加载</strong> <strong>,而是把这个请求</strong> <strong>委托给父类加载器去执行</strong></p>
<p><strong>2、如果</strong> <strong>父类加载器还存在其父类加载器</strong> <strong>,则进一步</strong> <strong>向上委托</strong> <strong>,依次递归,请求最终将</strong> <strong>到达顶层的启动类加载器</strong></p>
<p><strong>3、如果父类的加载器可以完成类的加载任务,就成功返回,倘若</strong> <strong>父类加载器无法完成此加载任务,子加载器才会尝试自己去加载,</strong> <strong>这就是双亲委派模式</strong></p>
<p>​    <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/20210509161013261.png" alt="20210509161013261"></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><strong>源码分析</strong></h2><p><strong>（双亲委派机制在 java.lang.ClassLoader.loadClass(String,boolean) 中体现）</strong></p>
<p><em>1、先在<strong>当前加载器的缓存</strong>中*<em>查找有无目标类</em></em>,如果有,直接返回。*</p>
<p><em>2、判断当前加载器的父加载器是否为空</em> <em>,如果不为空,则调用 parent.loadClass(name, false) 接口进行加载</em></p>
<p><em>3、反之,如果当前加载器的父类加载器为空,则调用 findBootstrapClassOrNull(name) 接口,让引导类加载器进行加载</em></p>
<p><em>4、如果通过以上3条路径都没能成功加载,则调用 findClass(name) 接口进行加载。该接口最终会调用 java.lang.ClassLoader 接口的 defineClass 系列的native接口加载目标Java类。</em></p>
<p><strong>双亲委派的模型就隐藏在这第2和第3步中</strong></p>
<h2 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a><strong>双亲委派机制的优势</strong></h2><p><strong>1、避免类的重复加载，确保一个类的全局唯一性（当父ClassLoader已经加载了该类的时候,就没有必要子ClassLoader再加载一次）</strong></p>
<p><strong>2、保护程序的安全，防止API随意被篡改</strong></p>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a><strong>沙箱安全机制</strong></h2><p><strong>Java代码限定在</strong><a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020"><strong>虚拟机</strong></a><strong>JVM特定的运行范围中，并且严格限制代码对本地资源的访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏</strong></p>
<p>​    <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/%E6%88%AA%E5%9B%BE%20(8).png" alt="截图 (8)" style="zoom:80%;"></p>
<h1 id="类的使用方式"><a href="#类的使用方式" class="headerlink" title="类的使用方式"></a><strong>类的使用方式</strong></h1><p><strong>java虚拟机在每个类或接口被java程序“首次主动使用”时才初始化它们。被动使用不会初始化类，但又可能会加载类</strong></p>
<p><strong>在加载的过程中，遇到.class文件的缺失或者存在错误，类加载器只会在首次主动使用它们时才会报错，如果一直没使用，则不会报错</strong></p>
<h2 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a><strong>主动使用</strong></h2><p><strong>1、创建类的实例</strong>	</p>
<p><strong>2、访问某个类或接口的静态变量，或者对该静态变量赋值</strong>	</p>
<p><strong>3、调用类的静态方法</strong></p>
<p><strong>4、反射</strong></p>
<p><strong>5、初始化一个类的子类</strong></p>
<p><strong>6、java虚拟机启动时被标明为启动类的类</strong></p>
<p><strong>注意：</strong> <strong>初始化一个类的子类这条规则，不适用于接口，即：初始化一个类的子类，会先初始化它的父类，但是不一定会初始化它的接口。只有当首次使用该接口的静态变量时，才会初始化。</strong></p>
<h2 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a><strong>被动使用</strong></h2><p><strong>除了主动使用的其他使用方式，例如：</strong></p>
<p><strong>1）通过子类引用父类的静态字段，为子类的被动使用，不会导致子类初始化</strong></p>
<p><strong>2）通过数组定义类引用类，为类的被动使用，不会触发此类的初始化</strong></p>
<p>​    <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/9.png" alt="截图 (9)"></p>
<p><strong>3）常量在编译阶段会存入调用方法所在的类的常量池中（这个例子存在F类的常量池中）</strong></p>
<p><strong>本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</strong></p>
<p>  <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/10.png" alt="截图 (10)"></p>
]]></content>
      <categories>
        <category>底层源码</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/07/12/03-%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a><strong>数据区</strong></h1><p><strong>JVM在执行java程序的过程中会把它管理的内存划分为若干个不同的数据区域（包括5个运行时数据区）</strong></p>
<p><strong>1、方法区	2、虚拟机栈	3、本地方法栈	4、堆	5、程序计数器</strong></p>
<p>​    <img src="/1.jpg" alt="截图1"></p>
<p><strong>运行时数据区的完整图</strong></p>
<p>​    <img src="/2.jpg" alt="截图2"></p>
<p><strong>Java的内存区域</strong></p>
<p>​    <img src="/3.jpg" alt="截图3"></p>
<p><strong>灰色的为单独线程私有的，红色的为多个线程共享的。</strong></p>
<p><strong>即：</strong></p>
<p><strong>1、每个线程：独立包括程序计数器、虚拟机栈、本地方法栈。</strong></p>
<p><strong>2、线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</strong></p>
<p>​    <img src="/4.jpg" alt="截图4"></p>
<h1 id="线程的简单介绍"><a href="#线程的简单介绍" class="headerlink" title="线程的简单介绍"></a><strong>线程的简单介绍</strong></h1><p><strong>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</strong></p>
<p>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</p>
<p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。<strong>一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</strong></p>
<p><strong>JVM线程（*）</strong></p>
<p>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</p>
<ul>
<li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li>
<li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li>
<li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li>
<li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li>
</ul>
]]></content>
  </entry>
</search>
