<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01-什么是JVM?</title>
    <url>/2022/07/10/01-%E4%BB%80%E4%B9%88%E6%98%AFJVM/</url>
    <content><![CDATA[<h2 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a><strong>什么是JVM？</strong></h2><p><strong>①. JVM 是 java虚拟机，是用来执行java字节码(二进制的形式)的虚拟计算机</strong></p>
<p><strong>②. jvm是运行在操作系统之上的，与硬件没有任何关系</strong></p>
<p><img src="/2022/07/10/01-%E4%BB%80%E4%B9%88%E6%98%AFJVM/1.png" alt="1"></p>
<h2 id="Java的跨平台及原理"><a href="#Java的跨平台及原理" class="headerlink" title="Java的跨平台及原理"></a><strong>Java的跨平台及原理</strong></h2><p><strong>①. 跨平台：由Java编写的程序可以在不同的操作系统上运行：一次编写，多处运行</strong></p>
<p><strong>②. 原理：编译之后的字节码文件和平台无关，需要在不同的操作系统上安装一个对应版本的虚拟机(JVM)</strong></p>
<h2 id="JVM的整体的理解"><a href="#JVM的整体的理解" class="headerlink" title="JVM的整体的理解"></a><strong>JVM的整体的理解</strong></h2><p><strong>①. 类加载子系统</strong></p>
<p><strong>②. 运行时数据区(我们核心关注这里 的栈、堆、方法区)</strong></p>
<p><strong>③. 执行引擎(一般都是JIT编译器和解释器共存)</strong></p>
<p><img src="/2022/07/10/01-%E4%BB%80%E4%B9%88%E6%98%AFJVM/2.png" alt="2"></p>
<h2 id="java代码执行流程"><a href="#java代码执行流程" class="headerlink" title="java代码执行流程"></a><strong>java代码执行流程</strong></h2><p>​	<strong>java源码—java编译器—生成字节码—进入java虚拟机（类加载器—字节码校验器—翻译字节码—JIT编译器）</strong></p>
<h2 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a><strong>JVM的架构模型</strong></h2><p><strong>Java编译器输入的指令流基木上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。</strong></p>
<p><strong>基于栈式架构的特点</strong></p>
<ul>
<li>跨平台性</li>
<li>指令集小</li>
<li>指令多</li>
<li>执行性能比寄存器差</li>
</ul>
<p><strong>基于寄存器架构的特点</strong></p>
<ul>
<li>指令集架构则完全依赖硬件，可移植性差</li>
<li>性能优秀和执行更高效</li>
</ul>
<p><strong>举例</strong></p>
<p><strong>同样执行2+3这种逻辑操作，其指令分别如下：</strong></p>
<p><strong>1、基于栈的计算流程（以Java虚拟机为例)</strong></p>
<p><img src="/2022/07/10/01-%E4%BB%80%E4%B9%88%E6%98%AFJVM/3.png" alt="3"></p>
<p><strong>2、基于寄存器的计算流程</strong></p>
<p><img src="/2022/07/10/01-%E4%BB%80%E4%B9%88%E6%98%AFJVM/4.png" alt="4"></p>
<p><strong>总结</strong></p>
<p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a><strong>JVM的生命周期</strong></h2><p><strong>虚拟机的启动</strong></p>
<p><strong>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</strong></p>
<p><strong>虚拟机的执行</strong></p>
<ul>
<li><strong>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</strong></li>
<li><strong>程序开始执行时他才运行，程序结束时他就停止。</strong></li>
<li><strong>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</strong></li>
</ul>
<p><strong>虚拟机的退出</strong></p>
<ul>
<li><strong>程序正常执行结束</strong></li>
<li><strong>程序在执行过程中遇到了异常或错误而异常终止</strong></li>
<li><strong>由于操作系统用现错误而导致Java虚拟机进程终止</strong></li>
<li><strong>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</strong></li>
<li><strong>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</strong></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>02-类加载器和类加载过程</title>
    <url>/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a><strong>类加载过程</strong></h1><p><img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/1.png" alt="截图"></p>
<p><img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/20210311102359950.png" alt="20210311102359950"></p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a><strong>加载</strong></h2><p>1、通过一个类的全限定名获取定义此类的二进制字节流</p>
<p>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
<p>3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
<h2 id="链接：一共分为三个部分，验证、准备和解析"><a href="#链接：一共分为三个部分，验证、准备和解析" class="headerlink" title="链接：一共分为三个部分，验证、准备和解析"></a><strong>链接：一共分为三个部分，验证、准备和解析</strong></h2><h3 id="一、验证"><a href="#一、验证" class="headerlink" title="一、验证"></a><strong>一、验证</strong></h3><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身。</p>
<p>验证阶段是十分重要的，直接决定了Java虚拟机是否能承受恶意代码的攻击，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重。</p>
<p>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证</p>
<img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/%E6%88%AA%E5%9B%BE%20(1).png" alt="截图 (1)" style="zoom:67%;">

<h3 id="二、准备"><a href="#二、准备" class="headerlink" title="二、准备"></a><strong>二、准备</strong></h3><p>1、为类变量分配内存并且设置该变量的默认初始值，即零值。</p>
<p>2、这里不包括含用final修饰的static,因为final在编译的时候就会分配数值了，准备阶段会显式初始化。</p>
<p>3、这里不会为实例变量分配初始化，类变量会分配在方法区，而实例变量是会随着对象一起分配到java堆中。</p>
<h3 id="三、解析"><a href="#三、解析" class="headerlink" title="三、解析"></a><strong>三、解析</strong></h3><p>1、<strong>将常量池内的符号引用转换为直接引用过程</strong></p>
<p>2、实际上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</p>
<p>3、符号引用就是一组符号来描述所引用的目标。<strong>符号引用的字面形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</strong></p>
<p>4、主要解析动作针对类或接口、字段、类方法、接口方法、方法类型等。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h2><h3 id="1）初始化阶段就是执行类构造器方法-的过程"><a href="#1）初始化阶段就是执行类构造器方法-的过程" class="headerlink" title="1）初始化阶段就是执行类构造器方法()的过程"></a><strong>1）初始化阶段就是执行类构造器方法()的过程</strong></h3><p><strong>该方法不需要定义，而是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来的</strong></p>
<p><strong>构造器方法中的指令按照语句在源文件中出现的顺序来决定</strong></p>
<p><strong>变量已经赋过一次系统要求的初始零值，而在初始化阶段</strong></p>
<p><strong>则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。</strong></p>
<h3 id="2）若该类有父类，JVM会保证子子类的-执行前，父类的-已经执行完毕"><a href="#2）若该类有父类，JVM会保证子子类的-执行前，父类的-已经执行完毕" class="headerlink" title="2）若该类有父类，JVM会保证子子类的()执行前，父类的()已经执行完毕"></a>2）若该类有父类，JVM会保证子子类的()执行前，父类的()已经执行完毕</h3><p>虚拟机必须保证一个类的()方法在多线程下被同步加锁</p>
<img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/%E6%88%AA%E5%9B%BE%20(2).png" alt="截图 (2)" style="zoom:80%;">

<h3 id="3）在类加载的Linking链接的准备阶段，所有类变量以符号引用的方法存储在方法区"><a href="#3）在类加载的Linking链接的准备阶段，所有类变量以符号引用的方法存储在方法区" class="headerlink" title="3）在类加载的Linking链接的准备阶段，所有类变量以符号引用的方法存储在方法区"></a>3）在类加载的Linking链接的准备阶段，所有类变量以符号引用的方法存储在方法区</h3><p>而当静态代码尝试获取类变量时候需要通过直接引用，这就导致了编译的出错</p>
<h3 id="4）Java编译器并不会为所有的类都产生-初始化方法"><a href="#4）Java编译器并不会为所有的类都产生-初始化方法" class="headerlink" title="4）Java编译器并不会为所有的类都产生()初始化方法"></a>4）Java编译器并不会为所有的类都产生()初始化方法</h3><p>一个类中并没有声明任何的类变量,也没有静态代码块时</p>
<p>一个类中声明类变量,但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</p>
<p>一个类中包含static final修饰的基本数据类型的字段,这些类字段初始化语句采用编译时常量表达式 </p>
<p>(如果这个static final 不是通过方法或者构造器,则在链接阶段)</p>
<p>  <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/3.png" alt="截图 (3)"></p>
<h3 id="5）赋值的阶段性问题"><a href="#5）赋值的阶段性问题" class="headerlink" title="5）赋值的阶段性问题"></a><strong>5）赋值的阶段性问题</strong></h3><p> <strong>在链接阶段的准备环节赋值的情况:</strong></p>
<p><strong>1、对于基本数据类型的字段来说,如果使用static final修饰,则显式赋值(直接赋值常量,而非调用方法)通常是在链接阶段的准备环节进行</strong></p>
<p><strong>2、对于String来说,如果使用字面量的方式赋值,使用static final修饰的话,则显式赋值通常是在链接阶段的准备环节进行</strong></p>
<p><strong>3、使用static + final修饰,且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值,是在链接阶段的准备环节进行。</strong></p>
<p><strong>在初始化阶段()中赋值的情况:</strong></p>
<p><strong>排除上述的在准备环节赋值的情况之外的情况</strong></p>
<p><img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/4.png" alt="截图 (4)"></p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a><strong>类加载器</strong></h1> <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/%E6%88%AA%E5%9B%BE%20(5).png" alt="截图 (5)" style="zoom:80%;">

<h2 id="引导-启动-类加载器"><a href="#引导-启动-类加载器" class="headerlink" title="引导(启动)类加载器"></a><strong>引导(启动)类加载器</strong></h2><p>这个类加载使用C&#x2F;C++语言实现的,嵌套在JVM内部</p>
<p><strong>1、它用来加载Java的核心类库(JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resource.jar或sum.boot.class.path路径下的内容)</strong></p>
<p><strong>用于提供JVM自身需要的类(String类就是使用的这个类加载器)</strong></p>
<p>2、由于安全考虑,Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p>
<p>3、并不继承自java.lang.ClassLoader,没有父加载器</p>
<p><strong>4、加载扩展类和应用程序类加载器,并指定为他们的父类加载器</strong></p>
<p><strong>自定义加载器****（将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器）</strong></p>
<p>1、Java语言编写</p>
<p><strong>2、派生于ClassLoader类,父类加载器为启动类加载器</strong></p>
<p>3、从java.ext.dirs系统属性所指定的目录中加载类库,或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录(扩展目录)下加载类库。</p>
<p>如果用户创建的JAR放在此目录下,也会自动由扩展类加载器加载</p>
<h2 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a><strong>扩展类加载器</strong></h2><p>1、Java语言编写</p>
<p><strong>2、派生于ClassLoader类,父类加载器为启动类加载器</strong></p>
<p>3、从java.ext.dirs系统属性所指定的目录中加载类库,或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录(扩展目录)下加载类库</p>
<p>如果用户创建的JAR放在此目录下,也会自动由扩展类加载器加载</p>
<h2 id="应用程序-系统-类加载器-AppClassLoader"><a href="#应用程序-系统-类加载器-AppClassLoader" class="headerlink" title="应用程序(系统)类加载器 AppClassLoader"></a><strong>应用程序(系统)类加载器 AppClassLoader</strong></h2><p>1、java语言编写</p>
<p><strong>2、派生于ClassLoader类,父类加载器为扩展类加载器</strong></p>
<p><strong>3、它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</strong></p>
<p><strong>4、该类加载是程序中默认的类加载器</strong></p>
<p>5、通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</p>
<h2 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a><strong>用户自定义类加载器</strong></h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a><strong>目的</strong></h3><p>隔离记载类</p>
<p>修改类的加载方式</p>
<p>扩展加载源</p>
<p>防止源码泄露</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h3><p><strong>1）重写 loadClass() 方法（不推荐,这个方法会保证类的双亲委派机制）</strong></p>
<p><strong>2）重写 findClass() 方法 –&gt;推荐</strong></p>
<p><strong>这两种方法本质上差不多,毕竟loadClass()也会调用findClass(),但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法,根据参数指定类的名字,返回对应的Class对象的引用</strong></p>
<p><strong>获取ClassLoader的方法</strong></p>
<p><img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/6.png" alt="截图 (6)"></p>
<p>​    <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/7.png" alt="截图 (7)"></p>
<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a><strong>双亲委派机制</strong></h1><p><em>java虚拟机对class文件采用按需加载的方式进行加载，当需要使用该类时才会将它的class文件加载到内存中生成class对象</em></p>
<p><em>在加载这个类的时候，采用的就是双亲委派模式。</em></p>
<p><strong>1、如果</strong> <strong>一个类加载收到了类加载请求,它并不会自己先去加载</strong> <strong>,而是把这个请求</strong> <strong>委托给父类加载器去执行</strong></p>
<p><strong>2、如果</strong> <strong>父类加载器还存在其父类加载器</strong> <strong>,则进一步</strong> <strong>向上委托</strong> <strong>,依次递归,请求最终将</strong> <strong>到达顶层的启动类加载器</strong></p>
<p><strong>3、如果父类的加载器可以完成类的加载任务,就成功返回,倘若</strong> <strong>父类加载器无法完成此加载任务,子加载器才会尝试自己去加载,</strong> <strong>这就是双亲委派模式</strong></p>
<p>​    <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/20210509161013261.png" alt="20210509161013261"></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><strong>源码分析</strong></h2><p><strong>（双亲委派机制在 java.lang.ClassLoader.loadClass(String,boolean) 中体现）</strong></p>
<p><em>1、先在<strong>当前加载器的缓存</strong>中*<em>查找有无目标类</em></em>,如果有,直接返回。*</p>
<p><em>2、判断当前加载器的父加载器是否为空</em> <em>,如果不为空,则调用 parent.loadClass(name, false) 接口进行加载</em></p>
<p><em>3、反之,如果当前加载器的父类加载器为空,则调用 findBootstrapClassOrNull(name) 接口,让引导类加载器进行加载</em></p>
<p><em>4、如果通过以上3条路径都没能成功加载,则调用 findClass(name) 接口进行加载。该接口最终会调用 java.lang.ClassLoader 接口的 defineClass 系列的native接口加载目标Java类。</em></p>
<p><strong>双亲委派的模型就隐藏在这第2和第3步中</strong></p>
<h2 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a><strong>双亲委派机制的优势</strong></h2><p><strong>1、避免类的重复加载，确保一个类的全局唯一性（当父ClassLoader已经加载了该类的时候,就没有必要子ClassLoader再加载一次）</strong></p>
<p><strong>2、保护程序的安全，防止API随意被篡改</strong></p>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a><strong>沙箱安全机制</strong></h2><p><strong>Java代码限定在</strong><a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020"><strong>虚拟机</strong></a><strong>JVM特定的运行范围中，并且严格限制代码对本地资源的访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏</strong></p>
<p>​    <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/%E6%88%AA%E5%9B%BE%20(8).png" alt="截图 (8)" style="zoom:80%;"></p>
<h1 id="类的使用方式"><a href="#类的使用方式" class="headerlink" title="类的使用方式"></a><strong>类的使用方式</strong></h1><p><strong>java虚拟机在每个类或接口被java程序“首次主动使用”时才初始化它们。被动使用不会初始化类，但又可能会加载类</strong></p>
<p><strong>在加载的过程中，遇到.class文件的缺失或者存在错误，类加载器只会在首次主动使用它们时才会报错，如果一直没使用，则不会报错</strong></p>
<h2 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a><strong>主动使用</strong></h2><p><strong>1、创建类的实例</strong>	</p>
<p><strong>2、访问某个类或接口的静态变量，或者对该静态变量赋值</strong>	</p>
<p><strong>3、调用类的静态方法</strong></p>
<p><strong>4、反射</strong></p>
<p><strong>5、初始化一个类的子类</strong></p>
<p><strong>6、java虚拟机启动时被标明为启动类的类</strong></p>
<p><strong>注意：</strong> <strong>初始化一个类的子类这条规则，不适用于接口，即：初始化一个类的子类，会先初始化它的父类，但是不一定会初始化它的接口。只有当首次使用该接口的静态变量时，才会初始化。</strong></p>
<h2 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a><strong>被动使用</strong></h2><p><strong>除了主动使用的其他使用方式，例如：</strong></p>
<p><strong>1）通过子类引用父类的静态字段，为子类的被动使用，不会导致子类初始化</strong></p>
<p><strong>2）通过数组定义类引用类，为类的被动使用，不会触发此类的初始化</strong></p>
<p>​    <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/9.png" alt="截图 (9)"></p>
<p><strong>3）常量在编译阶段会存入调用方法所在的类的常量池中（这个例子存在F类的常量池中）</strong></p>
<p><strong>本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</strong></p>
<p>  <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/10.png" alt="截图 (10)"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>03-数据区概述与线程</title>
    <url>/2022/07/12/03-%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a><strong>数据区</strong></h1><p><strong>JVM在执行java程序的过程中会把它管理的内存划分为若干个不同的数据区域（包括5个运行时数据区）</strong></p>
<p><strong>1、方法区	2、虚拟机栈	3、本地方法栈	4、堆	5、程序计数器</strong></p>
<p>​    <img src="/2022/07/12/03-%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%BA%BF%E7%A8%8B/1.jpg" alt="截图1"></p>
<p><strong>运行时数据区的完整图</strong></p>
<p>​    <img src="/2022/07/12/03-%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%BA%BF%E7%A8%8B/2.jpg" alt="截图2"></p>
<p><strong>Java的内存区域</strong></p>
<p>​    <img src="/2022/07/12/03-%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%BA%BF%E7%A8%8B/3.jpg" alt="截图3"></p>
<p><strong>灰色的为单独线程私有的，红色的为多个线程共享的。</strong></p>
<p><strong>即：</strong></p>
<p><strong>1、每个线程：独立包括程序计数器、虚拟机栈、本地方法栈。</strong></p>
<p><strong>2、线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</strong></p>
<p>​    <img src="/2022/07/12/03-%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%BA%BF%E7%A8%8B/4.jpg" alt="截图4"></p>
<h1 id="线程的简单介绍"><a href="#线程的简单介绍" class="headerlink" title="线程的简单介绍"></a><strong>线程的简单介绍</strong></h1><p><strong>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</strong></p>
<p>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</p>
<p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。<strong>一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</strong></p>
<p><strong>JVM线程（*）</strong></p>
<p>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</p>
<ul>
<li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li>
<li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li>
<li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li>
<li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>04-程序计数器</title>
    <url>/2022/07/12/04-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    <content><![CDATA[<h1 id="程序计数器（PC寄存器）"><a href="#程序计数器（PC寄存器）" class="headerlink" title="程序计数器（PC寄存器）"></a><strong>程序计数器</strong>（PC寄存器）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>既不存在GC也不存在OOM</strong></p>
<p><strong>PC寄存器用来存储指向下一条指令的地址，也是即将要执行的指令代码</strong>。由执行引擎读取下一条指令</p>
<p>它是一块<strong>很小的内存空间</strong>，几乎可以忽略不记。也是<strong>运行速度最快的存储区域</strong>。</p>
<p>在JVM规范中，每个线程都有它自己的程序计数器，是<strong>线程私有的</strong>，生命周期与线程的生命周期保持一致。</p>
<p>  <img src="/2022/07/12/04-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/1.jpg" alt="截图1"></p>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a><strong>代码演示</strong></h2><p>   <img src="/2022/07/12/04-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/2.jpg" alt="截图2"></p>
<p>   <img src="/2022/07/12/04-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/3.jpg" alt="截图3"></p>
<p><strong>通过PC寄存器，我们就可以知道当前程序执行到哪一步了</strong></p>
<p>​    <img src="/2022/07/12/04-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/4.jpg" alt="截图4"></p>
<h2 id="使用PC寄存器存储字节码地址有什么用？（为什么要使用PC寄存器记录当前线程的执行地址呢？）"><a href="#使用PC寄存器存储字节码地址有什么用？（为什么要使用PC寄存器记录当前线程的执行地址呢？）" class="headerlink" title="使用PC寄存器存储字节码地址有什么用？（为什么要使用PC寄存器记录当前线程的执行地址呢？）"></a><strong>使用PC寄存器存储字节码地址有什么用？（为什么要使用PC寄存器记录当前线程的执行地址呢？</strong>）</h2><p><strong>1、CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</strong></p>
<p><strong>2、JVM的字节码解释器需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</strong></p>
<h2 id="PC寄存器为什么被设定为线程私有的？"><a href="#PC寄存器为什么被设定为线程私有的？" class="headerlink" title="PC寄存器为什么被设定为线程私有的？"></a><strong>PC寄存器为什么被设定为线程私有的？</strong></h2><p><strong>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</strong></p>
<p><strong>这样必然导致经常中断或恢复，为了保证分毫无差。每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</strong></p>
<p> <img src="/2022/07/12/04-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/5.jpg" alt="截图5"></p>
<p><strong>比如一个cpu负责3个线程，cpu会在3个线程间轮流执行，为了能够保证CPU在切换的过程中，每个线程都可以按照切换之前的指令继续执行，而不影响其他线程，所以PC寄存器设定为线程私有的</strong></p>
<h2 id="CPU时间片（-）"><a href="#CPU时间片（-）" class="headerlink" title="CPU时间片（*）"></a><strong>CPU时间片（*）</strong></h2><p>   <img src="/2022/07/12/04-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/6.jpg" alt="截图6"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>06-本地方法栈和本地方法</title>
    <url>/2022/07/12/06-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a><strong>本地方法</strong></h1><p><strong>实际上是一个java调用非java代码的一个接口</strong> <strong>（</strong> <strong>使用native关键字进行修饰</strong> ）</p>
<p>本地方法的作用：</p>
<p>1、Java应用与Java外面的环境交互</p>
<p>2、与操作系统进行交互</p>
<p>3、Sun公司解释器由C实现</p>
<h1 id="本地方法栈-（线程私有）"><a href="#本地方法栈-（线程私有）" class="headerlink" title="本地方法栈 （线程私有）"></a><strong>本地方法栈</strong> <strong>（线程私有）</strong></h1><p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</p>
<p>本地方法栈中登记本地方法，然后执行引擎执行时，加载本地方法库</p>
<p>当某一个线程调用本地方法时</p>
<p>本地方法可通过本地方法接口来访问虚拟机内部的运行时数据区</p>
<p>可以使用本地处理器中的寄存器</p>
<p>……（和虚拟机拥有一样的权限）</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>01-设计模式的原则</title>
    <url>/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a><strong>设计模式的目的</strong></h1><p><strong>1、代码重用性</strong></p>
<p><strong>2、可读性</strong></p>
<p><strong>3、可扩展性（增加功能时，对原来的功能没有影响）</strong></p>
<p><strong>4、可靠性（增加功能时，对原来的功能没有影响）</strong></p>
<p><strong>5、高内聚，低耦合</strong></p>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a><strong>单一职责原则</strong></h2><p><strong>一个类应该只负责一项职责</strong></p>
<p>如：类 A 负责两个不同职责：职责 1，职责 2。</p>
<p>当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2</p>
<p><strong>注意：</strong></p>
<ul>
<li>降低类的复杂度，一个类负责一个职责</li>
<li>提高类的可读性</li>
<li>降低变更的风险</li>
</ul>
<p>只有类中方法数量足够少时，可以在方法级别保持单一职责原则</p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/1.png" alt="0"></p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/2.png" alt="0"></p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/3.png" alt="0"></p>
<h2 id="接口隔离的原则"><a href="#接口隔离的原则" class="headerlink" title="接口隔离的原则"></a><strong>接口隔离的原则</strong></h2><p><strong>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</strong></p>
<p>类A和类C只需要依赖接口1的一部分接口，而不需要实现全部，所以可以将接口 Interface1 拆分为独立的几个接口(这里我们拆分成 3 个接口)，类 A 和类 C 分别与他们需要的接口建立依赖关系</p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/4.png" alt="0"></p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/5.png" alt="0"></p>
<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a><strong>依赖倒转原则</strong></h2><p>1）高层模块不应该依赖底层模块，二者都应该依赖其抽象</p>
<p>2）抽象不应该依赖细节，细节应该依赖抽象</p>
<p><strong>3）核心思想：面向接口编程</strong></p>
<p>三种方式：接口传递，构造方法传递，setter方法传递</p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/6.png" alt="0"></p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/7.png" alt="0"></p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a><strong>里氏替换原则</strong></h2><p><strong>继承给程序设计带来便利也带来了弊端：</strong></p>
<ul>
<li>使用继承会给程序带来侵入性</li>
<li>可移植性降低</li>
<li>增加对象间的耦合</li>
<li>当这个类要修改时，必须考虑到所有的子类</li>
</ul>
<p><strong>正确使用继承：</strong></p>
<ul>
<li>使用继承时，在子类中尽量不要重写父类的方法</li>
<li>在适当的情况，可以使用聚合，组合，依赖来解决</li>
</ul>
<p><strong>解决方法：让原来的子类和父类都继承一个更通俗的基类，将原有的继承关系去掉，采用聚合，组合，依赖等关系来代替</strong></p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/8.png" alt="0"></p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/9.png" alt="0"></p>
<h2 id="开闭原则-（最基础，最重要）"><a href="#开闭原则-（最基础，最重要）" class="headerlink" title="开闭原则 （最基础，最重要）"></a><strong>开闭原则</strong> <strong>（最基础，最重要）</strong></h2><p><strong>比如一个类，模块和函数一个对扩展开发（对提供方），对修改关闭（对使用方）。</strong></p>
<p><strong>当软件需要变化，尽量通过扩展代码，而不是通过修改已有代码的方法实现</strong></p>
<p><strong>案例：</strong></p>
<p>如果需要增加新的功能，绘制别的图形，需要在使用方处修改代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ocp</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">//使用看看存在的问题</span></span><br><span class="line">      <span class="type">GraphicEditor</span> <span class="variable">graphicEditor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GraphicEditor</span>();</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Rectangle</span>());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Circle</span>());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Triangle</span>());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span> &#123;</span><br><span class="line">   <span class="comment">//接收Shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape s)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (s.m_type == <span class="number">1</span>)</span><br><span class="line">         drawRectangle(s);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>)</span><br><span class="line">         drawCircle(s);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">3</span>)</span><br><span class="line">         drawTriangle(s);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//绘制矩形</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(Shape r)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//绘制圆形</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(Shape r)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//绘制三角形</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawTriangle</span><span class="params">(Shape r)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="type">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   Rectangle() &#123;</span><br><span class="line">      <span class="built_in">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   Circle() &#123;</span><br><span class="line">      <span class="built_in">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   Triangle() &#123;</span><br><span class="line">      <span class="built_in">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>改进：</strong></p>
<p>创建一个抽象类Shape，提供一个抽象方法drow，然后让子类去继承该抽象方法，重写该抽象方法，当需要增加新的功能的时候，只需要创建一个新的类去继承抽象方法并重写即可，无需对使用方代码进行改动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ocp</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">//使用看看存在的问题</span></span><br><span class="line">      <span class="type">GraphicEditor</span> <span class="variable">graphicEditor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GraphicEditor</span>();</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Rectangle</span>());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Circle</span>());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Triangle</span>());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">OtherGraphic</span>());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span> &#123;</span><br><span class="line">   <span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape s)</span> &#123;</span><br><span class="line">      s.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="type">int</span> m_type;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   Rectangle() &#123;</span><br><span class="line">      <span class="built_in">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   Circle() &#123;</span><br><span class="line">      <span class="built_in">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   Triangle() &#123;</span><br><span class="line">      <span class="built_in">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增一个图形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OtherGraphic</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   OtherGraphic() &#123;</span><br><span class="line">      <span class="built_in">super</span>.m_type = <span class="number">4</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制其它图形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="迪米特法则-（最少知道原则）"><a href="#迪米特法则-（最少知道原则）" class="headerlink" title="迪米特法则 （最少知道原则）"></a><strong>迪米特法则</strong> <strong>（最少知道原则）</strong></h2><p> <strong>一个对象应该对其他对象保持最少的了解</strong></p>
<p>每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，则这两个对象之间是朋友关系</p>
<p>其中，出现成员变量，方法参数，方法返回值中的类为直接的朋友</p>
<p>迪米特法则只要要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系</p>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a><strong>合成复用原则</strong></h2><p><strong>尽量使用合成或者聚合的方式，而不是使用继承</strong></p>
<p>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起</p>
<p><strong>针对接口编程，而不是针对具体实现编程</strong></p>
<p><strong>松耦合设计</strong></p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/10.png" alt="0"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>05-虚拟机栈及相关问题</title>
    <url>/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="虚拟机栈-（线程私有）"><a href="#虚拟机栈-（线程私有）" class="headerlink" title="虚拟机栈 （线程私有）"></a><strong>虚拟机栈</strong> <strong>（线程私有）</strong></h1><p> <img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/1.jpg" alt="0"></p>
<p><strong>不存在GC，存在OOM</strong></p>
<p>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧，对应着一次次的方法调用</p>
<p>虚拟机栈的生命周期和线程一致。作用是主管java程序的运行，保存方法的局部变量（8种基本数据类型，对象的引用地址，对象实际存储在堆空间中），部分结果，并参与方法的调用和返回</p>
<p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</p>
<h2 id="JVM直接对栈的操作："><a href="#JVM直接对栈的操作：" class="headerlink" title="JVM直接对栈的操作："></a>JVM直接对栈的操作：</h2><p><strong>1、每个方法执行，伴随着进栈（入栈，压栈）</strong></p>
<p>2、执行结束后的出栈操作</p>
<h2 id="设置栈内存的大小"><a href="#设置栈内存的大小" class="headerlink" title="设置栈内存的大小"></a><strong>设置栈内存的大小</strong></h2><p>使用参数-Xss选项设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p>
<h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a><strong>栈的存储单位</strong></h2><p><strong>1）栈中的数据都是以栈帧为基本单位存在</strong></p>
<p><strong>2）在这个线程上正在执行的每个方法都各自对应着一个栈帧</strong></p>
<p><strong>3）栈帧是一个内存区块，是一个数据集，****维系着方法执行过程中的各种数据信息</strong></p>
<p><strong>4）在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧，与当前栈帧相对应的方法就是当前方法，定义这个方法的类就是当前类。</strong></p>
<p><strong>5）执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</strong></p>
<p><strong>6）如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</strong></p>
<p>​    <img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/2.jpg" alt="0"></p>
<h2 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a><strong>栈帧的内部结构</strong></h2><p><strong>每个栈帧都存储着：</strong></p>
<ol>
<li><strong>局部变量表</strong></li>
<li><strong>操作数栈（表达式栈）</strong></li>
<li>动态链接（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（或方法正常退出或异常退出的定义）</li>
<li>一些附加信息</li>
</ol>
<p>方法嵌套调用的次数由栈的大小决定，栈越大，方法嵌套调用的次数就越多。</p>
<p>对于一个函数，参数和局部变量越多，局部变量表就会膨胀，栈帧就越大</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a><strong>局部变量表</strong></h3><p>1、存放编译器的各种基本数据类型（8种）引用类型（reference）returnAddress类型的变量</p>
<p>2、定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</p>
<p>3、由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</p>
<p>4、局部变量表所需的容量大小是在编译器就确定下来的（一旦确定就不会更改）</p>
<p><strong>注意：局部变量表中的变量只在当前方法调用中有效，当方法调用结束后，随着方法栈帧的销毁，局部变量表也会销毁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 字节码中方法内部结构的剖析</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> hzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/7/11 14:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">//使用javap -v 类.class 或者使用jclasslib</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVariableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LocalVariableTest test=<span class="keyword">new</span> <span class="title class_">LocalVariableTest</span>();</span><br><span class="line">        <span class="type">int</span> num=<span class="number">10</span>;</span><br><span class="line">        test.test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        String name=<span class="string">&quot;xiaozhi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/3.jpg" alt="0"></p>
<p>​    <img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/4.jpg" alt="0"></p>
<p>​    <img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/5.jpg" alt="0"></p>
<p><strong>比如此处，num对应的起始pc是8，对应代码的实际行数第14行，字节码指令长度是17</strong></p>
<p><strong>所以起始pc加上长度就是字节码的指令长度</strong></p>
<h4 id="textcolor-red-局部变量表的基本存储单元是Slot-变量槽"><a href="#textcolor-red-局部变量表的基本存储单元是Slot-变量槽" class="headerlink" title="textcolor{red}{局部变量表的基本存储单元是Slot(变量槽)"></a>textcolor{red}{局部变量表的基本存储单元是Slot(变量槽)</h4><ul>
<li>32位以内的类型只占用一个Slot（包括returnAddress类型）</li>
<li>64位的类型占用两个Slot（long和double）</li>
<li>byte，short，char在存储前转化为int</li>
<li>boolean也被转换为int，0表示false，1表示true</li>
<li>JVM会为局部变量中的每一个Slot都分配一个访问索引，通过这个索引可以访问局部变量中指定的值</li>
</ul>
<p>​    <img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/6.jpg" alt="0"></p>
<p><strong>如果需要访问一个64bit的局部变量值时，只需要使用前一个索引即可</strong></p>
<p><strong>如果当前帧是由构造方法或者实例的方法进行创建的，那么该对象引用this将会存放在index为0的Slot处，其余的继续排列</strong></p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>​    <img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/7.jpg" alt="0"></p>
<p>*<em>this代表对象实例，而static是随类的加载而加载，先于实例之前就有的，所以不存在于局部变量表中，所以不能使用。</em></p>
<p><strong>变量的分类	一、按照数据类型分：1、基本数据类型		2、引用数据类型</strong></p>
<p><strong>二、按照在类中声明的位置分：	1、成员变量：在使用前都经过默认初始化赋值</strong></p>
<p>​    	  		<strong>类变量：linking的prepare阶段，给类变量默认赋值  —&gt;  initial阶段，给类变量显式赋值即静态代码块赋值</strong></p>
<pre><code>           **实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值**
   
       **2、局部变量：使用前必须进行显示赋值，否则编译不通过**
</code></pre>
<p><strong>局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中的直接或间接引用的对象都不会被回收</strong></p>
<h3 id="操作数（表达式）栈"><a href="#操作数（表达式）栈" class="headerlink" title="操作数（表达式）栈"></a><strong>操作数（表达式）栈</strong></h3><ol>
<li>每一个独立的栈帧中除了包含局部变量表以外，还包含了一个后进先出的操作数栈，也可以称之为表达式栈</li>
<li>在方法执行的过程中，根据字节码指令，往栈中写入数据（入栈）或提取数据（出栈）</li>
<li>主要用于保存计算过程的中间结果，同时作为计算机过程中变量临时的存储空间</li>
<li>当一个方法开始执行的时候，一个新的栈帧也会被创建出来，这个方法的操作数栈是空的</li>
<li>每一个操作数栈都会拥有一个栈深度用于存储数值（max_stack）32bit类型占用一个栈单位深度，64bit类型占用两个栈单位深度</li>
<li>操作数栈不是通过访问索引的方式来进行数据访问的，而只能通过标准的入栈出栈来进行数据访问</li>
</ol>
<h4 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a><strong>代码追踪</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/8.jpg" alt="0"></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/9.jpg" alt="0"></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/10.jpg" alt="0"></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/11.jpg" alt="0"></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/12.jpg" alt="0"></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/13.jpg" alt="0"></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/14.jpg" alt="0"></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/15.jpg" alt="0"></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/16.jpg" alt="0"></p>
<h4 id="操作数栈的最大深度"><a href="#操作数栈的最大深度" class="headerlink" title="操作数栈的最大深度"></a><strong>操作数栈的最大深度</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperandStackTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//byte、short、char、boolean:都以int型保存</span></span><br><span class="line">        <span class="type">byte</span> i=<span class="number">15</span>;</span><br><span class="line">        <span class="type">short</span> j=<span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> k=i+j;</span><br><span class="line">        <span class="type">long</span> m=<span class="number">12L</span>;</span><br><span class="line">        <span class="type">int</span> n=<span class="number">800</span>;</span><br><span class="line">        <span class="comment">//存在宽化类型转换</span></span><br><span class="line">        m=m*n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/17.jpg" alt="0"></p>
<h4 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a><strong>栈顶缓存技术</strong></h4><p>为了解决指令过多导致频繁地执行内存读&#x2F;写操作，影响执行速度的问题</p>
<p>将栈顶元素全部缓存在物理CPU的寄存器中,以此降低对内存的读&#x2F;写次数</p>
<p><strong>(将计算的操作放到CPU寄存器里面去)</strong></p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a><strong>动态链接</strong></h3><p>栈帧内部包含了一个指向运行时常量池中该栈帧所属方法的引用—动态链接</p>
<p>每一个栈帧内部都包含一个指向运行时常量池Constant pool或该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如invokedynamic指令</p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/18.jpg" alt="0"></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/19.jpg" alt="0"></p>
<p>动态链接的作用就是为了将这些符号引用(#)最终转换为调用方法的直接引用</p>
<h4 id="方法的调用："><a href="#方法的调用：" class="headerlink" title="方法的调用："></a><strong>方法的调用：</strong></h4><ul>
<li>静态链接：在字节码文件装载进JVM内部时，被调用的方法在编译期可知，而且在运行的期间保持不变，这时候符号引用就会转换为直接引用。这个过程即为静态链接</li>
<li>动态链接：被调用的方法在编译期不可确定，在程序运行的期间才将符号引用进行转换，这个过程为动态链接</li>
<li>绑定：一个字段，方法，类在符号引用转换为直接引用的过程</li>
<li>早期绑定：被调用的目标方法在编译期内可知，运行期间不变</li>
<li>晚期绑定：调用方法在编译期无法确定，到运行期才确定</li>
<li>非虚方法：在编译器确定调用的版本，这个版本运行时不变，比如：静态方法，私有方法，final方法，实例构造器，父类方法</li>
<li>虚方法：其他</li>
</ul>
<h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a><strong>虚方法表</strong></h4><p><strong>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</strong></p>
<p><strong>如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中</strong></p>
<p><strong>虚方法表会在类加载的链接阶段被创建并开始初始化</strong> <strong>，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</strong></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/20.jpg" alt="0"></p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a><strong>方法返回地址</strong></h3><p><em><strong>存储调用该方法的PC寄存器的值</strong></em></p>
<p><em><strong>在方法推出后都会返回到该方法被调用的位置。</strong></em></p>
<p><em><strong>方法正常退出时，调用者的PC计数器的值作为返回地址（调用该方法的指令的下一条指令的地址）</strong></em></p>
<p><em><strong>方法异常退出时，返回地址通过异常表来确定</strong></em></p>
<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a><strong>相关问题</strong></h2><p><strong>1、举例栈溢出的情况：通过-Xss设置栈的大小（OOM）</strong></p>
<p><strong>2、调整栈大小，就能保证不出现溢出吗？不能</strong></p>
<p><strong>3、分配的栈内存越大越好吗？不是，栈空间大了线程数就少了，栈空间和线程数目成反比</strong></p>
<p><strong>4、垃圾回收是否会涉及到虚拟机栈？不会</strong></p>
<p><strong>5、方法中定义的局部变量是否线程安全？看情况</strong></p>
<p><strong>6、代码演示：（内部产生，在内部消亡，线程安全）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//s1的声明方式是线程安全的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//StringBuilder线程不安全</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//s2的操作过程是线程不安全的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder s2)</span>&#123;</span><br><span class="line">    s2.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//s3的操作是线程不安全的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    s3.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> s3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//s4的操作是线程安全的,s4其实在内部消亡了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    s4.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> s4.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">        s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    method2(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>1-1-数据结构分类</title>
    <url>/2022/07/12/1-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="数据结构分类："><a href="#数据结构分类：" class="headerlink" title="数据结构分类："></a><strong>数据结构分类：</strong></h2><ul>
<li>顺序存储结构： 把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的 ，比如我们常用的数组就是顺序存储结构。</li>
</ul>
<p>​    <img src="/2022/07/12/1-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB/1.png" alt="0" style="zoom:67%;"></p>
<ul>
<li>链式存储结构： 是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。此时，数据元素之间并 不能反映元素间的逻辑关系，因此在链式存储结构中引进了一个指针存放数据元素的地址，这样通过地址就可以找 到相关联数据元素的位置</li>
</ul>
<h2 id="逻辑结构分类："><a href="#逻辑结构分类：" class="headerlink" title="逻辑结构分类："></a><strong>逻辑结构分类：</strong></h2><ul>
<li>集合结构：集合结构中数据元素除了属于同一个集合外，他们之间没有任何其他的关系。</li>
<li>线性结构：线性结构中的数据元素之间存在一对一的关系</li>
<li>树形结构：树形结构中的数据元素之间存在一对多的层次关系</li>
<li>图形结构：图形结构的数据元素是多对多的关系</li>
</ul>
<p><img src="/2022/07/12/1-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB/2.png" alt="0" style="zoom: 67%;">  <img src="/2022/07/12/1-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB/3.png" alt="0" style="zoom: 67%;"></p>
<p><img src="/2022/07/12/1-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB/4.png" alt="0" style="zoom: 67%;">  <img src="/2022/07/12/1-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB/5.png" alt="0" style="zoom: 67%;"></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>1-nginx-目录，配置文件</title>
    <url>/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="使用-工具tree查看目录结构"><a href="#使用-工具tree查看目录结构" class="headerlink" title="使用 工具tree查看目录结构"></a><strong>使用</strong> <strong>工具tree查看目录结构</strong></h2><p><strong>1、安装tree工具：</strong> <strong>yum install -y tree</strong></p>
<p><strong>2、</strong> <strong>tree &#x2F;usr&#x2F;local&#x2F;nginx</strong> <strong>(tree后面跟的是Nginx的安装目录)</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/1.png" alt="0"></p>
<h2 id="查看进程的PID"><a href="#查看进程的PID" class="headerlink" title="查看进程的PID"></a><strong>查看进程的PID</strong></h2><p><strong>1、查看nginx的master进程和worker进程：</strong> <strong>ps -ef | grep nginx</strong></p>
<p><strong>2、nginx的.&#x2F;configure的配置参数的时候，有一个参数是–pid-path&#x3D;PATH默认是</strong> <strong>&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid</strong></p>
<p><strong>所以可以通过查看该文件来获取nginx的master进程ID</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/2.png" alt="0"></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/3.png" alt="0"></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/4.png" alt="0"></p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a><strong>信号</strong></h2><table>
<thead>
<tr>
<th><strong>信号</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>TERM或INT</strong></td>
<td><strong>立即关闭整个服务</strong></td>
</tr>
<tr>
<td><strong>QUIT</strong></td>
<td><strong>“优雅”地关闭整个服务</strong></td>
</tr>
<tr>
<td><strong>HUP</strong></td>
<td><strong>重读配置文件并使用服务对新配置项生效</strong></td>
</tr>
<tr>
<td><strong>USR1</strong></td>
<td><strong>重新打开日志文件，可以用来进行日志切割</strong></td>
</tr>
<tr>
<td><strong>USR2</strong></td>
<td><strong>平滑升级</strong> <strong>到最新版的nginx</strong></td>
</tr>
<tr>
<td><strong>WINCH</strong></td>
<td><strong>所有子进程不在接收处理新连接相当于给work进程发送QUIT指令</strong></td>
</tr>
</tbody></table>
<h3 id="调用命令为-kill-signal-PID"><a href="#调用命令为-kill-signal-PID" class="headerlink" title="调用命令为 kill -signal PID"></a><strong>调用命令为</strong> <strong>kill -signal PID</strong></h3><p><strong>1、发送</strong>  <strong>TERM 或 INT</strong>  <strong>信号给master进程，会将Nginx服务</strong> <strong>立即关闭</strong> <strong>。</strong></p>
<p><strong>2、发送</strong>  <strong>QUIT</strong>  <strong>信号给master进程，master进程会控制所有的work进程不再接收新的请求，</strong> <strong>等所有请求处理完后，在把进程都关闭掉</strong></p>
<p><strong>3、发送</strong>  <strong>HUP</strong>  <strong>信号给master进程，master进程会把控制旧的work进程不再接收新的请求，等处理完请求后将旧的work进程关闭掉，然后根据nginx的配置文件重新启动新的work进程</strong></p>
<p><strong>4、发送</strong>  <strong>USR1</strong>  <strong>信号给master进程，告诉Nginx重新开启日志文件</strong></p>
<p><strong>5、</strong> <strong>发送</strong>  <strong>USR2</strong>  <strong>信号给master进程，</strong> <strong>重新开启对应的master进程和work进程</strong> <strong>，这时系统里会有两个master进程和四个master进程</strong></p>
<p><strong>新的master进程的PID会被记录在			&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid</strong></p>
<p><strong>而之前的旧的master进程PID会被记在	&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid.oldbin文件中</strong></p>
<p><strong>最后再发送  QUIT  信号给旧的master进程</strong></p>
<p><strong>6、发送</strong>  <strong>WINCH</strong>  <strong>信号给master进程,让master进程控制不让所有的work进程在接收新的请求了</strong></p>
<p><strong>请求处理完后关闭work进程。</strong> <strong>注意master进程不会被关闭掉</strong></p>
<h3 id="nginx命令行控制"><a href="#nginx命令行控制" class="headerlink" title="nginx命令行控制"></a><strong>nginx命令行控制</strong></h3><p><strong>在sbin目录下，可以对nginx进行状态控制</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/5.png" alt="0"></p>
<p><strong>.&#x2F;nginx-v			查看版本号信息</strong>		</p>
<p><strong>.&#x2F;nginx-V			查看版本号信息和配置信息</strong></p>
<p><strong>.&#x2F;nginx-t			测试配置文件语法是否正确</strong></p>
<p><strong>.&#x2F;nginx-T			测试nginx的配置文件语法是否正确并列出用到的配置文件信息然后退出</strong></p>
<p><strong>.&#x2F;nginx-q			在配置测试期间禁止显示非错误消息</strong>	</p>
<p><strong>.&#x2F;nginx-s			s即signal信号，后面可以跟</strong></p>
<p>​								<strong>stop[快速关闭，类似于TERM&#x2F;INT信号的作用]</strong></p>
<p>​								<strong>quit[优雅的关闭，类似于QUIT信号的作用]</strong> </p>
<p>​								<strong>reopen[重新打开日志文件类似于USR1信号的作用]</strong> </p>
<p>​								<strong>reload[类似于HUP信号的作用]</strong></p>
<p><strong>.&#x2F;nginx-p			指定Nginx的prefix路径</strong></p>
<p><strong>.&#x2F;nginx-c			指定Nginx的配置文件路径</strong></p>
<p><strong>.&#x2F;nginx-g			补充Nginx配置文件，向Nginx服务指定启动时应用全局的配置</strong></p>
<h2 id="nginx-conf配置文件结构"><a href="#nginx-conf配置文件结构" class="headerlink" title="nginx.conf配置文件结构"></a><strong>nginx.conf配置文件结构</strong></h2><p><strong>nginx.conf配置文件中默认有三大块：全局块、events块、http块</strong></p>
<p><strong>http块中可以配置多个server块，每个server块又可以配置多个location块</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/6.png" alt="0"></p>
<h3 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a><strong>全局块</strong></h3><h4 id="一、user指令"><a href="#一、user指令" class="headerlink" title="一、user指令"></a><strong>一、user指令</strong></h4><p><strong>可以指定启动运行工作进程的用户及用户组，这样对于系统的权限访问控制的更加精细，也更加安全</strong></p>
<h4 id="二、work-process指令"><a href="#二、work-process指令" class="headerlink" title="二、work process指令"></a><strong>二、work process指令</strong></h4><p><strong>1、master_process:用来指定是否开启工作进程</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/7.png" alt="0"></p>
<p><strong>2、worker _ processes:用于配置Nginx生成工作进程的数量</strong> <strong>，这个是Nginx服务器实现并发处理服务的关键所在</strong></p>
<p><strong>process的值越大，可以支持的并发处理量也越多</strong> <strong>但事实上这个值的设定是需要受到来自服务器自身的限制建议将该值和服务器CPU的内核数保存一致</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/8.png" alt="0"></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/9.png" alt="0"></p>
<h4 id="三、其他指令"><a href="#三、其他指令" class="headerlink" title="三、其他指令"></a><strong>三、其他指令</strong></h4><p><strong>1、deamon：</strong> <strong>设定Nginx是否以守护进程的方式启动</strong></p>
<p><strong>守护进程是linux后台一种服务进程，特点是独立于控制终端，不会随着终端的关闭而停止</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/10.png" alt="0"></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/11.png" alt="0"></p>
<p><strong>2、pid：</strong> <strong>配置nginx当前master进程的进程号ID存储的文件路径</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/12.png" alt="0"></p>
<p><strong>3、error_log：</strong> <strong>配置nginx错误日志存放路径</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/13.png" alt="0"></p>
<p><strong>日志级别的值有：debug|info|notice|warn|error|crit|alert|emerg</strong></p>
<p>​								  调试 |信息|  通知  | 警告 | 错误 |临界|警报|紧急</p>
<p><strong>4、include：</strong> <strong>引入其他配置文件</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/14.png" alt="0"></p>
<h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a><strong>测试：</strong></h4><p><strong>1）创建一个main.conf，在里面写上配置文件</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/15.png" alt="0"></p>
<p><strong>2）引入配置文件</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/16.png" alt="0"></p>
<p><strong>3）加载成功</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/17.png" alt="0"></p>
<h3 id="events块"><a href="#events块" class="headerlink" title="events块"></a><strong>events块</strong></h3><h4 id="1、-accept-mutex：-设置nginx网络连接序列化"><a href="#1、-accept-mutex：-设置nginx网络连接序列化" class="headerlink" title="1、 accept_mutex： 设置nginx网络连接序列化"></a><strong>1、</strong> <strong>accept_mutex：</strong> <strong>设置nginx网络连接序列化</strong></h4><p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/18.png" alt="0"></p>
<p><strong>如果设置为on，将会对多个Nginx进程接收连接进行序列号，一个个来唤醒接收，</strong> <strong>防止了多个进程对连接的争抢</strong></p>
<h4 id="2、-multi-accept：-用来设置是否允许同时接收多个网络连接"><a href="#2、-multi-accept：-用来设置是否允许同时接收多个网络连接" class="headerlink" title="2、 multi_accept： 用来设置是否允许同时接收多个网络连接"></a><strong>2、</strong> <strong>multi_accept：</strong> <strong>用来设置是否允许同时接收多个网络连接</strong></h4><p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/19.png" alt="0"></p>
<p><strong>如果multi_accept被禁止了，nginx一个工作进程只能同时接受一个新的连接。否则，一个工作进程可以同时接受所有的新连接</strong></p>
<h4 id="3、-worker-connections：-用来配置单个worker进程最大的连接数"><a href="#3、-worker-connections：-用来配置单个worker进程最大的连接数" class="headerlink" title="3、 worker_connections： 用来配置单个worker进程最大的连接数"></a><strong>3、</strong> <strong>worker_connections：</strong> <strong>用来配置单个worker进程最大的连接数</strong></h4><p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/20.png" alt="0"></p>
<p><strong>连接数不仅仅包括和前端用户建立的连接数，而是包括所有可能的连接数</strong></p>
<h4 id="4、-use：用来设置Nginx服务器选择哪种事件驱动来处理网络消息"><a href="#4、-use：用来设置Nginx服务器选择哪种事件驱动来处理网络消息" class="headerlink" title="4、 use：用来设置Nginx服务器选择哪种事件驱动来处理网络消息"></a><strong>4、</strong> <strong>use：</strong>用来设置Nginx服务器选择哪种事件驱动来处理网络消息</h4><p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/21.png" alt="0"></p>
<h3 id="HTTP块"><a href="#HTTP块" class="headerlink" title="HTTP块"></a><strong>HTTP块</strong></h3><h4 id="自定义MIME-Type（网络资源的媒体类型）"><a href="#自定义MIME-Type（网络资源的媒体类型）" class="headerlink" title="自定义MIME-Type（网络资源的媒体类型）"></a><strong>自定义MIME-Type（网络资源的媒体类型）</strong></h4><p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/22.png" alt="0"></p>
<h4 id="default-type-用来配置Nginx响应前端请求默认的MIME类型"><a href="#default-type-用来配置Nginx响应前端请求默认的MIME类型" class="headerlink" title="default_type:用来配置Nginx响应前端请求默认的MIME类型"></a><strong>default_type:用来配置Nginx响应前端请求默认的MIME类型</strong></h4><p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/23.png" alt="0"></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/24.png" alt="0"></p>
<h4 id="自定义服务日志"><a href="#自定义服务日志" class="headerlink" title="自定义服务日志"></a><strong>自定义服务日志</strong></h4><p><strong>1、access_log:用来设置用户访问日志的相关属性</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/25.png" alt="0"></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/26.png" alt="0"></p>
<p><strong>2、log_format:用来指定日志的输出格式。</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/27.png" alt="0"></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/28.png" alt="0"></p>
<p><strong>3、sendfile:用来设置Nginx服务器是否使用sendfile()传输文件</strong></p>
<p><strong>该属性可以大大提高Nginx处理静态资源的性能</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/29.png" alt="0"></p>
<p><strong>4、keepalive_timeout:用来</strong> <strong>设置长连接的超时时间</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/30.png" alt="0"></p>
<p><strong>5、keepalive_requests:用来设置一个keep-alive</strong> <strong>连接使用的次数</strong></p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>2-1-算法时间复杂度分析</title>
    <url>/2022/07/12/2-1-%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><strong>最高次项的指数大的，随着n的增长，结果也会变得增长特别快</strong></p>
<p><strong>算法函数中n最高次幂越小，算法效率越高</strong></p>
<p>1.算法函数中的常数可以忽略； </p>
<p>2.算法函数中最高次幂的常数因子可以忽略； </p>
<p>3.算法函数中最高次幂越小，算法效率越高。</p>
<h2 id="大O记法"><a href="#大O记法" class="headerlink" title="大O记法"></a><strong>大O记法</strong></h2><p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随着n的变化情况并确定T(n)的 量级。算法的时间复杂度，就是算法的时间量度，记作:T(n)&#x3D;O(f(n))。</p>
<p><strong>它表示随着问题规模n的增大，算法执行时间 的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度，其中f(n)是问题规模n的某个函数。</strong></p>
<p><strong>执行次数&#x3D;执行时间</strong></p>
<h3 id="算法一："><a href="#算法一：" class="headerlink" title="算法一："></a>算法一：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//执行1次</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n=<span class="number">100</span>;<span class="comment">//执行1次</span></span><br><span class="line"></span><br><span class="line">    sum = (n+<span class="number">1</span>)*n/<span class="number">2</span>;<span class="comment">//执行1次</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;sum=&quot;</span>+sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法二："><a href="#算法二：" class="headerlink" title="算法二："></a>算法二：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//执行1次</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n=<span class="number">100</span>;<span class="comment">//执行1次</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">    	sum += i;<span class="comment">//执行了n次</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;sum=&quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法三："><a href="#算法三：" class="headerlink" title="算法三："></a>算法三：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;<span class="comment">//执行1次</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n=<span class="number">100</span>;<span class="comment">//执行1次</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=n ; i++) &#123;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=n ; j++) &#123;</span><br><span class="line"></span><br><span class="line">     	sum+=i;<span class="comment">//执行n^2次</span></span><br><span class="line"></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;sum=&quot;</span>+sum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**算法一：3次 **</p>
<p>**算法二：n+3次 **</p>
<p><strong>算法三：n^2+2次</strong></p>
<h3 id="推导大O阶-的表示法"><a href="#推导大O阶-的表示法" class="headerlink" title="推导大O阶 的表示法"></a><strong>推导大O阶</strong> 的表示法</h3><p>以下几个规则可以使用： </p>
<p>**1.用常数1取代运行时间中的所有加法常数； **</p>
<p><strong>2.在修改后的运行次数中，只保留高阶项；</strong></p>
<p><strong>3.如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数；</strong></p>
<p>所以，上述算法的大O记法分别为： </p>
<p>​	算法一：O(1) </p>
<p>​	算法二：O(n) </p>
<p>​	算法三：O(n^2)</p>
<h2 id="常见的大O阶"><a href="#常见的大O阶" class="headerlink" title="常见的大O阶"></a><strong>常见的大O阶</strong></h2><h3 id="1-线性阶"><a href="#1-线性阶" class="headerlink" title="1.线性阶"></a>1.线性阶</h3><p>一般含有非嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//执行1次</span></span><br><span class="line">    <span class="type">int</span> n=<span class="number">100</span>;<span class="comment">//执行1次</span></span><br><span class="line">    sum = (n+<span class="number">1</span>)*n/<span class="number">2</span>;<span class="comment">//执行1次</span></span><br><span class="line">    System.out.println(<span class="string">&quot;sum=&quot;</span>+sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上面这段代码，它的循环的时间复杂度为O(n)</strong>,因为循环体中的代码需要执行n次</p>
<h3 id="2-平方阶"><a href="#2-平方阶" class="headerlink" title="2.平方阶"></a>2.平方阶</h3><p>一般嵌套循环属于这种时间复杂度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>,n=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=n ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=n ; j++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码，n&#x3D;100，也就是说，外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环 中出来，就需要执行100<em>100次，也就是n的平方次，所以*<em>这段代码的时间复杂度是O(n^2).</em></em></p>
<h3 id="3-立方阶"><a href="#3-立方阶" class="headerlink" title="3.立方阶"></a>3.立方阶</h3><p>一般三层嵌套循环属于这种时间复杂度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt;= n; j++) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码，n&#x3D;100，也就是说，外层循环每执行一次，中间循环循环就执行100次，中间循环每执行一次，最 内层循环需要执行100次，那总共程序想要从这三个循环中出来，就需要执行100100100次，也就是n的立方，所 以<strong>这段代码的时间复杂度是O(n^3).</strong></p>
<h3 id="4-对数阶"><a href="#4-对数阶" class="headerlink" title="4.对数阶"></a>4.对数阶</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>,n=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">    i = i * <span class="number">2</span>; 	   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于每次i<em>2之后，就距离n更近一步，假设有x个2相乘后大于n，则会退出循环。由于是2^x&#x3D;n,得到x&#x3D;log(2)n,所 以*<em>这个循环的时间复杂度为O(logn);</em></em> 对于对数阶，<strong>由于随着输入规模n的增大，不管底数为多少，他们的增长趋势是一样的，所以我们会忽略底数。</strong></p>
<h3 id="5-常数阶"><a href="#5-常数阶" class="headerlink" title="5.常数阶"></a>5.常数阶</h3><p>一般不涉及循环操作的都是常数阶，因为它不会随着n的增长而增加操作次数。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> i=n+<span class="number">2</span>;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码，不管输入规模n是多少，都执行2次，根据大O推导法则，常数用1来替换，所以<strong>上述代码的时间复杂度为O(1)</strong></p>
<p>​    <img src="/2022/07/12/2-1-%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/1.png" alt="0"></p>
<p>他们的复杂程度从低到高依次为：</p>
<p>​    <img src="/2022/07/12/2-1-%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.png" alt="0"></p>
<p>所以，我们的算法，尽可能的<strong>追求的是O(1),O(logn),O(n),O(nlogn)这几种时间复杂度</strong>，而如果发现算法的时间复杂度为平方阶、 立方阶或者更复杂的，那我们可以分为这种算法是不可取的，需要优化。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>2-2-函数调用时间复杂度分析</title>
    <url>/2022/07/12/2-2-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="案例一："><a href="#案例一：" class="headerlink" title="案例一："></a><strong>案例一：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        show(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>show方法的时间复杂度为O(1),main方法的时间复杂度是O(n)</strong></p>
<h2 id="案例二："><a href="#案例二：" class="headerlink" title="案例二："></a><strong>案例二：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        show(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; i++) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main方法中，有一个for循环，循环体调用了show方法，由于show方法内部也有一个for循环</p>
<p><strong>所以show方法 的时间复杂度为O(n)，main方法的时间复杂度为O(n^2)</strong></p>
<h2 id="案例三："><a href="#案例三：" class="headerlink" title="案例三："></a><strong>案例三：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">100</span>;</span><br><span class="line">    show(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        show(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; i++) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在show方法中，有一个for循环，所以show方法的时间复杂度为O(n),在main方法中，show(n)这行代码内部执行 的次数为n，第一个for循环内调用了show方法，所以其执行次数为n^2,第二个嵌套for循环内只执行了一行代码，</p>
<p>所以其执行次数为n^2,那么<strong>main方法总执行次数为n+n^2+n^2&#x3D;2n^2+n</strong>。</p>
<p>根据大O推导规则，去掉n保留最高阶 项，并去掉最高阶项的常数因子2，所以<strong>最终main方法的时间复杂度为O(n^2)</strong></p>
<h2 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a><strong>最坏情况</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr=&#123;<span class="number">11</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num==arr[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最好情况：</strong> 查找的第一个数字就是期望的数字，那么算法的时间复杂度为O(1) </p>
<p><strong>最坏情况：</strong> 查找的最后一个数字，才是期望的数字，那么算法的时间复杂度为O(n) </p>
<p><strong>平均情况：</strong> 任何数字查找的平均成本是O(n&#x2F;2) <strong>最坏情况是一种保证，在应用中，这是一种最基本的保障，即使在最坏情况下，也能够正常提供服务，所以，除非 特别指定，</strong> <strong>我们提到的运行时间都指的是最坏情况下的运行时间。</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>2-3-算法的空间复杂度分析</title>
    <url>/2022/07/12/2-3-%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="一、java中常见内存占用"><a href="#一、java中常见内存占用" class="headerlink" title="一、java中常见内存占用"></a>一、java中常见内存占用</h2><p>1.基本数据类型内存占用情况：</p>
<p>​    <img src="/2022/07/12/2-3-%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/1.png" alt="0"></p>
<p>2.计算机访问内存的方式都是一次一个字节</p>
<p>3.一个引用（机器地址）需要8个字节表示：</p>
<p>例如： Date date &#x3D; new Date(),则date这个变量需要占用8个字节来表示</p>
<p>4.创建一个对象，比如new Date()，除了Date对象内部存储的数据(例如年月日等信息)占用的内存，该对象本身也 有内存开销，每个对象的自身开销是16个字节，用来保存对象的头信息。 </p>
<p>5.一般内存的使用，如果不够8个字节，都会被自动填充为8字节</p>
<p>6.java中数组被被限定为对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要<strong>24字节的头信息</strong></p>
<p>(16个自己的对象开销，4字节用于保存长度以及4个填充字节)再加上保存值所需的内存。</p>
<h2 id="二、算法的空间复杂度"><a href="#二、算法的空间复杂度" class="headerlink" title="二、算法的空间复杂度"></a><strong>二、算法的空间复杂度</strong></h2><p>算法的空间复杂度计算公式记作：S(n)&#x3D;O(f(n)),其中n为输入规模，f(n)为语句关于n所占存储空间的函数。</p>
<p>案例： 对指定的数组元素进行反转，并返回反转的内容。</p>
<p>​    <img src="/2022/07/12/2-3-%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.png" alt="0"></p>
<p>​    <img src="/2022/07/12/2-3-%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/3.png" alt="0"></p>
<p>根据大O推导法则，算法一的空间复杂度为O(1)</p>
<p>算法二的空间复杂度为O(n)</p>
<p>所以从空间占用的角度讲，算法一要优于算法二。</p>
<p>由于java中有内存垃圾回收机制，并且jvm对程序的内存占用也有优化（例如即时编译），我们无法精确的评估一 个java程序的内存占用情况，但是了解了java的基本内存占用，使我们可以对java程序的内存占用情况进行估算。 由于现在的计算机设备内存一般都比较大，基本上个人计算机都是4G起步，大的可以达到32G</p>
<p>所以<strong>内存占用一般 情况下并不是我们算法的瓶颈，普通情况下直接说复杂度，默认为算法的时间复杂度。</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>3-1-冒泡排序</title>
    <url>/2022/07/12/3-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>排序原理：</strong> </p>
<p><strong>1. 比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。</strong></p>
<p><strong>2. 对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值。</strong></p>
<p><img src="/2022/07/12/3-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/1.png"></p>
<p>**初始状态到第一次冒泡 : **</p>
<ol>
<li>比较 4,5，5比4大，不变。</li>
<li>比较5,6，6比5大，不变</li>
<li>比较6,3，3比6小，交换二者位置    4,5,3,6,2,1</li>
<li>比较6,2，2比6小，交换二者位置    4,5,3,2,6,1</li>
<li>比较6,1，1比6小，交换二者位置    4,5,3,2,1,6</li>
</ol>
<p>假设数组长度为n，冒泡排序必须实现n-1次冒泡（令k &#x3D; n）</p>
<p>第一次冒泡要有k-1次比较</p>
<p>第二次冒泡要有k-2次比较</p>
<p>第n-1次冒泡要有k-n-1次比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length-<span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (greater(a[j],a[j+<span class="number">1</span>]))&#123;</span><br><span class="line">                exch(a,j,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用两个for循环进行遍历，第一个for循环表示冒泡的次数为：数组长度-1</strong></p>
<p><strong>第二个for循环表示相邻数组元素依次比较，j &lt; i 表示排序完的元素放在数组的后面，不需要再次进行排序</strong></p>
<p><img src="/2022/07/12/3-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/2.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> SORT;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/1/14</span></span><br><span class="line"><span class="comment"> * 10:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//    1.public static void sort(Comparable[] a)：对数组内的元素进行排序</span></span><br><span class="line"><span class="comment">//    2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w</span></span><br><span class="line"><span class="comment">//    3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bubble</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组内的元素进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length-<span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (greater(a[j],a[j+<span class="number">1</span>]))&#123;</span><br><span class="line">                    exch(a,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断v是否大于w</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v,Comparable w)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> v.compareTo(w);</span><br><span class="line">        <span class="keyword">if</span> (result&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        return result&gt;0;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换a数组中，索引i和索引j处的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>冒泡排序的时间复杂度分析 冒泡排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码</strong></p>
<p>**所以， 分析冒泡排序的时间复杂度，主要分析一下内层循环体的执行次数即可。 **</p>
<p>在最坏情况下，也就是假如要排序的元素为{6,5,4,3,2,1}逆序，</p>
<p>那么： 元素比较的次数为： (N-1)+(N-2)+(N-3)+…+2+1&#x3D;((N-1)+1)*(N-1)&#x2F;2&#x3D;N^2&#x2F;2-N&#x2F;2; </p>
<p>元素交换的次数为： (N-1)+(N-2)+(N-3)+…+2+1&#x3D;((N-1)+1)*(N-1)&#x2F;2&#x3D;N^2&#x2F;2-N&#x2F;2;</p>
<p>总执行次数为： (N^2&#x2F;2-N&#x2F;2)+(N^2&#x2F;2-N&#x2F;2)&#x3D;N^2-N;</p>
<p>按照大O推导法则，保留函数中的最高阶项那么<strong>最终冒泡排序的时间复杂度为O(N^2)</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>3-2-选择排序</title>
    <url>/2022/07/12/3-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>排序原理：</strong></p>
<p><strong>1.每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较</strong></p>
<p>​	**如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引 **</p>
<p><strong>2.交换第一个索引处和最小值所在的索引处的值</strong></p>
<p>​    <img src="/2022/07/12/3-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/1.png" alt="0"></p>
<p>原始数据到第一趟排序：假定4是最小值，让4分别与数据的其他7位元素进行比较，如果有比4小的数，交换二者位置让那个数成为最小值放在第一位，然后继续比较，直到到了元素的最后一位</p>
<p>第六趟到第7趟排序：假定8是最小值，与后面的10，9进行比较，如果有比4小的数，交换二者位置让那个数成为最小值放在第一位，然后继续比较，直到到了元素的最后一位</p>
<p>​    <img src="/2022/07/12/3-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/2.png" alt="0"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//定义一个变量，记录最小元素所在的索引，默认为参与选择排序的第一个元素所在的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">            <span class="comment">//需要比较最小索引min处的值和j索引处的值</span></span><br><span class="line">            <span class="keyword">if</span> (greater(a[min],a[j]))&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换最小元素所在的索引min处的值和j索引处的值</span></span><br><span class="line">        exch(a, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v,Comparable w)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    Comparable temp;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设数组长度为n</p>
<p>最开始，将数组的第一个元素作为最小值所在的索引，定义为min</p>
<p>用两个for循环进行嵌套，第一个for循环表示，需要进行n-1趟排序</p>
<p>第二个for循环为了比较最小索引的值min 与 后面元素的索引值。</p>
<p>如果存在比最小索引min的值小的元素，则交换min与该元素的索引，使其成为最小值的索引</p>
<p><strong>注意：</strong></p>
<p><strong>第二个for循环中定义 j &#x3D; i + 1 是为了在排好顺序的元素的后一位才开始进行比较</strong></p>
<p><strong>而且 j 不能越界访问，所以 j 要小于数组的长度</strong></p>
<p><strong>选择排序的时间复杂度分析：</strong></p>
<p>选择排序使用了双层for循环，其中外层循环完成了数据交换，内层循环完成了数据比较，</p>
<p>分别统计数据 交换次数和数据比较次数： </p>
<p>数据比较次数： (N-1)+(N-2)+(N-3)+…+2+1&#x3D;((N-1)+1)*(N-1)&#x2F;2&#x3D;N^2&#x2F;2-N&#x2F;2;</p>
<p>数据交换次数： N-1 时间复杂度：N^2&#x2F;2-N&#x2F;2+（N-1）&#x3D;N^2&#x2F;2+N&#x2F;2-1; 根据大O推导法则，保留最高阶项，去除常数因子，<strong>时间复杂度为O(N^2);</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构基础知识</tag>
      </tags>
  </entry>
</search>
