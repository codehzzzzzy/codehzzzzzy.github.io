<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01-什么是JVM?</title>
    <url>/2022/07/10/01-%E4%BB%80%E4%B9%88%E6%98%AFJVM/</url>
    <content><![CDATA[<h2 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a><strong>什么是JVM？</strong></h2><p><strong>①. JVM 是 java虚拟机，是用来执行java字节码(二进制的形式)的虚拟计算机</strong></p>
<p><strong>②. jvm是运行在操作系统之上的，与硬件没有任何关系</strong></p>
<p><img src="/2022/07/10/01-%E4%BB%80%E4%B9%88%E6%98%AFJVM/1.png" alt="1"></p>
<h2 id="Java的跨平台及原理"><a href="#Java的跨平台及原理" class="headerlink" title="Java的跨平台及原理"></a><strong>Java的跨平台及原理</strong></h2><p><strong>①. 跨平台：由Java编写的程序可以在不同的操作系统上运行：一次编写，多处运行</strong></p>
<p><strong>②. 原理：编译之后的字节码文件和平台无关，需要在不同的操作系统上安装一个对应版本的虚拟机(JVM)</strong></p>
<h2 id="JVM的整体的理解"><a href="#JVM的整体的理解" class="headerlink" title="JVM的整体的理解"></a><strong>JVM的整体的理解</strong></h2><p><strong>①. 类加载子系统</strong></p>
<p><strong>②. 运行时数据区(我们核心关注这里 的栈、堆、方法区)</strong></p>
<p><strong>③. 执行引擎(一般都是JIT编译器和解释器共存)</strong></p>
<p><img src="/2022/07/10/01-%E4%BB%80%E4%B9%88%E6%98%AFJVM/2.png" alt="2"></p>
<h2 id="java代码执行流程"><a href="#java代码执行流程" class="headerlink" title="java代码执行流程"></a><strong>java代码执行流程</strong></h2><p>​	<strong>java源码—java编译器—生成字节码—进入java虚拟机（类加载器—字节码校验器—翻译字节码—JIT编译器）</strong></p>
<h2 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a><strong>JVM的架构模型</strong></h2><p><strong>Java编译器输入的指令流基木上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。</strong></p>
<p><strong>基于栈式架构的特点</strong></p>
<ul>
<li>跨平台性</li>
<li>指令集小</li>
<li>指令多</li>
<li>执行性能比寄存器差</li>
</ul>
<p><strong>基于寄存器架构的特点</strong></p>
<ul>
<li>指令集架构则完全依赖硬件，可移植性差</li>
<li>性能优秀和执行更高效</li>
</ul>
<p><strong>举例</strong></p>
<p><strong>同样执行2+3这种逻辑操作，其指令分别如下：</strong></p>
<p><strong>1、基于栈的计算流程（以Java虚拟机为例)</strong></p>
<p><img src="/2022/07/10/01-%E4%BB%80%E4%B9%88%E6%98%AFJVM/3.png" alt="3"></p>
<p><strong>2、基于寄存器的计算流程</strong></p>
<p><img src="/2022/07/10/01-%E4%BB%80%E4%B9%88%E6%98%AFJVM/4.png" alt="4"></p>
<p><strong>总结</strong></p>
<p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a><strong>JVM的生命周期</strong></h2><p><strong>虚拟机的启动</strong></p>
<p><strong>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</strong></p>
<p><strong>虚拟机的执行</strong></p>
<ul>
<li><strong>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</strong></li>
<li><strong>程序开始执行时他才运行，程序结束时他就停止。</strong></li>
<li><strong>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</strong></li>
</ul>
<p><strong>虚拟机的退出</strong></p>
<ul>
<li><strong>程序正常执行结束</strong></li>
<li><strong>程序在执行过程中遇到了异常或错误而异常终止</strong></li>
<li><strong>由于操作系统用现错误而导致Java虚拟机进程终止</strong></li>
<li><strong>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</strong></li>
<li><strong>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</strong></li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>01-设计模式的原则</title>
    <url>/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a><strong>设计模式的目的</strong></h1><p><strong>1、代码重用性</strong></p>
<p><strong>2、可读性</strong></p>
<p><strong>3、可扩展性（增加功能时，对原来的功能没有影响）</strong></p>
<p><strong>4、可靠性（增加功能时，对原来的功能没有影响）</strong></p>
<p><strong>5、高内聚，低耦合</strong></p>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a><strong>单一职责原则</strong></h2><p><strong>一个类应该只负责一项职责</strong></p>
<p>如：类 A 负责两个不同职责：职责 1，职责 2。</p>
<p>当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2</p>
<p><strong>注意：</strong></p>
<ul>
<li>降低类的复杂度，一个类负责一个职责</li>
<li>提高类的可读性</li>
<li>降低变更的风险</li>
</ul>
<p>只有类中方法数量足够少时，可以在方法级别保持单一职责原则</p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/1.png" alt="0"></p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/2.png" alt="0"></p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/3.png" alt="0"></p>
<h2 id="接口隔离的原则"><a href="#接口隔离的原则" class="headerlink" title="接口隔离的原则"></a><strong>接口隔离的原则</strong></h2><p><strong>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</strong></p>
<p>类A和类C只需要依赖接口1的一部分接口，而不需要实现全部，所以可以将接口 Interface1 拆分为独立的几个接口(这里我们拆分成 3 个接口)，类 A 和类 C 分别与他们需要的接口建立依赖关系</p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/4.png" alt="0"></p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/5.png" alt="0"></p>
<h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a><strong>依赖倒转原则</strong></h2><p>1）高层模块不应该依赖底层模块，二者都应该依赖其抽象</p>
<p>2）抽象不应该依赖细节，细节应该依赖抽象</p>
<p><strong>3）核心思想：面向接口编程</strong></p>
<p>三种方式：接口传递，构造方法传递，setter方法传递</p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/6.png" alt="0"></p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/7.png" alt="0"></p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a><strong>里氏替换原则</strong></h2><p><strong>继承给程序设计带来便利也带来了弊端：</strong></p>
<ul>
<li>使用继承会给程序带来侵入性</li>
<li>可移植性降低</li>
<li>增加对象间的耦合</li>
<li>当这个类要修改时，必须考虑到所有的子类</li>
</ul>
<p><strong>正确使用继承：</strong></p>
<ul>
<li>使用继承时，在子类中尽量不要重写父类的方法</li>
<li>在适当的情况，可以使用聚合，组合，依赖来解决</li>
</ul>
<p><strong>解决方法：让原来的子类和父类都继承一个更通俗的基类，将原有的继承关系去掉，采用聚合，组合，依赖等关系来代替</strong></p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/8.png" alt="0"></p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/9.png" alt="0"></p>
<h2 id="开闭原则-（最基础，最重要）"><a href="#开闭原则-（最基础，最重要）" class="headerlink" title="开闭原则 （最基础，最重要）"></a><strong>开闭原则</strong> <strong>（最基础，最重要）</strong></h2><p><strong>比如一个类，模块和函数一个对扩展开发（对提供方），对修改关闭（对使用方）。</strong></p>
<p><strong>当软件需要变化，尽量通过扩展代码，而不是通过修改已有代码的方法实现</strong></p>
<p><strong>案例：</strong></p>
<p>如果需要增加新的功能，绘制别的图形，需要在使用方处修改代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ocp</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">//使用看看存在的问题</span></span><br><span class="line">      <span class="type">GraphicEditor</span> <span class="variable">graphicEditor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GraphicEditor</span>();</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Rectangle</span>());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Circle</span>());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Triangle</span>());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span> &#123;</span><br><span class="line">   <span class="comment">//接收Shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape s)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (s.m_type == <span class="number">1</span>)</span><br><span class="line">         drawRectangle(s);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>)</span><br><span class="line">         drawCircle(s);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">3</span>)</span><br><span class="line">         drawTriangle(s);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//绘制矩形</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(Shape r)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//绘制圆形</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(Shape r)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//绘制三角形</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawTriangle</span><span class="params">(Shape r)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="type">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   Rectangle() &#123;</span><br><span class="line">      <span class="built_in">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   Circle() &#123;</span><br><span class="line">      <span class="built_in">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   Triangle() &#123;</span><br><span class="line">      <span class="built_in">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>改进：</strong></p>
<p>创建一个抽象类Shape，提供一个抽象方法drow，然后让子类去继承该抽象方法，重写该抽象方法，当需要增加新的功能的时候，只需要创建一个新的类去继承抽象方法并重写即可，无需对使用方代码进行改动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ocp</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">//使用看看存在的问题</span></span><br><span class="line">      <span class="type">GraphicEditor</span> <span class="variable">graphicEditor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GraphicEditor</span>();</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Rectangle</span>());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Circle</span>());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">Triangle</span>());</span><br><span class="line">      graphicEditor.drawShape(<span class="keyword">new</span> <span class="title class_">OtherGraphic</span>());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span> &#123;</span><br><span class="line">   <span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape s)</span> &#123;</span><br><span class="line">      s.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="type">int</span> m_type;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   Rectangle() &#123;</span><br><span class="line">      <span class="built_in">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   Circle() &#123;</span><br><span class="line">      <span class="built_in">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   Triangle() &#123;</span><br><span class="line">      <span class="built_in">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增一个图形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OtherGraphic</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   OtherGraphic() &#123;</span><br><span class="line">      <span class="built_in">super</span>.m_type = <span class="number">4</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 绘制其它图形 &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="迪米特法则-（最少知道原则）"><a href="#迪米特法则-（最少知道原则）" class="headerlink" title="迪米特法则 （最少知道原则）"></a><strong>迪米特法则</strong> <strong>（最少知道原则）</strong></h2><p> <strong>一个对象应该对其他对象保持最少的了解</strong></p>
<p>每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，则这两个对象之间是朋友关系</p>
<p>其中，出现成员变量，方法参数，方法返回值中的类为直接的朋友</p>
<p>迪米特法则只要要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系</p>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a><strong>合成复用原则</strong></h2><p><strong>尽量使用合成或者聚合的方式，而不是使用继承</strong></p>
<p>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起</p>
<p><strong>针对接口编程，而不是针对具体实现编程</strong></p>
<p><strong>松耦合设计</strong></p>
<p>​    <img src="/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/10.png" alt="0"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>03-数据区概述与线程</title>
    <url>/2022/07/12/03-%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a><strong>数据区</strong></h1><p><strong>JVM在执行java程序的过程中会把它管理的内存划分为若干个不同的数据区域（包括5个运行时数据区）</strong></p>
<p><strong>1、方法区	2、虚拟机栈	3、本地方法栈	4、堆	5、程序计数器</strong></p>
<p>​    <img src="/2022/07/12/03-%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%BA%BF%E7%A8%8B/1.jpg" alt="截图1"></p>
<p><strong>运行时数据区的完整图</strong></p>
<p>​    <img src="/2022/07/12/03-%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%BA%BF%E7%A8%8B/2.jpg" alt="截图2"></p>
<p><strong>Java的内存区域</strong></p>
<p>​    <img src="/2022/07/12/03-%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%BA%BF%E7%A8%8B/3.jpg" alt="截图3"></p>
<p><strong>灰色的为单独线程私有的，红色的为多个线程共享的。</strong></p>
<p><strong>即：</strong></p>
<p><strong>1、每个线程：独立包括程序计数器、虚拟机栈、本地方法栈。</strong></p>
<p><strong>2、线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</strong></p>
<p>​    <img src="/2022/07/12/03-%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%BA%BF%E7%A8%8B/4.jpg" alt="截图4"></p>
<h1 id="线程的简单介绍"><a href="#线程的简单介绍" class="headerlink" title="线程的简单介绍"></a><strong>线程的简单介绍</strong></h1><p><strong>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</strong></p>
<p>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</p>
<p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。<strong>一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</strong></p>
<p><strong>JVM线程（*）</strong></p>
<p>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</p>
<ul>
<li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li>
<li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li>
<li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li>
<li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>02-类加载器和类加载过程</title>
    <url>/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a><strong>类加载过程</strong></h1><p><img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/1.png" alt="截图"></p>
<p><img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/20210311102359950.png" alt="20210311102359950"></p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a><strong>加载</strong></h2><p>1、通过一个类的全限定名获取定义此类的二进制字节流</p>
<p>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
<p>3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
<h2 id="链接：一共分为三个部分，验证、准备和解析"><a href="#链接：一共分为三个部分，验证、准备和解析" class="headerlink" title="链接：一共分为三个部分，验证、准备和解析"></a><strong>链接：一共分为三个部分，验证、准备和解析</strong></h2><h3 id="一、验证"><a href="#一、验证" class="headerlink" title="一、验证"></a><strong>一、验证</strong></h3><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身。</p>
<p>验证阶段是十分重要的，直接决定了Java虚拟机是否能承受恶意代码的攻击，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重。</p>
<p>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证</p>
<img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/%E6%88%AA%E5%9B%BE%20(1).png" alt="截图 (1)" style="zoom:67%;">

<h3 id="二、准备"><a href="#二、准备" class="headerlink" title="二、准备"></a><strong>二、准备</strong></h3><p>1、为类变量分配内存并且设置该变量的默认初始值，即零值。</p>
<p>2、这里不包括含用final修饰的static,因为final在编译的时候就会分配数值了，准备阶段会显式初始化。</p>
<p>3、这里不会为实例变量分配初始化，类变量会分配在方法区，而实例变量是会随着对象一起分配到java堆中。</p>
<h3 id="三、解析"><a href="#三、解析" class="headerlink" title="三、解析"></a><strong>三、解析</strong></h3><p>1、<strong>将常量池内的符号引用转换为直接引用过程</strong></p>
<p>2、实际上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</p>
<p>3、符号引用就是一组符号来描述所引用的目标。<strong>符号引用的字面形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</strong></p>
<p>4、主要解析动作针对类或接口、字段、类方法、接口方法、方法类型等。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h2><h3 id="1）初始化阶段就是执行类构造器方法-的过程"><a href="#1）初始化阶段就是执行类构造器方法-的过程" class="headerlink" title="1）初始化阶段就是执行类构造器方法()的过程"></a><strong>1）初始化阶段就是执行类构造器方法()的过程</strong></h3><p><strong>该方法不需要定义，而是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来的</strong></p>
<p><strong>构造器方法中的指令按照语句在源文件中出现的顺序来决定</strong></p>
<p><strong>变量已经赋过一次系统要求的初始零值，而在初始化阶段</strong></p>
<p><strong>则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。</strong></p>
<h3 id="2）若该类有父类，JVM会保证子子类的-执行前，父类的-已经执行完毕"><a href="#2）若该类有父类，JVM会保证子子类的-执行前，父类的-已经执行完毕" class="headerlink" title="2）若该类有父类，JVM会保证子子类的()执行前，父类的()已经执行完毕"></a>2）若该类有父类，JVM会保证子子类的()执行前，父类的()已经执行完毕</h3><p>虚拟机必须保证一个类的()方法在多线程下被同步加锁</p>
<img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/%E6%88%AA%E5%9B%BE%20(2).png" alt="截图 (2)" style="zoom:80%;">

<h3 id="3）在类加载的Linking链接的准备阶段，所有类变量以符号引用的方法存储在方法区"><a href="#3）在类加载的Linking链接的准备阶段，所有类变量以符号引用的方法存储在方法区" class="headerlink" title="3）在类加载的Linking链接的准备阶段，所有类变量以符号引用的方法存储在方法区"></a>3）在类加载的Linking链接的准备阶段，所有类变量以符号引用的方法存储在方法区</h3><p>而当静态代码尝试获取类变量时候需要通过直接引用，这就导致了编译的出错</p>
<h3 id="4）Java编译器并不会为所有的类都产生-初始化方法"><a href="#4）Java编译器并不会为所有的类都产生-初始化方法" class="headerlink" title="4）Java编译器并不会为所有的类都产生()初始化方法"></a>4）Java编译器并不会为所有的类都产生()初始化方法</h3><p>一个类中并没有声明任何的类变量,也没有静态代码块时</p>
<p>一个类中声明类变量,但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</p>
<p>一个类中包含static final修饰的基本数据类型的字段,这些类字段初始化语句采用编译时常量表达式 </p>
<p>(如果这个static final 不是通过方法或者构造器,则在链接阶段)</p>
<p>  <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/3.png" alt="截图 (3)"></p>
<h3 id="5）赋值的阶段性问题"><a href="#5）赋值的阶段性问题" class="headerlink" title="5）赋值的阶段性问题"></a><strong>5）赋值的阶段性问题</strong></h3><p> <strong>在链接阶段的准备环节赋值的情况:</strong></p>
<p><strong>1、对于基本数据类型的字段来说,如果使用static final修饰,则显式赋值(直接赋值常量,而非调用方法)通常是在链接阶段的准备环节进行</strong></p>
<p><strong>2、对于String来说,如果使用字面量的方式赋值,使用static final修饰的话,则显式赋值通常是在链接阶段的准备环节进行</strong></p>
<p><strong>3、使用static + final修饰,且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值,是在链接阶段的准备环节进行。</strong></p>
<p><strong>在初始化阶段()中赋值的情况:</strong></p>
<p><strong>排除上述的在准备环节赋值的情况之外的情况</strong></p>
<p><img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/4.png" alt="截图 (4)"></p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a><strong>类加载器</strong></h1> <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/%E6%88%AA%E5%9B%BE%20(5).png" alt="截图 (5)" style="zoom:80%;">

<h2 id="引导-启动-类加载器"><a href="#引导-启动-类加载器" class="headerlink" title="引导(启动)类加载器"></a><strong>引导(启动)类加载器</strong></h2><p>这个类加载使用C&#x2F;C++语言实现的,嵌套在JVM内部</p>
<p><strong>1、它用来加载Java的核心类库(JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resource.jar或sum.boot.class.path路径下的内容)</strong></p>
<p><strong>用于提供JVM自身需要的类(String类就是使用的这个类加载器)</strong></p>
<p>2、由于安全考虑,Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p>
<p>3、并不继承自java.lang.ClassLoader,没有父加载器</p>
<p><strong>4、加载扩展类和应用程序类加载器,并指定为他们的父类加载器</strong></p>
<p><strong>自定义加载器****（将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器）</strong></p>
<p>1、Java语言编写</p>
<p><strong>2、派生于ClassLoader类,父类加载器为启动类加载器</strong></p>
<p>3、从java.ext.dirs系统属性所指定的目录中加载类库,或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录(扩展目录)下加载类库。</p>
<p>如果用户创建的JAR放在此目录下,也会自动由扩展类加载器加载</p>
<h2 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a><strong>扩展类加载器</strong></h2><p>1、Java语言编写</p>
<p><strong>2、派生于ClassLoader类,父类加载器为启动类加载器</strong></p>
<p>3、从java.ext.dirs系统属性所指定的目录中加载类库,或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录(扩展目录)下加载类库</p>
<p>如果用户创建的JAR放在此目录下,也会自动由扩展类加载器加载</p>
<h2 id="应用程序-系统-类加载器-AppClassLoader"><a href="#应用程序-系统-类加载器-AppClassLoader" class="headerlink" title="应用程序(系统)类加载器 AppClassLoader"></a><strong>应用程序(系统)类加载器 AppClassLoader</strong></h2><p>1、java语言编写</p>
<p><strong>2、派生于ClassLoader类,父类加载器为扩展类加载器</strong></p>
<p><strong>3、它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</strong></p>
<p><strong>4、该类加载是程序中默认的类加载器</strong></p>
<p>5、通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</p>
<h2 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a><strong>用户自定义类加载器</strong></h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a><strong>目的</strong></h3><p>隔离记载类</p>
<p>修改类的加载方式</p>
<p>扩展加载源</p>
<p>防止源码泄露</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h3><p><strong>1）重写 loadClass() 方法（不推荐,这个方法会保证类的双亲委派机制）</strong></p>
<p><strong>2）重写 findClass() 方法 –&gt;推荐</strong></p>
<p><strong>这两种方法本质上差不多,毕竟loadClass()也会调用findClass(),但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法,根据参数指定类的名字,返回对应的Class对象的引用</strong></p>
<p><strong>获取ClassLoader的方法</strong></p>
<p><img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/6.png" alt="截图 (6)"></p>
<p>​    <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/7.png" alt="截图 (7)"></p>
<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a><strong>双亲委派机制</strong></h1><p><em>java虚拟机对class文件采用按需加载的方式进行加载，当需要使用该类时才会将它的class文件加载到内存中生成class对象</em></p>
<p><em>在加载这个类的时候，采用的就是双亲委派模式。</em></p>
<p><strong>1、如果</strong> <strong>一个类加载收到了类加载请求,它并不会自己先去加载</strong> <strong>,而是把这个请求</strong> <strong>委托给父类加载器去执行</strong></p>
<p><strong>2、如果</strong> <strong>父类加载器还存在其父类加载器</strong> <strong>,则进一步</strong> <strong>向上委托</strong> <strong>,依次递归,请求最终将</strong> <strong>到达顶层的启动类加载器</strong></p>
<p><strong>3、如果父类的加载器可以完成类的加载任务,就成功返回,倘若</strong> <strong>父类加载器无法完成此加载任务,子加载器才会尝试自己去加载,</strong> <strong>这就是双亲委派模式</strong></p>
<p>​    <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/20210509161013261.png" alt="20210509161013261"></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><strong>源码分析</strong></h2><p><strong>（双亲委派机制在 java.lang.ClassLoader.loadClass(String,boolean) 中体现）</strong></p>
<p><em>1、先在<strong>当前加载器的缓存</strong>中*<em>查找有无目标类</em></em>,如果有,直接返回。*</p>
<p><em>2、判断当前加载器的父加载器是否为空</em> <em>,如果不为空,则调用 parent.loadClass(name, false) 接口进行加载</em></p>
<p><em>3、反之,如果当前加载器的父类加载器为空,则调用 findBootstrapClassOrNull(name) 接口,让引导类加载器进行加载</em></p>
<p><em>4、如果通过以上3条路径都没能成功加载,则调用 findClass(name) 接口进行加载。该接口最终会调用 java.lang.ClassLoader 接口的 defineClass 系列的native接口加载目标Java类。</em></p>
<p><strong>双亲委派的模型就隐藏在这第2和第3步中</strong></p>
<h2 id="双亲委派机制的优势"><a href="#双亲委派机制的优势" class="headerlink" title="双亲委派机制的优势"></a><strong>双亲委派机制的优势</strong></h2><p><strong>1、避免类的重复加载，确保一个类的全局唯一性（当父ClassLoader已经加载了该类的时候,就没有必要子ClassLoader再加载一次）</strong></p>
<p><strong>2、保护程序的安全，防止API随意被篡改</strong></p>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a><strong>沙箱安全机制</strong></h2><p><strong>Java代码限定在</strong><a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020"><strong>虚拟机</strong></a><strong>JVM特定的运行范围中，并且严格限制代码对本地资源的访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏</strong></p>
<p>​    <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/%E6%88%AA%E5%9B%BE%20(8).png" alt="截图 (8)" style="zoom:80%;"></p>
<h1 id="类的使用方式"><a href="#类的使用方式" class="headerlink" title="类的使用方式"></a><strong>类的使用方式</strong></h1><p><strong>java虚拟机在每个类或接口被java程序“首次主动使用”时才初始化它们。被动使用不会初始化类，但又可能会加载类</strong></p>
<p><strong>在加载的过程中，遇到.class文件的缺失或者存在错误，类加载器只会在首次主动使用它们时才会报错，如果一直没使用，则不会报错</strong></p>
<h2 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a><strong>主动使用</strong></h2><p><strong>1、创建类的实例</strong>	</p>
<p><strong>2、访问某个类或接口的静态变量，或者对该静态变量赋值</strong>	</p>
<p><strong>3、调用类的静态方法</strong></p>
<p><strong>4、反射</strong></p>
<p><strong>5、初始化一个类的子类</strong></p>
<p><strong>6、java虚拟机启动时被标明为启动类的类</strong></p>
<p><strong>注意：</strong> <strong>初始化一个类的子类这条规则，不适用于接口，即：初始化一个类的子类，会先初始化它的父类，但是不一定会初始化它的接口。只有当首次使用该接口的静态变量时，才会初始化。</strong></p>
<h2 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a><strong>被动使用</strong></h2><p><strong>除了主动使用的其他使用方式，例如：</strong></p>
<p><strong>1）通过子类引用父类的静态字段，为子类的被动使用，不会导致子类初始化</strong></p>
<p><strong>2）通过数组定义类引用类，为类的被动使用，不会触发此类的初始化</strong></p>
<p>​    <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/9.png" alt="截图 (9)"></p>
<p><strong>3）常量在编译阶段会存入调用方法所在的类的常量池中（这个例子存在F类的常量池中）</strong></p>
<p><strong>本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</strong></p>
<p>  <img src="/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/10.png" alt="截图 (10)"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>04-程序计数器</title>
    <url>/2022/07/12/04-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    <content><![CDATA[<h1 id="程序计数器（PC寄存器）"><a href="#程序计数器（PC寄存器）" class="headerlink" title="程序计数器（PC寄存器）"></a><strong>程序计数器</strong>（PC寄存器）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>既不存在GC也不存在OOM</strong></p>
<p><strong>PC寄存器用来存储指向下一条指令的地址，也是即将要执行的指令代码</strong>。由执行引擎读取下一条指令</p>
<p>它是一块<strong>很小的内存空间</strong>，几乎可以忽略不记。也是<strong>运行速度最快的存储区域</strong>。</p>
<p>在JVM规范中，每个线程都有它自己的程序计数器，是<strong>线程私有的</strong>，生命周期与线程的生命周期保持一致。</p>
<p>  <img src="/2022/07/12/04-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/1.jpg" alt="截图1"></p>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a><strong>代码演示</strong></h2><p>   <img src="/2022/07/12/04-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/2.jpg" alt="截图2"></p>
<p>   <img src="/2022/07/12/04-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/3.jpg" alt="截图3"></p>
<p><strong>通过PC寄存器，我们就可以知道当前程序执行到哪一步了</strong></p>
<p>​    <img src="/2022/07/12/04-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/4.jpg" alt="截图4"></p>
<h2 id="使用PC寄存器存储字节码地址有什么用？（为什么要使用PC寄存器记录当前线程的执行地址呢？）"><a href="#使用PC寄存器存储字节码地址有什么用？（为什么要使用PC寄存器记录当前线程的执行地址呢？）" class="headerlink" title="使用PC寄存器存储字节码地址有什么用？（为什么要使用PC寄存器记录当前线程的执行地址呢？）"></a><strong>使用PC寄存器存储字节码地址有什么用？（为什么要使用PC寄存器记录当前线程的执行地址呢？</strong>）</h2><p><strong>1、CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</strong></p>
<p><strong>2、JVM的字节码解释器需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</strong></p>
<h2 id="PC寄存器为什么被设定为线程私有的？"><a href="#PC寄存器为什么被设定为线程私有的？" class="headerlink" title="PC寄存器为什么被设定为线程私有的？"></a><strong>PC寄存器为什么被设定为线程私有的？</strong></h2><p><strong>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</strong></p>
<p><strong>这样必然导致经常中断或恢复，为了保证分毫无差。每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</strong></p>
<p> <img src="/2022/07/12/04-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/5.jpg" alt="截图5"></p>
<p><strong>比如一个cpu负责3个线程，cpu会在3个线程间轮流执行，为了能够保证CPU在切换的过程中，每个线程都可以按照切换之前的指令继续执行，而不影响其他线程，所以PC寄存器设定为线程私有的</strong></p>
<h2 id="CPU时间片（-）"><a href="#CPU时间片（-）" class="headerlink" title="CPU时间片（*）"></a><strong>CPU时间片（*）</strong></h2><p>   <img src="/2022/07/12/04-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/6.jpg" alt="截图6"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>06-本地方法栈和本地方法</title>
    <url>/2022/07/12/06-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a><strong>本地方法</strong></h1><p><strong>实际上是一个java调用非java代码的一个接口</strong> <strong>（</strong> <strong>使用native关键字进行修饰</strong> ）</p>
<p>本地方法的作用：</p>
<p>1、Java应用与Java外面的环境交互</p>
<p>2、与操作系统进行交互</p>
<p>3、Sun公司解释器由C实现</p>
<h1 id="本地方法栈-（线程私有）"><a href="#本地方法栈-（线程私有）" class="headerlink" title="本地方法栈 （线程私有）"></a><strong>本地方法栈</strong> <strong>（线程私有）</strong></h1><p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</p>
<p>本地方法栈中登记本地方法，然后执行引擎执行时，加载本地方法库</p>
<p>当某一个线程调用本地方法时</p>
<p>本地方法可通过本地方法接口来访问虚拟机内部的运行时数据区</p>
<p>可以使用本地处理器中的寄存器</p>
<p>……（和虚拟机拥有一样的权限）</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>05-虚拟机栈及相关问题</title>
    <url>/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="虚拟机栈-（线程私有）"><a href="#虚拟机栈-（线程私有）" class="headerlink" title="虚拟机栈 （线程私有）"></a><strong>虚拟机栈</strong> <strong>（线程私有）</strong></h1><p> <img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/1.jpg" alt="0"></p>
<p><strong>不存在GC，存在OOM</strong></p>
<p>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧，对应着一次次的方法调用</p>
<p>虚拟机栈的生命周期和线程一致。作用是主管java程序的运行，保存方法的局部变量（8种基本数据类型，对象的引用地址，对象实际存储在堆空间中），部分结果，并参与方法的调用和返回</p>
<p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</p>
<h2 id="JVM直接对栈的操作："><a href="#JVM直接对栈的操作：" class="headerlink" title="JVM直接对栈的操作："></a>JVM直接对栈的操作：</h2><p><strong>1、每个方法执行，伴随着进栈（入栈，压栈）</strong></p>
<p>2、执行结束后的出栈操作</p>
<h2 id="设置栈内存的大小"><a href="#设置栈内存的大小" class="headerlink" title="设置栈内存的大小"></a><strong>设置栈内存的大小</strong></h2><p>使用参数-Xss选项设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p>
<h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a><strong>栈的存储单位</strong></h2><p><strong>1）栈中的数据都是以栈帧为基本单位存在</strong></p>
<p><strong>2）在这个线程上正在执行的每个方法都各自对应着一个栈帧</strong></p>
<p><strong>3）栈帧是一个内存区块，是一个数据集，****维系着方法执行过程中的各种数据信息</strong></p>
<p><strong>4）在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧，与当前栈帧相对应的方法就是当前方法，定义这个方法的类就是当前类。</strong></p>
<p><strong>5）执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</strong></p>
<p><strong>6）如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</strong></p>
<p>​    <img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/2.jpg" alt="0"></p>
<h2 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a><strong>栈帧的内部结构</strong></h2><p><strong>每个栈帧都存储着：</strong></p>
<ol>
<li><strong>局部变量表</strong></li>
<li><strong>操作数栈（表达式栈）</strong></li>
<li>动态链接（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（或方法正常退出或异常退出的定义）</li>
<li>一些附加信息</li>
</ol>
<p>方法嵌套调用的次数由栈的大小决定，栈越大，方法嵌套调用的次数就越多。</p>
<p>对于一个函数，参数和局部变量越多，局部变量表就会膨胀，栈帧就越大</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a><strong>局部变量表</strong></h3><p>1、存放编译器的各种基本数据类型（8种）引用类型（reference）returnAddress类型的变量</p>
<p>2、定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</p>
<p>3、由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</p>
<p>4、局部变量表所需的容量大小是在编译器就确定下来的（一旦确定就不会更改）</p>
<p><strong>注意：局部变量表中的变量只在当前方法调用中有效，当方法调用结束后，随着方法栈帧的销毁，局部变量表也会销毁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 字节码中方法内部结构的剖析</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> hzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/7/11 14:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">//使用javap -v 类.class 或者使用jclasslib</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVariableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LocalVariableTest test=<span class="keyword">new</span> <span class="title class_">LocalVariableTest</span>();</span><br><span class="line">        <span class="type">int</span> num=<span class="number">10</span>;</span><br><span class="line">        test.test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        String name=<span class="string">&quot;xiaozhi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/3.jpg" alt="0"></p>
<p>​    <img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/4.jpg" alt="0"></p>
<p>​    <img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/5.jpg" alt="0"></p>
<p><strong>比如此处，num对应的起始pc是8，对应代码的实际行数第14行，字节码指令长度是17</strong></p>
<p><strong>所以起始pc加上长度就是字节码的指令长度</strong></p>
<h4 id="textcolor-red-局部变量表的基本存储单元是Slot-变量槽"><a href="#textcolor-red-局部变量表的基本存储单元是Slot-变量槽" class="headerlink" title="textcolor{red}{局部变量表的基本存储单元是Slot(变量槽)"></a>textcolor{red}{局部变量表的基本存储单元是Slot(变量槽)</h4><ul>
<li>32位以内的类型只占用一个Slot（包括returnAddress类型）</li>
<li>64位的类型占用两个Slot（long和double）</li>
<li>byte，short，char在存储前转化为int</li>
<li>boolean也被转换为int，0表示false，1表示true</li>
<li>JVM会为局部变量中的每一个Slot都分配一个访问索引，通过这个索引可以访问局部变量中指定的值</li>
</ul>
<p>​    <img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/6.jpg" alt="0"></p>
<p><strong>如果需要访问一个64bit的局部变量值时，只需要使用前一个索引即可</strong></p>
<p><strong>如果当前帧是由构造方法或者实例的方法进行创建的，那么该对象引用this将会存放在index为0的Slot处，其余的继续排列</strong></p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>​    <img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/7.jpg" alt="0"></p>
<p>*<em>this代表对象实例，而static是随类的加载而加载，先于实例之前就有的，所以不存在于局部变量表中，所以不能使用。</em></p>
<p><strong>变量的分类	一、按照数据类型分：1、基本数据类型		2、引用数据类型</strong></p>
<p><strong>二、按照在类中声明的位置分：	1、成员变量：在使用前都经过默认初始化赋值</strong></p>
<p>​    	  		<strong>类变量：linking的prepare阶段，给类变量默认赋值  —&gt;  initial阶段，给类变量显式赋值即静态代码块赋值</strong></p>
<pre><code>           **实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值**
   
       **2、局部变量：使用前必须进行显示赋值，否则编译不通过**
</code></pre>
<p><strong>局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中的直接或间接引用的对象都不会被回收</strong></p>
<h3 id="操作数（表达式）栈"><a href="#操作数（表达式）栈" class="headerlink" title="操作数（表达式）栈"></a><strong>操作数（表达式）栈</strong></h3><ol>
<li>每一个独立的栈帧中除了包含局部变量表以外，还包含了一个后进先出的操作数栈，也可以称之为表达式栈</li>
<li>在方法执行的过程中，根据字节码指令，往栈中写入数据（入栈）或提取数据（出栈）</li>
<li>主要用于保存计算过程的中间结果，同时作为计算机过程中变量临时的存储空间</li>
<li>当一个方法开始执行的时候，一个新的栈帧也会被创建出来，这个方法的操作数栈是空的</li>
<li>每一个操作数栈都会拥有一个栈深度用于存储数值（max_stack）32bit类型占用一个栈单位深度，64bit类型占用两个栈单位深度</li>
<li>操作数栈不是通过访问索引的方式来进行数据访问的，而只能通过标准的入栈出栈来进行数据访问</li>
</ol>
<h4 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a><strong>代码追踪</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/8.jpg" alt="0"></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/9.jpg" alt="0"></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/10.jpg" alt="0"></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/11.jpg" alt="0"></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/12.jpg" alt="0"></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/13.jpg" alt="0"></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/14.jpg" alt="0"></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/15.jpg" alt="0"></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/16.jpg" alt="0"></p>
<h4 id="操作数栈的最大深度"><a href="#操作数栈的最大深度" class="headerlink" title="操作数栈的最大深度"></a><strong>操作数栈的最大深度</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperandStackTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//byte、short、char、boolean:都以int型保存</span></span><br><span class="line">        <span class="type">byte</span> i=<span class="number">15</span>;</span><br><span class="line">        <span class="type">short</span> j=<span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> k=i+j;</span><br><span class="line">        <span class="type">long</span> m=<span class="number">12L</span>;</span><br><span class="line">        <span class="type">int</span> n=<span class="number">800</span>;</span><br><span class="line">        <span class="comment">//存在宽化类型转换</span></span><br><span class="line">        m=m*n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/17.jpg" alt="0"></p>
<h4 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a><strong>栈顶缓存技术</strong></h4><p>为了解决指令过多导致频繁地执行内存读&#x2F;写操作，影响执行速度的问题</p>
<p>将栈顶元素全部缓存在物理CPU的寄存器中,以此降低对内存的读&#x2F;写次数</p>
<p><strong>(将计算的操作放到CPU寄存器里面去)</strong></p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a><strong>动态链接</strong></h3><p>栈帧内部包含了一个指向运行时常量池中该栈帧所属方法的引用—动态链接</p>
<p>每一个栈帧内部都包含一个指向运行时常量池Constant pool或该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如invokedynamic指令</p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/18.jpg" alt="0"></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/19.jpg" alt="0"></p>
<p>动态链接的作用就是为了将这些符号引用(#)最终转换为调用方法的直接引用</p>
<h4 id="方法的调用："><a href="#方法的调用：" class="headerlink" title="方法的调用："></a><strong>方法的调用：</strong></h4><ul>
<li>静态链接：在字节码文件装载进JVM内部时，被调用的方法在编译期可知，而且在运行的期间保持不变，这时候符号引用就会转换为直接引用。这个过程即为静态链接</li>
<li>动态链接：被调用的方法在编译期不可确定，在程序运行的期间才将符号引用进行转换，这个过程为动态链接</li>
<li>绑定：一个字段，方法，类在符号引用转换为直接引用的过程</li>
<li>早期绑定：被调用的目标方法在编译期内可知，运行期间不变</li>
<li>晚期绑定：调用方法在编译期无法确定，到运行期才确定</li>
<li>非虚方法：在编译器确定调用的版本，这个版本运行时不变，比如：静态方法，私有方法，final方法，实例构造器，父类方法</li>
<li>虚方法：其他</li>
</ul>
<h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a><strong>虚方法表</strong></h4><p><strong>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</strong></p>
<p><strong>如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中</strong></p>
<p><strong>虚方法表会在类加载的链接阶段被创建并开始初始化</strong> <strong>，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</strong></p>
<p><img src="/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/20.jpg" alt="0"></p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a><strong>方法返回地址</strong></h3><p><em><strong>存储调用该方法的PC寄存器的值</strong></em></p>
<p><em><strong>在方法推出后都会返回到该方法被调用的位置。</strong></em></p>
<p><em><strong>方法正常退出时，调用者的PC计数器的值作为返回地址（调用该方法的指令的下一条指令的地址）</strong></em></p>
<p><em><strong>方法异常退出时，返回地址通过异常表来确定</strong></em></p>
<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a><strong>相关问题</strong></h2><p><strong>1、举例栈溢出的情况：通过-Xss设置栈的大小（OOM）</strong></p>
<p><strong>2、调整栈大小，就能保证不出现溢出吗？不能</strong></p>
<p><strong>3、分配的栈内存越大越好吗？不是，栈空间大了线程数就少了，栈空间和线程数目成反比</strong></p>
<p><strong>4、垃圾回收是否会涉及到虚拟机栈？不会</strong></p>
<p><strong>5、方法中定义的局部变量是否线程安全？看情况</strong></p>
<p><strong>6、代码演示：（内部产生，在内部消亡，线程安全）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//s1的声明方式是线程安全的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//StringBuilder线程不安全</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//s2的操作过程是线程不安全的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder s2)</span>&#123;</span><br><span class="line">    s2.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//s3的操作是线程不安全的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    s3.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> s3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//s4的操作是线程安全的,s4其实在内部消亡了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    s4.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> s4.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">        s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    method2(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>08-方法区</title>
    <url>/2022/07/14/08-%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="方法区的演变"><a href="#方法区的演变" class="headerlink" title="方法区的演变"></a>方法区的演变</h1><p><img src="/2022/07/14/08-%E6%96%B9%E6%B3%95%E5%8C%BA/1.png" style="zoom: 67%;"><img src="/2022/07/14/08-%E6%96%B9%E6%B3%95%E5%8C%BA/2.png" style="zoom: 67%;"><img src="/2022/07/14/08-%E6%96%B9%E6%B3%95%E5%8C%BA/3.png" style="zoom: 67%;"></p>
<br>

<p><strong>只有HotSpot虚拟机才有永久代</strong></p>
<p>1、jdk1.6之前：又永久代，静态变量存储在永久代上</p>
<p>2、jdk1.7：又永久代，字符串常量池，静态变量移除，保存在堆中</p>
<p>3、jdk1.8以后：无永久代，类型信息、字段、方法、常量池保存在本地内存的元空间，但字符串常量池，静态变量仍在堆</p>
<img src="/2022/07/14/08-%E6%96%B9%E6%B3%95%E5%8C%BA/8.png" style="zoom: 75%;">

<br>

<h2 id="永久代为什么要被元空间替换？"><a href="#永久代为什么要被元空间替换？" class="headerlink" title="永久代为什么要被元空间替换？"></a>永久代为什么要被元空间替换？</h2><p>1、为永久代设置空间大小是很难确定的如果动态加载类过多，容易产生永久代的OOM，而元空间使用本地内存，只受本地内存的影响</p>
<p>2、对永久代调优困难</p>
<br>

<h2 id="字符串常量池为什么要放到堆空间？"><a href="#字符串常量池为什么要放到堆空间？" class="headerlink" title="字符串常量池为什么要放到堆空间？"></a>字符串常量池为什么要放到堆空间？</h2><p>因为永久代的回收率很低，在进行full GC的时候才会触发，而full GC是老年代空间不足、永久代不足时才会触发，所以导致回收效率不高。但是<em><strong>实际中又有大量字符会被创建，回收效率低导致永久代空间不足。放到堆里，可以及时回收。</strong></em></p>
<br>

<h1 id="方法区的概述"><a href="#方法区的概述" class="headerlink" title="方法区的概述"></a>方法区的概述</h1><p>1、方法区在JVM启动的时候被创建，它的实际的物理内存空间可以是不连续的<em><strong>（关闭 JVM 就会释放这个区域的内存）</strong></em></p>
<p><em><strong>2、方法区时逻辑上是堆的一个组成部分</strong></em>，但是在不同虚拟机里头实现是不一样的，最典型的就是永久代(PermGen space)和元空间(Metaspace)<br><em><strong>（注意：方法区是一种规范，而永久代和元空间是它的一种实现方式）</strong></em></p>
<p>3、方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类,导致方法区溢出，虚拟机同样会抛出内存溢出错误：(<code>java.lang.OutOfMemoryError:PermGen space</code>、<code>java.lang.OutOfMemoryError:Metaspace</code>)</p>
<ul>
<li>加载过多的jar包</li>
<li>tomcat部署的过程过多</li>
<li>反射类太多</li>
</ul>
<p>4、jdk7及以前，将方法区的实现称为永久代，jdk8之后，使用元空间取代了永久代</p>
<p><em><strong>5、元空间和永久代的区别：元空间不在虚拟机设置的内存中，而是使用本地内存</strong></em></p>
<img src="/2022/07/14/08-%E6%96%B9%E6%B3%95%E5%8C%BA/5.png" style="zoom: 67%;">

<br>

<h1 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h1><p><strong>jdk7及以前</strong></p>
<p><code>-XX:PermSize=100m</code>（默认值是20.75M）</p>
<p><code>-XX:MaxPermSize=100m</code>（32位机器默认是64M，64位是82M）</p>
<p><strong>jdk1.8及以后</strong></p>
<p><code>-XX:MetaspaceSize=100m</code>（windows默认约等于21M）</p>
<p><code>-XX:MaxMetaspaceSize=100m</code>（默认是-1,即没有限制）</p>
<br>

<h1 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h1><p><em><strong>存储已被虚拟机记载的类型信息、常量、静态变量、即时编译器编译后的代码缓存、域信息、方法信息</strong></em></p>
<h2 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h2><p><strong>对每个加载的类型（类，接口，枚举，注解）JVM 必须在方法区中存储以下类型信息</strong></p>
<p>1、类型的完整有效名称（全名&#x3D;包名.类名）</p>
<p>2、直接父类的完整有效名（接口和Object类没有）</p>
<p>3、修饰符</p>
<p><em><strong>4、直接接口的一个有序列表</strong></em></p>
<br>

<h2 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h2><p><em><strong>域名称，域修饰符（public，private……），域类型</strong></em></p>
<br>

<h2 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h2><p>1、方法名称</p>
<p>2、方法返回类型</p>
<p>3、方法参数的数量和类型<strong>（按顺序）</strong></p>
<p>4、方法的字节码，操作数栈和局部变量表的大小</p>
<br>

<h2 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h2><p>1、静态变量和类关联在一起，<em><strong>随着类的加载而加载</strong></em></p>
<p><em><strong>2、类变量被所有类的实例共享，即使没有类实例也可以访问它</strong></em></p>
<p>以下代码不会报空指针异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="全局常量：static-final"><a href="#全局常量：static-final" class="headerlink" title="全局常量：static final"></a>全局常量：static final</h2><p><em><strong>每个全局常量在编译的时候就会被分配</strong></em></p>
<br>

<h2 id="常量池与运行时常量池"><a href="#常量池与运行时常量池" class="headerlink" title="常量池与运行时常量池"></a>常量池与运行时常量池</h2><p><em><strong>方法区内部包含了运行时常量池</strong></em></p>
<p><em><strong>字节码文件中包含了常量池</strong></em></p>
<p><em><strong>当类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</strong></em></p>
<br>

<h3 id="常量池的理解"><a href="#常量池的理解" class="headerlink" title="常量池的理解"></a>常量池的理解</h3><p>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型、字面量等信息（主要是字面量和符号引用）</p>
<img src="/2022/07/14/08-%E6%96%B9%E6%B3%95%E5%8C%BA/6.png" style="zoom: 90%;">

<p><em><strong>一个 java 程序编译生成字节码文件后，字节码文件需要大量数据支持进行解析，如果将数据直接存进字节码，文件过大所以将数据存进常量池，字节码中包含了指向常量池的引用</strong></em></p>
<br>

<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><em><strong>字节码文件中的常量池表经过类加载器放到方法区后，对应的结构就称为运行时常量池</strong></em></p>
<p><em><strong>当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</strong></em></p>
<p><strong>注意：</strong></p>
<p>1、运行时常量池是方法区的一部分。</p>
<p>2、运行时常量池中包含多种不同的常量，包括<em><strong>编译期就已经明确的数值字面量</strong></em>，也包括到<em><strong>运行期解析后才能够获得的方法或者字段引用</strong></em> <em><strong>此时不再是常量池中的符号地址了，这里换为真实地址。</strong></em></p>
<p>3、运行时常量池相较于Class文件中的常量池的特征：<em><strong>动态性</strong></em></p>
<p><em><strong>4、符号地址变为真实地址其实就是，在<code>*.class文件</code>被加载到内存以后，将<code>*.class文件</code>中常量池中的<code>#x</code>符号地址，转化为内存中的地址。</strong></em></p>
<br>

<h1 id="方法区的垃圾收集"><a href="#方法区的垃圾收集" class="headerlink" title="方法区的垃圾收集"></a>方法区的垃圾收集</h1><blockquote>
<p>前言：</p>
<p>方法区内常量池之中主要存放的两大类常量：字面量和符号引用。 </p>
<p>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。</p>
<p>符号引用则属于编译原理方面的概念，包括</p>
<ol>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ol>
</blockquote>
<p>方法区中主要回收</p>
<p>1、常量池中废弃的常量</p>
<p>2、不再使用的类型</p>
<p>只要常量池中的常量没有被任何地方引用，就可以被回收（与堆中回收对象类似）</p>
<p>判断一个类是否要进行回收（*）</p>
<p><img src="/2022/07/14/08-%E6%96%B9%E6%B3%95%E5%8C%BA/7.png"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>07-堆</title>
    <url>/2022/07/13/07-%E5%A0%86/</url>
    <content><![CDATA[<h1 id="堆的核心概述"><a href="#堆的核心概述" class="headerlink" title="堆的核心概述"></a><strong>堆的核心概述</strong></h1><p>一个进程对应一个JVM实例，一个JVM实例中有一个运行时数据区，一个运行时数据区中只有一个堆空间</p>
<p><strong>进程中的多个线程各自拥有一套程序计数器，本地方法栈，虚拟机栈，但是多个线程共享同一个堆空间</strong></p>
<ul>
<li>一个JVM实例只存在一个堆内存，堆是Java内存管理的核心区域</li>
<li>堆区在JVM启动的时候就被创建，其空间大小也确定了<em><strong>（JVM管理的最大一块内存区域，大小可调节）</strong></em></li>
<li>堆可以处于物理上不连续的内存空间，但在逻辑上它应该被视为连续的</li>
<li><strong>多个线程共享一个堆区，容易造成并发性能差的问题，所以堆划分出线程私有的缓冲区，每个线程占一份</strong></li>
<li>几乎所有的对象实例都在这里分配内存</li>
<li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，指向对象或数组在堆中的位置</li>
<li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾回收的时候会被移除<em><strong>（只是移除了方法区指向堆空间的索引，如果方法结束就移除堆中的对象的话，当方法多次调用时，会因为多次 GC而影响系统性能）</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHeap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleHeap</span><span class="params">(<span class="type">int</span> id)</span> &#123;<span class="built_in">this</span>.id = id;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;My ID is &quot;</span> + id); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleHeap</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHeap</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">SimpleHeap</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHeap</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/07/13/07-%E5%A0%86/1.png" alt="1" style="zoom: 70%;">



<h1 id="堆内存结构概述和OOM"><a href="#堆内存结构概述和OOM" class="headerlink" title="堆内存结构概述和OOM"></a><strong>堆内存结构概述和OOM</strong></h1><h2 id="堆空间细分为"><a href="#堆空间细分为" class="headerlink" title="堆空间细分为"></a>堆空间细分为</h2><ul>
<li><p>JDK 7及之前堆内存逻辑上分为三部分：<strong>新生区+养老区+永久区</strong></p>
</li>
<li><p>JDK 8及之后堆内存逻辑上分为三部分：<strong>新生区+养老区+元空间</strong></p>
</li>
</ul>
<p>新生区&lt;&#x3D;&gt;新生代&lt;&#x3D;&gt;年轻代</p>
<p>养老区&lt;&#x3D;&gt;老年区&lt;&#x3D;&gt;老年代</p>
<p>永久代&lt;&#x3D;&gt;永久区</p>
<h2 id="堆空间大小的设置-Xms-Xmx"><a href="#堆空间大小的设置-Xms-Xmx" class="headerlink" title="堆空间大小的设置 -Xms -Xmx"></a>堆空间大小的设置 -Xms -Xmx</h2><p><code>-Xms</code>（默认：物理内存的1&#x2F;64）：表示<strong>堆空间（新生代＋老年代）的起始内存</strong></p>
<p><code>-Xmx</code>（默认：物理内存的1&#x2F;4）：则用于表示<strong>堆空间的最大内存</strong></p>
<p><strong>通常会将-Xms和-Xmx两个参数配置相同的值，目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提升性能</strong></p>
<h2 id="新生代与老年代"><a href="#新生代与老年代" class="headerlink" title="新生代与老年代"></a><strong>新生代与老年代</strong></h2><p>堆区可细分为新生代和老年代，新生代又可划分为Eden空间，Survivor1空间和Survivor2空间（from区，to区）</p>
<img src="/2022/07/13/07-%E5%A0%86/2.png" alt="1" style="zoom: 70%;">

<ul>
<li>配置新生代和老年代在堆结构中的占比<strong>（一般不进行调整）</strong></li>
</ul>
<p>默认情况下 <code>-XX:NewRatio=2</code>，表示新生代占1，老年代占2，即新生代占整个堆的1&#x2F;3</p>
<ul>
<li>配置年轻代中的Eden和Survivor区的比例</li>
</ul>
<p> <code>-XX:SurvivorRatio=8</code>，表示调整这个空间比例<strong>（Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1）</strong></p>
<ul>
<li>配置新生代的空间的大小：<code>-Xmn</code>，一般不设置</li>
</ul>
<p><strong>几乎所有的Java对象都是在Eden区被new出来的，大部分的Java对象的销毁都在新生代进行的</strong></p>
<h1 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a><strong>对象分配</strong></h1><h2 id="一般过程"><a href="#一般过程" class="headerlink" title="一般过程"></a>一般过程</h2><img src="/2022/07/13/07-%E5%A0%86/3.png" alt="1" style="zoom: 70%;">

<p><strong>首先对象先存储到Eden区</strong>，当Eden区存满的时候，<strong>会触发Young GC（Minor GC）</strong>，此时会把用户工作进程停止，称为STW（stop the world），然后判断Eden区里面哪些对象需要回收。（如图所示，红色为回收的对象）</p>
<p>然后将不需要回收的对象放到from区，并加上年龄计数器1</p>
<img src="/2022/07/13/07-%E5%A0%86/4.png" alt="1" style="zoom: 70%;">

<p><em><strong>当from区存满的时候，如果对象还不需要回收，那么就会转入到to区，然后在年龄计数器上加上1，此时Eden里面不需要回收的对象也会存储在to区</strong></em></p>
<p><em><strong>此时，form区为空，from和 to区就互相转换</strong></em></p>
<img src="/2022/07/13/07-%E5%A0%86/5.png" alt="1" style="zoom: 70%;">

<p>当年龄计数器上的值为阈值时（默认为15）对象就会转存到老年区</p>
<p>采用<code>-XX:MaxTenuringThreshold</code>，参数可以设置对象在经过多少次GC后会被放入老年代</p>
<p><em><strong>实际上时对 Eden区到 Survivor区过度的一种策略，是为了保证 Eden区到 Survivor区不会频繁的进行复制一直存活的对象且对Survivor区也能保证不会具有太多的一直占据的内存</strong></em></p>
<p><em><strong>关于垃圾回收，频繁在新生区进行收集，很少在养老区收集，几乎不在永久区 &#x2F; 元空间收集</strong></em></p>
<h2 id="特殊过程"><a href="#特殊过程" class="headerlink" title="特殊过程"></a>特殊过程</h2><p><strong>当存在一个超大对象，导致Eden区放不下的时候，该对象则会直接放到老年区</strong></p>
<p>如果老年区放不下：</p>
<ol>
<li><strong>如果老年区本来的空间够放得下该对象，但是一部分被占用了。则进行Full GC，之后如果空间还是放不下，则直接OOM</strong></li>
<li><strong>如果老年区本来的空间就放不下该对象，直接返回OOM</strong></li>
</ol>
<img src="/2022/07/13/07-%E5%A0%86/6.png" alt="1" style="zoom: 110%;">



<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p><strong>关于HotSpot VM的实现，GC按照回收区域可以分为部分收集和整堆收集</strong></p>
<p>一、部分收集（Partial GC）：不是完整收集整个Java堆的垃圾收集，其中分为</p>
<ul>
<li>新生代收集（Minor GC &#x2F; Young GC）：只是新生代（Eden&#x2F;S0&#x2F;S1）的垃圾收集</li>
<li>老年代收集（Major GC &#x2F; Old GC）：只是老年代的垃圾收集</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集</li>
</ul>
<p>二、整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集</p>
<p><em><strong>注意：</strong></em></p>
<p><em><strong>1、目前只有CMS GC会有单独收集老年代的行为</strong></em></p>
<p><em><strong>2、很多时候Major GC会和Full GC一起混合使用，需要具体分辨是老年代回收还是整堆回收</strong></em></p>
<h2 id="新生代GC（Minor-GC）触发机制"><a href="#新生代GC（Minor-GC）触发机制" class="headerlink" title="新生代GC（Minor GC）触发机制"></a>新生代GC（Minor GC）触发机制</h2><p><strong>当新生代空间不足时，就会触发，这里的新生代空间不足指的是Eden区已满</strong></p>
<p><em><strong>注意：</strong></em></p>
<ul>
<li><strong>Survivor满不会引发GC</strong>（每次Minor GC都会清理新生代的内存）</li>
<li>Minor GC非常频繁，回收速度较快</li>
<li>会引发STW</li>
</ul>
<h2 id="老年代GC（Major-GC-x2F-Full-GC）触发机制"><a href="#老年代GC（Major-GC-x2F-Full-GC）触发机制" class="headerlink" title="老年代GC（Major GC &#x2F; Full GC）触发机制"></a>老年代GC（Major GC &#x2F; Full GC）触发机制</h2><p><strong>当发生在老年代的GC，对象从老年代消失时，我们说老年代GC触发了</strong></p>
<p><em><strong>注意：</strong></em></p>
<ul>
<li><em><strong>当老年代空间不足时，会尝试先触发Minor GC。如果之后空间还不足，则触发Major GC</strong></em></li>
<li>Major GC的速度比Minor GC满10倍以上，STW时间更长</li>
<li>Major GC后，如果内存还是不足，直接返回OOM</li>
</ul>
<h2 id="Full-GC触发机制（-）"><a href="#Full-GC触发机制（-）" class="headerlink" title="Full GC触发机制（*）"></a>Full GC触发机制（*）</h2><p>1、调用 <code>System.gc()</code> 时，系统建议执行Full GC，但是不必然执行</p>
<p>2、老年代空间不足</p>
<p>3、方法区空间不足</p>
<p>…………</p>
<h1 id="堆空间分代的思想"><a href="#堆空间分代的思想" class="headerlink" title="堆空间分代的思想"></a>堆空间分代的思想</h1><p>分代的唯一目的就是优化GC的性能</p>
<p>如果没有分代，那么所有的对象都在一块，当要进行GC的时候，判断哪些对象需要回收，哪些不需要的时候，就需要对整个空间进行扫描。<strong>如果进行分代处理的话，就可以把新创建的一些对象，放在同一块区域，GC的时候就可以针对性地进行搜索，而且还可以腾出一大块区域</strong></p>
<h1 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h1><ul>
<li>优先分配到Eden区</li>
<li>大对象直接分配到老年代</li>
<li>长期存活的对象分配到老年代</li>
<li><em><strong>动态对象的年龄判断：如果Survivor区中相同年龄的所有对象的和大于其空间的一般，年龄大于或等于该年龄的对象直接进入老年代</strong></em></li>
<li>空间分配担保（*）</li>
</ul>
<h1 id="TLAB为对象分配内存"><a href="#TLAB为对象分配内存" class="headerlink" title="TLAB为对象分配内存"></a>TLAB为对象分配内存</h1><h2 id="为什么要有TLAB？"><a href="#为什么要有TLAB？" class="headerlink" title="为什么要有TLAB？"></a>为什么要有TLAB？</h2><p>1、对象的创建在JVM中很频繁，所以在并发环境下从堆区中划分内存空间是线程不安全的</p>
<p>2、为了避免多个线程操作同一个地址，需要加锁，从而影响分配的速度</p>
<h2 id="什么是TLAB？"><a href="#什么是TLAB？" class="headerlink" title="什么是TLAB？"></a>什么是TLAB？</h2><p>1、在Eden区域进行划分，为每个线程分配了一个私有缓存的区域</p>
<p>2、多个线程共同操作时，可以避免线程安全问题，提升内存分配吞吐量</p>
<p><em><strong>注意：</strong></em></p>
<p>1、JVM将TLAB作为内存分配的首选</p>
<p><em><strong>2、TLAB只占 Eden的1%，当对象在TLAB空间分配内存失败后，JVM在Eden直接分配内存，而且通过加锁来确保原子性</strong></em></p>
<p>3、TLAB大小可以通过 <code>-XX:TLABWasteTargetPercent</code> + 参数进行设置</p>
<img src="/2022/07/13/07-%E5%A0%86/7.png" alt="1" style="zoom: 80%;">



<h1 id="总结堆空间参数设置"><a href="#总结堆空间参数设置" class="headerlink" title="总结堆空间参数设置"></a>总结堆空间参数设置</h1><p><em><strong>1、<code>-XX:+PrintFlagsInitial</code> : 查看所有的参数的默认初始值</strong></em></p>
<p>2、<code>-XX:+PrintFlagsFinal</code> : 查看所有的参数的最终值(可能会存在修改(:表示修改了),不再是初始值)</p>
<p>3、具体查看某个参数的指令:</p>
<ul>
<li>jps:查看当前运行中的进程</li>
<li>jinfo -flag SurvivorRatio 进程id</li>
</ul>
<p><em><strong>4、-Xms:初始堆空间内存 (默认为物理内存的1&#x2F;64)</strong></em></p>
<p><em><strong>5、-Xmx:最大堆空间内存(默认为物理内存的1&#x2F;4)</strong></em></p>
<p>6、-Xmn:设置新生代的大小。(初始值及最大值)</p>
<p>7、<code>-XX:NewRatio</code>:配置新生代与老年代在堆结构的占比</p>
<ul>
<li>默认:-<code>XX:NewRatio=2</code>,表示新生代占1,老年代占2,新生代占整个堆的1&#x2F;3</li>
<li>可以修改<code>-XX:NewRatio=4</code>,表示新生代占1,老年代占4,新生代占整个堆的1&#x2F;5</li>
</ul>
<p>8、<code>-XX:SurvivorRatio</code>:设置新生代中Eden和S0&#x2F;S1空间的比例<br>(Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1)</p>
<p>9、<code>-XX:MaxTenuringThreshold</code>设置新生代垃圾的最大年龄</p>
<p><em><strong>10、-XX:+PrintGCDetails:输出详细的GC处理日志</strong></em><br><em><strong>(如下这两种方式是简单的打印 gc 简要信息：</strong></em></p>
<p><em><strong>1） <code>-XX:+PrintGC</code></strong></em></p>
<p>*<strong>2） <code>-verbose:gc*</code></strong></p>
<p><em><strong>11、<code>-XX:HandlePromotionFailure</code>:是否设置空间分配担保</strong></em><br><em><strong>(JDK6之后,只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC,否则将进行Full GC)</strong></em></p>
<h1 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><em><strong>将堆上的对象分配到栈，需要使用逃逸分析手段</strong></em></p>
<ol>
<li><strong>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸</strong></li>
<li>当一个对象在方法中被定义后，它被外部方法所引用,则认为发生逃逸。<strong>例如作为调用参数传递到其他地方中</strong></li>
</ol>
<p><strong>其实就是看new出来的对象是否有可能在方法外被调用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> EscapeAnalysis object;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 方法返回 EscapeAnalysis 对象，发生逃逸</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> EscapeAnalysis <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">return</span> <span class="variable">object</span> <span class="operator">=</span>= <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>() : object;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 对象的作用域仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis1</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis2</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">EscapeAnalysis</span> <span class="variable">instance</span> <span class="operator">=</span> getInstance();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在jdk7及之后，可以通过</p>
<p>1、<code>-XX:+DoEscapeAnalysis</code> 显式开启逃逸分析</p>
<p>2、通过 <code>-XX:+PrintEscapeAnalysis</code> 查看逃逸分析的筛选结果</p>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><ul>
<li>成员变量赋值</li>
<li>方法返回值</li>
<li>实例引用传递</li>
</ul>
<p><em><strong>在开启逃逸分析后执行时间变，而且没有发生GC</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈上分配测试</span></span><br><span class="line"><span class="comment">//-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看执行时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span>+(end-start)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="comment">//为了方便查看堆内存中对象的个数，线程sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(); <span class="comment">//未发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h3><p>也叫做锁消除，指在动态编译同步块时，JIT编译器可以<strong>借助逃逸分析来判断同步块所使用的锁对象是否只能被一个线程访问而没有被发布到其他线程</strong>，如果没有，那么在编译这个同步块的时候，就会<strong>取消这部分代码的同步</strong>，大大提高并发性和性能。</p>
<p><strong>代码中堆obj进行加锁，但是obj对象的生命周期只在test1方法中，并不会被其他线程访问到，所以在JIT编译阶段就会优化成test2的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分离对象或标量替换"><a href="#分离对象或标量替换" class="headerlink" title="分离对象或标量替换"></a>分离对象或标量替换</h3><p>标量：一个无法再分解成更小的数据的数据，如基本数据类型</p>
<p>聚合量：还可以继续分解的数据，如对象</p>
<p><em><strong>如果一个对象不会被外界访问的话，经过JIT的优化，就会把对象拆解成若干个成员变量来替代，这就是标量替换</strong></em></p>
<p><em><strong>标量替换可以大大减少堆内存的占用，因为不需要创建对象，也就不需要分配堆内存</strong></em></p>
<p>参数：<code>-XX:+EliminateAllocations</code>开启标量替换，允许将对象打散分配在栈上<strong>（默认打开）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; alloc();&#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;x&quot;</span> + point.x + <span class="string">&quot;;&quot;</span> + <span class="string">&quot;y&quot;</span> + point.y);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">       <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> i1)</span> &#123;&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;x&quot;</span> + x + <span class="string">&quot;;&quot;</span> + <span class="string">&quot;y&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>09-对象的实例化，内存布局和访问定位</title>
    <url>/2022/07/14/09-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%8C%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="对象实例化与创建"><a href="#对象实例化与创建" class="headerlink" title="对象实例化与创建"></a>对象实例化与创建</h1><p><a href="https://www.processon.com/view/link/62d003731e08530a891e2b9b">对象实例化的概述（点我）</a></p>
<p><strong>测试对象实例化的过程</strong></p>
<p><em><strong>①加载类元信息	②为对象分配内存	③处理并发问题	④属性的默认初始化（零值初始化）</strong></em></p>
<p><em><strong>⑤设置对象头信息	⑥属性的显示初始化、代码块中初始化、构造器中初始化</strong></em></p>
<p><strong>创建的过程（字节码角度）</strong></p>
<p><img src="/2022/07/14/09-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%8C%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/2.png"></p>
<br>

<h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p><a href="https://www.processon.com/view/link/62d02000e401fd259600c5d5">内存布局（点我）</a></p>
<p><img src="/2022/07/14/09-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%8C%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/3.png"></p>
<br>

<h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p><a href="https://www.processon.com/view/link/62d0267e0e3e746072708d8c">对象访问定位概述（点我）</a></p>
<img src="/2022/07/14/09-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%8C%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/4.png" style="zoom:67%;">

<br>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>1-1-数据结构分类</title>
    <url>/2022/07/12/1-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="数据结构分类："><a href="#数据结构分类：" class="headerlink" title="数据结构分类："></a><strong>数据结构分类：</strong></h2><ul>
<li>顺序存储结构： 把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的 ，比如我们常用的数组就是顺序存储结构。</li>
</ul>
<p>​    <img src="/2022/07/12/1-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB/1.png" alt="0" style="zoom:67%;"></p>
<ul>
<li>链式存储结构： 是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。此时，数据元素之间并 不能反映元素间的逻辑关系，因此在链式存储结构中引进了一个指针存放数据元素的地址，这样通过地址就可以找 到相关联数据元素的位置</li>
</ul>
<h2 id="逻辑结构分类："><a href="#逻辑结构分类：" class="headerlink" title="逻辑结构分类："></a><strong>逻辑结构分类：</strong></h2><ul>
<li>集合结构：集合结构中数据元素除了属于同一个集合外，他们之间没有任何其他的关系。</li>
<li>线性结构：线性结构中的数据元素之间存在一对一的关系</li>
<li>树形结构：树形结构中的数据元素之间存在一对多的层次关系</li>
<li>图形结构：图形结构的数据元素是多对多的关系</li>
</ul>
<p><img src="/2022/07/12/1-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB/2.png" alt="0" style="zoom: 67%;">  <img src="/2022/07/12/1-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB/3.png" alt="0" style="zoom: 67%;"></p>
<p><img src="/2022/07/12/1-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB/4.png" alt="0" style="zoom: 67%;">  <img src="/2022/07/12/1-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB/5.png" alt="0" style="zoom: 67%;"></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>1-nginx-目录，配置文件</title>
    <url>/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="使用-工具tree查看目录结构"><a href="#使用-工具tree查看目录结构" class="headerlink" title="使用 工具tree查看目录结构"></a><strong>使用</strong> <strong>工具tree查看目录结构</strong></h1><p><strong>1、安装tree工具：</strong> <strong>yum install -y tree</strong></p>
<p><strong>2、</strong> <strong>tree &#x2F;usr&#x2F;local&#x2F;nginx</strong> <strong>(tree后面跟的是Nginx的安装目录)</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/1.png" alt="0"></p>
<h1 id="查看进程的PID"><a href="#查看进程的PID" class="headerlink" title="查看进程的PID"></a><strong>查看进程的PID</strong></h1><p><strong>1、查看nginx的master进程和worker进程：</strong> <strong>ps -ef | grep nginx</strong></p>
<p><strong>2、nginx的.&#x2F;configure的配置参数的时候，有一个参数是–pid-path&#x3D;PATH默认是</strong> <strong>&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid</strong></p>
<p><strong>所以可以通过查看该文件来获取nginx的master进程ID</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/2.png" alt="0"></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/3.png" alt="0"></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/4.png" alt="0"></p>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a><strong>信号</strong></h1><table>
<thead>
<tr>
<th><strong>信号</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>TERM或INT</strong></td>
<td><strong>立即关闭整个服务</strong></td>
</tr>
<tr>
<td><strong>QUIT</strong></td>
<td><strong>“优雅”地关闭整个服务</strong></td>
</tr>
<tr>
<td><strong>HUP</strong></td>
<td><strong>重读配置文件并使用服务对新配置项生效</strong></td>
</tr>
<tr>
<td><strong>USR1</strong></td>
<td><strong>重新打开日志文件，可以用来进行日志切割</strong></td>
</tr>
<tr>
<td><strong>USR2</strong></td>
<td><strong>平滑升级</strong> <strong>到最新版的nginx</strong></td>
</tr>
<tr>
<td><strong>WINCH</strong></td>
<td><strong>所有子进程不在接收处理新连接相当于给work进程发送QUIT指令</strong></td>
</tr>
</tbody></table>
<h2 id="调用命令为-kill-signal-PID"><a href="#调用命令为-kill-signal-PID" class="headerlink" title="调用命令为 kill -signal PID"></a><strong>调用命令为</strong> <strong>kill -signal PID</strong></h2><p><strong>1、发送</strong>  <strong>TERM 或 INT</strong>  <strong>信号给master进程，会将Nginx服务</strong> <strong>立即关闭</strong> <strong>。</strong></p>
<p><strong>2、发送</strong>  <strong>QUIT</strong>  <strong>信号给master进程，master进程会控制所有的work进程不再接收新的请求，</strong> <strong>等所有请求处理完后，在把进程都关闭掉</strong></p>
<p><strong>3、发送</strong>  <strong>HUP</strong>  <strong>信号给master进程，master进程会把控制旧的work进程不再接收新的请求，等处理完请求后将旧的work进程关闭掉，然后根据nginx的配置文件重新启动新的work进程</strong></p>
<p><strong>4、发送</strong>  <strong>USR1</strong>  <strong>信号给master进程，告诉Nginx重新开启日志文件</strong></p>
<p><strong>5、</strong> <strong>发送</strong>  <strong>USR2</strong>  <strong>信号给master进程，</strong> <strong>重新开启对应的master进程和work进程</strong> <strong>，这时系统里会有两个master进程和四个master进程</strong></p>
<p><strong>新的master进程的PID会被记录在			&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid</strong></p>
<p><strong>而之前的旧的master进程PID会被记在	&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid.oldbin文件中</strong></p>
<p><strong>最后再发送  QUIT  信号给旧的master进程</strong></p>
<p><strong>6、发送</strong>  <strong>WINCH</strong>  <strong>信号给master进程,让master进程控制不让所有的work进程在接收新的请求了</strong></p>
<p><strong>请求处理完后关闭work进程。</strong> <strong>注意master进程不会被关闭掉</strong></p>
<h2 id="nginx命令行控制"><a href="#nginx命令行控制" class="headerlink" title="nginx命令行控制"></a><strong>nginx命令行控制</strong></h2><p><strong>在sbin目录下，可以对nginx进行状态控制</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/5.png" alt="0"></p>
<p><strong>.&#x2F;nginx-v			查看版本号信息</strong>		</p>
<p><strong>.&#x2F;nginx-V			查看版本号信息和配置信息</strong></p>
<p><strong>.&#x2F;nginx-t			测试配置文件语法是否正确</strong></p>
<p><strong>.&#x2F;nginx-T			测试nginx的配置文件语法是否正确并列出用到的配置文件信息然后退出</strong></p>
<p><strong>.&#x2F;nginx-q			在配置测试期间禁止显示非错误消息</strong>	</p>
<p><strong>.&#x2F;nginx-s			s即signal信号，后面可以跟</strong></p>
<ul>
<li><strong>stop[快速关闭，类似于TERM&#x2F;INT信号的作用]</strong></li>
<li><strong>quit[优雅的关闭，类似于QUIT信号的作用]</strong> </li>
<li><strong>reopen[重新打开日志文件类似于USR1信号的作用]</strong> </li>
<li><strong>reload[类似于HUP信号的作用]</strong></li>
</ul>
<p><strong>.&#x2F;nginx-p			指定Nginx的prefix路径</strong></p>
<p><strong>.&#x2F;nginx-c			指定Nginx的配置文件路径</strong></p>
<p><strong>.&#x2F;nginx-g			补充Nginx配置文件，向Nginx服务指定启动时应用全局的配置</strong></p>
<h1 id="nginx-conf配置文件结构"><a href="#nginx-conf配置文件结构" class="headerlink" title="nginx.conf配置文件结构"></a><strong>nginx.conf配置文件结构</strong></h1><p><strong>nginx.conf配置文件中默认有三大块：全局块、events块、http块</strong></p>
<p><strong>http块中可以配置多个server块，每个server块又可以配置多个location块</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/6.png" alt="0"></p>
<h2 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a><strong>全局块</strong></h2><h3 id="一、user指令"><a href="#一、user指令" class="headerlink" title="一、user指令"></a><strong>一、user指令</strong></h3><p><strong>可以指定启动运行工作进程的用户及用户组，这样对于系统的权限访问控制的更加精细，也更加安全</strong></p>
<h3 id="二、work-process指令"><a href="#二、work-process指令" class="headerlink" title="二、work process指令"></a><strong>二、work process指令</strong></h3><p><strong>1、master_process:用来指定是否开启工作进程</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/7.png" alt="0"></p>
<p><strong>2、worker _ processes:用于配置Nginx生成工作进程的数量</strong> <strong>，这个是Nginx服务器实现并发处理服务的关键所在</strong></p>
<p><strong>process的值越大，可以支持的并发处理量也越多</strong> <strong>但事实上这个值的设定是需要受到来自服务器自身的限制建议将该值和服务器CPU的内核数保存一致</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/8.png" alt="0"></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/9.png" alt="0"></p>
<h3 id="三、其他指令"><a href="#三、其他指令" class="headerlink" title="三、其他指令"></a><strong>三、其他指令</strong></h3><p><strong>1、deamon：</strong> <strong>设定Nginx是否以守护进程的方式启动</strong></p>
<p><strong>守护进程是linux后台一种服务进程，特点是独立于控制终端，不会随着终端的关闭而停止</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/10.png" alt="0"></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/11.png" alt="0"></p>
<p><strong>2、pid：</strong> <strong>配置nginx当前master进程的进程号ID存储的文件路径</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/12.png" alt="0"></p>
<p><strong>3、error_log：</strong> <strong>配置nginx错误日志存放路径</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/13.png" alt="0"></p>
<p><strong>日志级别的值有：debug|info|notice|warn|error|crit|alert|emerg</strong></p>
<p>​								  调试 |信息|  通知  | 警告 | 错误 |临界|警报|紧急</p>
<p><strong>4、include：</strong> <strong>引入其他配置文件</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/14.png" alt="0"></p>
<h3 id="测试："><a href="#测试：" class="headerlink" title="测试："></a><strong>测试：</strong></h3><p><strong>1）创建一个main.conf，在里面写上配置文件</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/15.png" alt="0"></p>
<p><strong>2）引入配置文件</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/16.png" alt="0"></p>
<p><strong>3）加载成功</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/17.png" alt="0"></p>
<h2 id="events块"><a href="#events块" class="headerlink" title="events块"></a><strong>events块</strong></h2><h3 id="1、-accept-mutex：-设置nginx网络连接序列化"><a href="#1、-accept-mutex：-设置nginx网络连接序列化" class="headerlink" title="1、 accept_mutex： 设置nginx网络连接序列化"></a><strong>1、</strong> <strong>accept_mutex：</strong> <strong>设置nginx网络连接序列化</strong></h3><p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/18.png" alt="0"></p>
<p><strong>如果设置为on，将会对多个Nginx进程接收连接进行序列号，一个个来唤醒接收，</strong> <strong>防止了多个进程对连接的争抢</strong></p>
<h3 id="2、-multi-accept：-用来设置是否允许同时接收多个网络连接"><a href="#2、-multi-accept：-用来设置是否允许同时接收多个网络连接" class="headerlink" title="2、 multi_accept： 用来设置是否允许同时接收多个网络连接"></a><strong>2、</strong> <strong>multi_accept：</strong> <strong>用来设置是否允许同时接收多个网络连接</strong></h3><p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/19.png" alt="0"></p>
<p><strong>如果multi_accept被禁止了，nginx一个工作进程只能同时接受一个新的连接。否则，一个工作进程可以同时接受所有的新连接</strong></p>
<h3 id="3、-worker-connections：-用来配置单个worker进程最大的连接数"><a href="#3、-worker-connections：-用来配置单个worker进程最大的连接数" class="headerlink" title="3、 worker_connections： 用来配置单个worker进程最大的连接数"></a><strong>3、</strong> <strong>worker_connections：</strong> <strong>用来配置单个worker进程最大的连接数</strong></h3><p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/20.png" alt="0"></p>
<p><strong>连接数不仅仅包括和前端用户建立的连接数，而是包括所有可能的连接数</strong></p>
<h3 id="4、-use：用来设置Nginx服务器选择哪种事件驱动来处理网络消息"><a href="#4、-use：用来设置Nginx服务器选择哪种事件驱动来处理网络消息" class="headerlink" title="4、 use：用来设置Nginx服务器选择哪种事件驱动来处理网络消息"></a><strong>4、</strong> <strong>use：</strong>用来设置Nginx服务器选择哪种事件驱动来处理网络消息</h3><p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/21.png" alt="0"></p>
<h2 id="HTTP块"><a href="#HTTP块" class="headerlink" title="HTTP块"></a><strong>HTTP块</strong></h2><h3 id="自定义MIME-Type（网络资源的媒体类型）"><a href="#自定义MIME-Type（网络资源的媒体类型）" class="headerlink" title="自定义MIME-Type（网络资源的媒体类型）"></a><strong>自定义MIME-Type（网络资源的媒体类型）</strong></h3><p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/22.png" alt="0"></p>
<h3 id="default-type-用来配置Nginx响应前端请求默认的MIME类型"><a href="#default-type-用来配置Nginx响应前端请求默认的MIME类型" class="headerlink" title="default_type:用来配置Nginx响应前端请求默认的MIME类型"></a><strong>default_type:用来配置Nginx响应前端请求默认的MIME类型</strong></h3><p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/23.png" alt="0"></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/24.png" alt="0"></p>
<h3 id="自定义服务日志"><a href="#自定义服务日志" class="headerlink" title="自定义服务日志"></a><strong>自定义服务日志</strong></h3><p><strong>1、access_log:用来设置用户访问日志的相关属性</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/25.png" alt="0"></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/26.png" alt="0"></p>
<p><strong>2、log_format:用来指定日志的输出格式。</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/27.png" alt="0"></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/28.png" alt="0"></p>
<p><strong>3、sendfile:用来设置Nginx服务器是否使用sendfile()传输文件</strong></p>
<p><strong>该属性可以大大提高Nginx处理静态资源的性能</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/29.png" alt="0"></p>
<p><strong>4、keepalive_timeout:用来</strong> <strong>设置长连接的超时时间</strong></p>
<p>​    <img src="/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/30.png" alt="0"></p>
<p><strong>5、keepalive_requests:用来设置一个keep-alive</strong> <strong>连接使用的次数</strong></p>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>10-直接内存</title>
    <url>/2022/07/15/10-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p><strong>1、直接内存不是虚拟机运行时数据区的一部分，而是在Java堆外，直接向系统申请的内存空间</strong></p>
<p><img src="/2022/07/15/10-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/1.png"></p>
<p><img src="/2022/07/15/10-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/2.png"></p>
<p>2、来源于NIO，通过存在堆中的 <code>DirectByteBuffer</code> 操作本地内存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//1GB</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//直接分配本地内存空间</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line">    System.out.println(<span class="string">&quot;直接内存分配完毕&quot;</span>);</span><br><span class="line">    byteBuffer = <span class="literal">null</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;直接内存开始释放！&quot;</span>);</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、通常访问直接内存的速度会优于访问java堆的速度<strong>（读写性能更高，适用于读写频繁的场合）</strong></p>
<p><strong>4、java的NIO库运行java程序使用直接内存用于数据缓冲</strong></p>
<p>5、直接内存大小可以通过<code>MaxDirectMemorySize</code>设置，如果不指定，默认与堆的最大值<code>-Xmx</code>参数值一致，但是<strong>由于直接内存在java堆外，因此它不会直接受限于-Xmx指定的最大堆大小，它和java堆受限于操作系统能给出的最大内存</strong></p>
<p><strong>6、简单理解： <code>java process memory = java heap + native memory</code></strong></p>
<br>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>12-String相关</title>
    <url>/2022/07/16/12-String%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="String具有不可变性"><a href="#String具有不可变性" class="headerlink" title="String具有不可变性"></a><strong>String具有不可变性</strong></h1><p><em><strong>1）当对字符串进行重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</strong></em></p>
<p><em><strong>2）当对现有的字符串进行连接操作的时候，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></em></p>
<p><em><strong>3）当调用String的 replace() 方法修改指定字符或字符串的时候，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></em></p>
<p><strong>注意：String声明为final，不可被继承</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//字面量定义的方式，&quot;abc&quot;存储在字符串常量池中</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    System.out.println(s1 == s2)	<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//字面量定义的方式，&quot;abc&quot;存储在字符串常量池中</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    s1 = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    System.out.println(s1 == s2)	<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    s2 += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">    System.out.println(s2);<span class="comment">//abcdef</span></span><br><span class="line">    System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">    System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">    System.out.println(s2);<span class="comment">//mbc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/07/16/12-String%E7%9B%B8%E5%85%B3/1.png" style="zoom:80%;">

<img src="/2022/07/16/12-String%E7%9B%B8%E5%85%B3/2.png" style="zoom:70%;">

<br>

<h1 id="字符串常量池不会存储相同内容的字符串"><a href="#字符串常量池不会存储相同内容的字符串" class="headerlink" title="字符串常量池不会存储相同内容的字符串"></a>字符串常量池不会存储相同内容的字符串</h1><p><strong>1、String的String Pool是一个固定大小的 Hashtable</strong>，如果放进String Pool的String非常多，就会造成Hash冲突严重，导致链表会很长，而链表长了之后直接会造成的影响是当调用<code>String.intern</code>时性能会下降</p>
<p><strong>2、jdk6中StringTable的长度是固定的（1009），jdk7中StringTable的长度默认是60013，jdk8的可设置的最小值是1009。</strong>两个版本都可以**调整StringTable的值，使用 <code>-XX:StringTableSize</code> **</p>
<br>

<h1 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种：<br><strong>1、直接使用双引号声明出来的String对象会直接存储在常量池中（比如： <code>String info = “abc”</code> ）</strong><br><strong>2、也可以使用String提供的intern()方法手动将字符串加入常量池中</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;<span class="comment">//line 1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//line 2</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//line 3</span></span><br><span class="line">    <span class="type">Memory</span> <span class="variable">mem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Memory</span>();<span class="comment">//line 4</span></span><br><span class="line">    mem.foo(obj);<span class="comment">//line 5</span></span><br><span class="line">&#125;<span class="comment">//line 9</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Object param)</span> &#123;<span class="comment">//line 6</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> param.toString();<span class="comment">//line 7</span></span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;<span class="comment">//line 8</span></span><br></pre></td></tr></table></figure>

<img src="/2022/07/16/12-String%E7%9B%B8%E5%85%B3/3.png" style="zoom:70%;">

<br>

<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><em><strong>注意：</strong></em></h2><p><strong>完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量)</strong></p>
<p><strong>并且必须是指向同一个String类实例。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println();<span class="comment">//2293</span></span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);<span class="comment">//2294</span></span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;4&quot;</span>);System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;6&quot;</span>);System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;8&quot;</span>);System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;10&quot;</span>);<span class="comment">//2303</span></span><br><span class="line">    <span class="comment">//如下的字符串&quot;1&quot; 到 &quot;10&quot;不会再次加载</span></span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);<span class="comment">//2304</span></span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);<span class="comment">//2304</span></span><br><span class="line">    System.out.println(<span class="string">&quot;3&quot;</span>);System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;5&quot;</span>);System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;7&quot;</span>);System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;9&quot;</span>);<span class="comment">//2304</span></span><br><span class="line">    System.out.println(<span class="string">&quot;10&quot;</span>);<span class="comment">//2304</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h1><p>常量与常量的拼接结果在常量池，原理是编译器优化</p>
<p>常量池中不会存在相同内容的常量</p>
<p><strong style="color:red;">拼接中只有其中有一个是变量，拼接后的结果就在堆中。变量拼接的原理是StringBulider</strong></p>
<p>如果拼接的结果</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>11-执行引擎</title>
    <url>/2022/07/15/11-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>1、执行引擎是Java虚拟机的核心组成部分之一</p>
<p><strong>2、执行引擎的任务是将字节码指令解释&#x2F;编译为对应平台上的本地机器指令</strong> <em><strong>（其实执行引擎就是将高级语言翻译为机器语言）</strong></em></p>
<p><strong>3、执行引擎的工作过程</strong></p>
<ul>
<li><em><strong>输入的是字节码二进制流</strong></em></li>
<li><em><strong>处理过程是字节码解析执行的等效过程</strong></em></li>
<li><em><strong>输出是执行结果</strong></em></li>
</ul>
<img src="/2022/07/15/11-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/1.png" style="zoom:80%;">

<p>4、执行引擎在<strong>执行的过程中</strong>需要执行的<strong>字节码指令完全</strong> <strong>依赖于PC寄存器</strong></p>
<p>5、每当执行完一项指令操作后，PC寄存器就会<strong>更新下一条需要被执行的指令地址</strong></p>
<p><strong>6、在方法的执行过程中，执行引擎有可能会通过存储在局部变量表中的对象引用定位到存储在java堆中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息</strong></p>
<p><em><strong>7、执行引擎包括解释器，及时编译器，垃圾回收器</strong></em></p>
<br>

<h1 id="java代码编译和执行的过程"><a href="#java代码编译和执行的过程" class="headerlink" title="java代码编译和执行的过程"></a>java代码编译和执行的过程</h1><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图的各个步骤</p>
<img src="/2022/07/15/11-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/2.png" style="zoom:70%;">

<p><em><strong>解释器：</strong></em></p>
<p>​	当java虚拟机启动时会根据预定义的规范<strong>对字节码采用逐行解释的方式执行</strong></p>
<p>​	将<strong>字节码文件中的内容翻译为对应平台的本地机器指令执行</strong></p>
<p><em><strong>JIT编译器：</strong></em></p>
<p>​	虚拟机<strong>将源代码直接编译成和本地机器平台相关的机器语言</strong></p>
<img src="/2022/07/15/11-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/3.png" style="zoom:70%;">

<br>

<h1 id="机器码、指令、汇编语言"><a href="#机器码、指令、汇编语言" class="headerlink" title="机器码、指令、汇编语言"></a>机器码、指令、汇编语言</h1><h2 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h2><p><em><strong>各种用二进制编码方式表示的指令称为机器指令码（机器语言）</strong></em></p>
<p>编写的程序输入计算机，CPU直接读取运行，<em><strong>执行速度相比其他语言最快</strong></em>，而且机器指令和CPU密切相关，<em><strong>不同种类的CPU机器指令不同</strong></em></p>
<br>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>由于机器码是由0，1组成的二进制序列，为了<em><strong>增加可读性</strong></em>，将<em><strong>机器码中特定的0，1序列简化为对应的指令。</strong></em></p>
<p><em><strong>不同的硬件平台的同一种指令，对应的机器码也可能不同</strong></em></p>
<br>

<h2 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h2><p><em><strong>每个平台所支持的指令称为对应平台的指令集</strong></em></p>
<p>例如：</p>
<p>x86指令集 -&gt; 对应x86架构的平台</p>
<p>ARM指令集 -&gt; 对应ARM架构的平台</p>
<br>

<h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><p>使用助记符代替机器指令的操作码，用地址符号或标号替代指令或操作数的地址</p>
<br>

<h2 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h2><p>计算机执行高级语言编写的程序时，需要将程序解释和编译成机器的指令码。（这个过程称为解释程序或编译程序）</p>
<img src="/2022/07/15/11-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/4.png" style="zoom:70%;">

<br>

<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>1、字节码其实是一种<em><strong>中间状态（中间码）的二进制代码（文件）</strong></em>，它比机器码更抽象，需要<em><strong>直译器转译后才能称为机器码</strong></em></p>
<p><em><strong>2、字节码的实现方式是编译器和虚拟机器</strong></em>（编译器将源码翻译成字节码，特定平台上的虚拟机器将字节码转义为可以直接执行的指令）</p>
<p><em><strong>主要目的是为了实现跨平台性</strong></em></p>
<br>

<h1 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h1><p>1、利用解释器来逐行解析字节码文件，其实解释器的作用就是<em><strong>将字节码文件中的内容翻译为对应平台的本地机器指令执行</strong></em></p>
<p><em><strong>2、当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作</strong></em></p>
<h3 id="分类（-）"><a href="#分类（-）" class="headerlink" title="分类（*）"></a><strong>分类（*）</strong></h3><p>字节码解释器：执行时通过纯软件代码模拟字节码执行，效率低下</p>
<p>模板解释器：将每一条字节码和一个模板函数相关联，模板函数直接产生该字节码执行时的机器码，效率较高</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><em><strong>注意：</strong></em></h3><p><em><strong>1、无论是哪种解释器，效率还是比即时编译器低的</strong></em></p>
<p><em><strong>2、解释器存在的必要性：程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。</strong></em>当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。在一定时间过后，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p>
<br>

<h1 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h1><p>前端编译器：将 .java 文件转变成 .class 文件的过程</p>
<p>后端编译器（JIT编译器）：将字节码转变成机器码的过程</p>
<p>静态提前编译器（AOT编译器）：直接将 .java 文件编译成本地机器代码的过程</p>
<br>

<h2 id="热点代码及探测方式"><a href="#热点代码及探测方式" class="headerlink" title="热点代码及探测方式"></a>热点代码及探测方式</h2><p><em><strong>1、决定是否启用 JIT 编译器需要根据代码被调用执行的频率而定。</strong></em>关于<em><strong>需要被编译为本地代码的字节码，称为”热点代码“</strong></em></p>
<p>2、JIT 编译器运行时会针对那些频繁被调用的热点代码做深度优化，将其直接编译为对应平台的本地机器指令，提高执行性能</p>
<h3 id="热点代码："><a href="#热点代码：" class="headerlink" title="热点代码："></a><strong>热点代码：</strong></h3><p><em><strong>一个多次调用的方法或者方法体内循环次数较多的循环体都可以称为热点代码（这种编译方式由于发生在方法的执行过程中，因此也被称为栈上替换，OSR）</strong></em></p>
<br>

<h3 id="基于计数器的热点探测"><a href="#基于计数器的热点探测" class="headerlink" title="基于计数器的热点探测"></a>基于计数器的热点探测</h3><p><strong>判断一个方法被调用多少次，或循环体循环多少次才能称为热点代码的标准</strong></p>
<p>HotSpot虚拟机<strong>为每个方法都创建</strong>两个不同类型的计数器</p>
<h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><p>统计方法的调用次数，可以通过参数 <code>-XX:CompileThreshold</code>进行设定，Client默认是1500次，Server默认是10000次，超过阈值，触发 JIT 编译</p>
<img src="/2022/07/15/11-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/5.png" style="zoom:70%;">
<br>

<p><em><strong>热度衰减</strong></em></p>
<p><strong>方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率</strong> <strong>（一段时间内方法的执行频率）</strong>当超过一定限度时，如果方法的调用次数不足让它提交给即时编译器，那么这个方法的调用计数器就会<strong>减少一半</strong>，这个<strong>过程称为调用计数器热度的衰减</strong>，<strong>这段时间就称为该方法统计的半衰周期</strong></p>
<p>关闭热度衰减：<code>-XX:UseCounterDecay</code></p>
<p>设置半衰期的时间：<code>-XX:CounterHalfLifeTime</code>（单位为s）</p>
<br>


<h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>统计循环体的循环次数</p>
<img src="/2022/07/15/11-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/6.png" style="zoom:70%;">

<br>

<h2 id="设置程序执行方式"><a href="#设置程序执行方式" class="headerlink" title="设置程序执行方式"></a>设置程序执行方式</h2><p><code>-Xint</code>：完全采用解释器模式执行程序</p>
<p><code>-Xcomp</code>：完全采用即时编译器（如果即时编译器出现问题，解释器会介入执行）</p>
<p><code>-Xmixed</code>：采用解释器+即时编译器的混合模式</p>
<br>

<h2 id="JIT分类"><a href="#JIT分类" class="headerlink" title="JIT分类"></a>JIT分类</h2><p><strong>Client Compiler和Server Compiler（简称为C1和C2）</strong></p>
<h3 id="C1"><a href="#C1" class="headerlink" title="C1"></a>C1</h3><p><code>-client</code>：指定运行在Client模式下，C1会对字节码进行简单可靠的优化，耗时短</p>
<h3 id="C2"><a href="#C2" class="headerlink" title="C2"></a>C2</h3><p><code>-server</code>：指定运行在Server模式下，C2进行耗时较长的优化以及激进优化，但优化的代码执行效率更高</p>
<h3 id="C1和C2的优化策略（-）"><a href="#C1和C2的优化策略（-）" class="headerlink" title="C1和C2的优化策略（*）"></a>C1和C2的优化策略（*）</h3><img src="/2022/07/15/11-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/7.png" style="zoom:90%;">



<h1 id="Graal编译器与AOT编译器（-）"><a href="#Graal编译器与AOT编译器（-）" class="headerlink" title="Graal编译器与AOT编译器（*）"></a>Graal编译器与AOT编译器（*）</h1><img src="/2022/07/15/11-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/8.png" style="zoom:90%;">
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>2-1-算法时间复杂度分析</title>
    <url>/2022/07/12/2-1-%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><strong>最高次项的指数大的，随着n的增长，结果也会变得增长特别快</strong></p>
<p><strong>算法函数中n最高次幂越小，算法效率越高</strong></p>
<p>1.算法函数中的常数可以忽略； </p>
<p>2.算法函数中最高次幂的常数因子可以忽略； </p>
<p>3.算法函数中最高次幂越小，算法效率越高。</p>
<h2 id="大O记法"><a href="#大O记法" class="headerlink" title="大O记法"></a><strong>大O记法</strong></h2><p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随着n的变化情况并确定T(n)的 量级。算法的时间复杂度，就是算法的时间量度，记作:T(n)&#x3D;O(f(n))。</p>
<p><strong>它表示随着问题规模n的增大，算法执行时间 的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度，其中f(n)是问题规模n的某个函数。</strong></p>
<p><strong>执行次数&#x3D;执行时间</strong></p>
<h3 id="算法一："><a href="#算法一：" class="headerlink" title="算法一："></a>算法一：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//执行1次</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n=<span class="number">100</span>;<span class="comment">//执行1次</span></span><br><span class="line"></span><br><span class="line">    sum = (n+<span class="number">1</span>)*n/<span class="number">2</span>;<span class="comment">//执行1次</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;sum=&quot;</span>+sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法二："><a href="#算法二：" class="headerlink" title="算法二："></a>算法二：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//执行1次</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n=<span class="number">100</span>;<span class="comment">//执行1次</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">    	sum += i;<span class="comment">//执行了n次</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;sum=&quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法三："><a href="#算法三：" class="headerlink" title="算法三："></a>算法三：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;<span class="comment">//执行1次</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n=<span class="number">100</span>;<span class="comment">//执行1次</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=n ; i++) &#123;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=n ; j++) &#123;</span><br><span class="line"></span><br><span class="line">     	sum+=i;<span class="comment">//执行n^2次</span></span><br><span class="line"></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;sum=&quot;</span>+sum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**算法一：3次 **</p>
<p>**算法二：n+3次 **</p>
<p><strong>算法三：n^2+2次</strong></p>
<h3 id="推导大O阶-的表示法"><a href="#推导大O阶-的表示法" class="headerlink" title="推导大O阶 的表示法"></a><strong>推导大O阶</strong> 的表示法</h3><p>以下几个规则可以使用： </p>
<p>**1.用常数1取代运行时间中的所有加法常数； **</p>
<p><strong>2.在修改后的运行次数中，只保留高阶项；</strong></p>
<p><strong>3.如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数；</strong></p>
<p>所以，上述算法的大O记法分别为： </p>
<p>​	算法一：O(1) </p>
<p>​	算法二：O(n) </p>
<p>​	算法三：O(n^2)</p>
<h2 id="常见的大O阶"><a href="#常见的大O阶" class="headerlink" title="常见的大O阶"></a><strong>常见的大O阶</strong></h2><h3 id="1-线性阶"><a href="#1-线性阶" class="headerlink" title="1.线性阶"></a>1.线性阶</h3><p>一般含有非嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//执行1次</span></span><br><span class="line">    <span class="type">int</span> n=<span class="number">100</span>;<span class="comment">//执行1次</span></span><br><span class="line">    sum = (n+<span class="number">1</span>)*n/<span class="number">2</span>;<span class="comment">//执行1次</span></span><br><span class="line">    System.out.println(<span class="string">&quot;sum=&quot;</span>+sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上面这段代码，它的循环的时间复杂度为O(n)</strong>,因为循环体中的代码需要执行n次</p>
<h3 id="2-平方阶"><a href="#2-平方阶" class="headerlink" title="2.平方阶"></a>2.平方阶</h3><p>一般嵌套循环属于这种时间复杂度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>,n=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=n ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=n ; j++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码，n&#x3D;100，也就是说，外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环 中出来，就需要执行100<em>100次，也就是n的平方次，所以*<em>这段代码的时间复杂度是O(n^2).</em></em></p>
<h3 id="3-立方阶"><a href="#3-立方阶" class="headerlink" title="3.立方阶"></a>3.立方阶</h3><p>一般三层嵌套循环属于这种时间复杂度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt;= n; j++) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码，n&#x3D;100，也就是说，外层循环每执行一次，中间循环循环就执行100次，中间循环每执行一次，最 内层循环需要执行100次，那总共程序想要从这三个循环中出来，就需要执行100100100次，也就是n的立方，所 以<strong>这段代码的时间复杂度是O(n^3).</strong></p>
<h3 id="4-对数阶"><a href="#4-对数阶" class="headerlink" title="4.对数阶"></a>4.对数阶</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>,n=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">    i = i * <span class="number">2</span>; 	   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于每次i<em>2之后，就距离n更近一步，假设有x个2相乘后大于n，则会退出循环。由于是2^x&#x3D;n,得到x&#x3D;log(2)n,所 以*<em>这个循环的时间复杂度为O(logn);</em></em> 对于对数阶，<strong>由于随着输入规模n的增大，不管底数为多少，他们的增长趋势是一样的，所以我们会忽略底数。</strong></p>
<h3 id="5-常数阶"><a href="#5-常数阶" class="headerlink" title="5.常数阶"></a>5.常数阶</h3><p>一般不涉及循环操作的都是常数阶，因为它不会随着n的增长而增加操作次数。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> i=n+<span class="number">2</span>;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码，不管输入规模n是多少，都执行2次，根据大O推导法则，常数用1来替换，所以<strong>上述代码的时间复杂度为O(1)</strong></p>
<p>​    <img src="/2022/07/12/2-1-%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/1.png" alt="0"></p>
<p>他们的复杂程度从低到高依次为：</p>
<p>​    <img src="/2022/07/12/2-1-%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.png" alt="0"></p>
<p>所以，我们的算法，尽可能的<strong>追求的是O(1),O(logn),O(n),O(nlogn)这几种时间复杂度</strong>，而如果发现算法的时间复杂度为平方阶、 立方阶或者更复杂的，那我们可以分为这种算法是不可取的，需要优化。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>2-2-函数调用时间复杂度分析</title>
    <url>/2022/07/12/2-2-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="案例一："><a href="#案例一：" class="headerlink" title="案例一："></a><strong>案例一：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        show(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>show方法的时间复杂度为O(1),main方法的时间复杂度是O(n)</strong></p>
<h2 id="案例二："><a href="#案例二：" class="headerlink" title="案例二："></a><strong>案例二：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        show(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; i++) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main方法中，有一个for循环，循环体调用了show方法，由于show方法内部也有一个for循环</p>
<p><strong>所以show方法 的时间复杂度为O(n)，main方法的时间复杂度为O(n^2)</strong></p>
<h2 id="案例三："><a href="#案例三：" class="headerlink" title="案例三："></a><strong>案例三：</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">100</span>;</span><br><span class="line">    show(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        show(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; i++) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在show方法中，有一个for循环，所以show方法的时间复杂度为O(n),在main方法中，show(n)这行代码内部执行 的次数为n，第一个for循环内调用了show方法，所以其执行次数为n^2,第二个嵌套for循环内只执行了一行代码，</p>
<p>所以其执行次数为n^2,那么<strong>main方法总执行次数为n+n^2+n^2&#x3D;2n^2+n</strong>。</p>
<p>根据大O推导规则，去掉n保留最高阶 项，并去掉最高阶项的常数因子2，所以<strong>最终main方法的时间复杂度为O(n^2)</strong></p>
<h2 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a><strong>最坏情况</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr=&#123;<span class="number">11</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num==arr[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最好情况：</strong> 查找的第一个数字就是期望的数字，那么算法的时间复杂度为O(1) </p>
<p><strong>最坏情况：</strong> 查找的最后一个数字，才是期望的数字，那么算法的时间复杂度为O(n) </p>
<p><strong>平均情况：</strong> 任何数字查找的平均成本是O(n&#x2F;2) <strong>最坏情况是一种保证，在应用中，这是一种最基本的保障，即使在最坏情况下，也能够正常提供服务，所以，除非 特别指定，</strong> <strong>我们提到的运行时间都指的是最坏情况下的运行时间。</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>2-3-算法的空间复杂度分析</title>
    <url>/2022/07/12/2-3-%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="一、java中常见内存占用"><a href="#一、java中常见内存占用" class="headerlink" title="一、java中常见内存占用"></a>一、java中常见内存占用</h2><p>1.基本数据类型内存占用情况：</p>
<p>​    <img src="/2022/07/12/2-3-%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/1.png" alt="0"></p>
<p>2.计算机访问内存的方式都是一次一个字节</p>
<p>3.一个引用（机器地址）需要8个字节表示：</p>
<p>例如： Date date &#x3D; new Date(),则date这个变量需要占用8个字节来表示</p>
<p>4.创建一个对象，比如new Date()，除了Date对象内部存储的数据(例如年月日等信息)占用的内存，该对象本身也 有内存开销，每个对象的自身开销是16个字节，用来保存对象的头信息。 </p>
<p>5.一般内存的使用，如果不够8个字节，都会被自动填充为8字节</p>
<p>6.java中数组被被限定为对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要<strong>24字节的头信息</strong></p>
<p>(16个自己的对象开销，4字节用于保存长度以及4个填充字节)再加上保存值所需的内存。</p>
<h2 id="二、算法的空间复杂度"><a href="#二、算法的空间复杂度" class="headerlink" title="二、算法的空间复杂度"></a><strong>二、算法的空间复杂度</strong></h2><p>算法的空间复杂度计算公式记作：S(n)&#x3D;O(f(n)),其中n为输入规模，f(n)为语句关于n所占存储空间的函数。</p>
<p>案例： 对指定的数组元素进行反转，并返回反转的内容。</p>
<p>​    <img src="/2022/07/12/2-3-%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.png" alt="0"></p>
<p>​    <img src="/2022/07/12/2-3-%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/3.png" alt="0"></p>
<p>根据大O推导法则，算法一的空间复杂度为O(1)</p>
<p>算法二的空间复杂度为O(n)</p>
<p>所以从空间占用的角度讲，算法一要优于算法二。</p>
<p>由于java中有内存垃圾回收机制，并且jvm对程序的内存占用也有优化（例如即时编译），我们无法精确的评估一 个java程序的内存占用情况，但是了解了java的基本内存占用，使我们可以对java程序的内存占用情况进行估算。 由于现在的计算机设备内存一般都比较大，基本上个人计算机都是4G起步，大的可以达到32G</p>
<p>所以<strong>内存占用一般 情况下并不是我们算法的瓶颈，普通情况下直接说复杂度，默认为算法的时间复杂度。</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>2-nginx-配置到系统服务和系统环境</title>
    <url>/2022/07/13/2-nginx-%E9%85%8D%E7%BD%AE%E5%88%B0%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="一、将nginx配置到系统服务"><a href="#一、将nginx配置到系统服务" class="headerlink" title="一、将nginx配置到系统服务"></a><strong>一、将nginx配置到系统服务</strong></h1><p><strong>1、在   <code>/usr/lib/systemd/system</code>   目录下添加nginx.service,内容如下</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx web service</span><br><span class="line">Documentation=http://nginx.org/en/docs/</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/usr/local/nginx/logs/nginx.pid</span><br><span class="line">ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx</span><br><span class="line">ExecReload=/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure>

<p><strong>2、添加完成后如果权限有问题需要进行权限设置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 755 /usr/lib/systemd/system/nginx.service</span><br></pre></td></tr></table></figure>

<p><strong>3、使用系统命令来操作Nginx服务</strong></p>
<p><img src="/2022/07/13/2-nginx-%E9%85%8D%E7%BD%AE%E5%88%B0%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83/1.png"></p>
<h1 id="二、将nginx命令配置到系统环境"><a href="#二、将nginx命令配置到系统环境" class="headerlink" title="二、将nginx命令配置到系统环境"></a><strong>二、将nginx命令配置到系统环境</strong></h1><p><strong>1、修改</strong> <code>/etc/profile</code> <strong>文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line">在最后一行添加</span><br><span class="line">export PATH=$PATH:/usr/local/nginx/sbin</span><br></pre></td></tr></table></figure>

<p><strong>2、使配置立即生效</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>3-1-冒泡排序</title>
    <url>/2022/07/12/3-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>排序原理：</strong> </p>
<p><strong>1. 比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。</strong></p>
<p><strong>2. 对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值。</strong></p>
<p><img src="/2022/07/12/3-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/1.png"></p>
<p>**初始状态到第一次冒泡 : **</p>
<ol>
<li>比较 4,5，5比4大，不变。</li>
<li>比较5,6，6比5大，不变</li>
<li>比较6,3，3比6小，交换二者位置    4,5,3,6,2,1</li>
<li>比较6,2，2比6小，交换二者位置    4,5,3,2,6,1</li>
<li>比较6,1，1比6小，交换二者位置    4,5,3,2,1,6</li>
</ol>
<p>假设数组长度为n，冒泡排序必须实现n-1次冒泡（令k &#x3D; n）</p>
<p>第一次冒泡要有k-1次比较</p>
<p>第二次冒泡要有k-2次比较</p>
<p>第n-1次冒泡要有k-n-1次比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length-<span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (greater(a[j],a[j+<span class="number">1</span>]))&#123;</span><br><span class="line">                exch(a,j,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用两个for循环进行遍历，第一个for循环表示冒泡的次数为：数组长度-1</strong></p>
<p><strong>第二个for循环表示相邻数组元素依次比较，j &lt; i 表示排序完的元素放在数组的后面，不需要再次进行排序</strong></p>
<p><img src="/2022/07/12/3-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/2.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> SORT;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hzy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022/1/14</span></span><br><span class="line"><span class="comment"> * 10:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//    1.public static void sort(Comparable[] a)：对数组内的元素进行排序</span></span><br><span class="line"><span class="comment">//    2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w</span></span><br><span class="line"><span class="comment">//    3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bubble</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组内的元素进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length-<span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (greater(a[j],a[j+<span class="number">1</span>]))&#123;</span><br><span class="line">                    exch(a,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断v是否大于w</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v,Comparable w)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> v.compareTo(w);</span><br><span class="line">        <span class="keyword">if</span> (result&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        return result&gt;0;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换a数组中，索引i和索引j处的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Comparable temp;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>冒泡排序的时间复杂度分析 冒泡排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码</strong></p>
<p>**所以， 分析冒泡排序的时间复杂度，主要分析一下内层循环体的执行次数即可。 **</p>
<p>在最坏情况下，也就是假如要排序的元素为{6,5,4,3,2,1}逆序，</p>
<p>那么： 元素比较的次数为： (N-1)+(N-2)+(N-3)+…+2+1&#x3D;((N-1)+1)*(N-1)&#x2F;2&#x3D;N^2&#x2F;2-N&#x2F;2; </p>
<p>元素交换的次数为： (N-1)+(N-2)+(N-3)+…+2+1&#x3D;((N-1)+1)*(N-1)&#x2F;2&#x3D;N^2&#x2F;2-N&#x2F;2;</p>
<p>总执行次数为： (N^2&#x2F;2-N&#x2F;2)+(N^2&#x2F;2-N&#x2F;2)&#x3D;N^2-N;</p>
<p>按照大O推导法则，保留函数中的最高阶项那么<strong>最终冒泡排序的时间复杂度为O(N^2)</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>3-2-选择排序</title>
    <url>/2022/07/12/3-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>排序原理：</strong></p>
<p><strong>1.每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较</strong></p>
<p>​	**如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引 **</p>
<p><strong>2.交换第一个索引处和最小值所在的索引处的值</strong></p>
<p>​    <img src="/2022/07/12/3-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/1.png" alt="0"></p>
<p>原始数据到第一趟排序：假定4是最小值，让4分别与数据的其他7位元素进行比较，如果有比4小的数，交换二者位置让那个数成为最小值放在第一位，然后继续比较，直到到了元素的最后一位</p>
<p>第六趟到第7趟排序：假定8是最小值，与后面的10，9进行比较，如果有比4小的数，交换二者位置让那个数成为最小值放在第一位，然后继续比较，直到到了元素的最后一位</p>
<p>​    <img src="/2022/07/12/3-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/2.png" alt="0"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//定义一个变量，记录最小元素所在的索引，默认为参与选择排序的第一个元素所在的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">            <span class="comment">//需要比较最小索引min处的值和j索引处的值</span></span><br><span class="line">            <span class="keyword">if</span> (greater(a[min],a[j]))&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换最小元素所在的索引min处的值和j索引处的值</span></span><br><span class="line">        exch(a, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">greater</span><span class="params">(Comparable v,Comparable w)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    Comparable temp;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设数组长度为n</p>
<p>最开始，将数组的第一个元素作为最小值所在的索引，定义为min</p>
<p>用两个for循环进行嵌套，第一个for循环表示，需要进行n-1趟排序</p>
<p>第二个for循环为了比较最小索引的值min 与 后面元素的索引值。</p>
<p>如果存在比最小索引min的值小的元素，则交换min与该元素的索引，使其成为最小值的索引</p>
<p><strong>注意：</strong></p>
<p><strong>第二个for循环中定义 j &#x3D; i + 1 是为了在排好顺序的元素的后一位才开始进行比较</strong></p>
<p><strong>而且 j 不能越界访问，所以 j 要小于数组的长度</strong></p>
<p><strong>选择排序的时间复杂度分析：</strong></p>
<p>选择排序使用了双层for循环，其中外层循环完成了数据交换，内层循环完成了数据比较，</p>
<p>分别统计数据 交换次数和数据比较次数： </p>
<p>数据比较次数： (N-1)+(N-2)+(N-3)+…+2+1&#x3D;((N-1)+1)*(N-1)&#x2F;2&#x3D;N^2&#x2F;2-N&#x2F;2;</p>
<p>数据交换次数： N-1 时间复杂度：N^2&#x2F;2-N&#x2F;2+（N-1）&#x3D;N^2&#x2F;2+N&#x2F;2-1; 根据大O推导法则，保留最高阶项，去除常数因子，<strong>时间复杂度为O(N^2);</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>3-nginx-静态资源部署</title>
    <url>/2022/07/13/3-nginx-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="静态资源的配置指令"><a href="#静态资源的配置指令" class="headerlink" title="静态资源的配置指令"></a><strong>静态资源的配置指令</strong></h1><h2 id="listen指令：-用来配置监听端口"><a href="#listen指令：-用来配置监听端口" class="headerlink" title="listen指令： 用来配置监听端口"></a><strong>listen指令：</strong> <strong>用来配置监听端口</strong></h2><p><img src="/2022/07/13/3-nginx-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2/1.png"></p>
<p><img src="/2022/07/13/3-nginx-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2/2.png"></p>
<p><strong>default_server属性是标识符，用来将此虚拟主机设置成默认主机</strong></p>
<p><strong>所谓的默认主机指的是如果没有匹配到对应的address:port，则会默认执行的。</strong> 如果不指定默认使用的是第一个server</p>
<p><img src="/2022/07/13/3-nginx-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2/3.png"></p>
<br>

<h2 id="server-name指令："><a href="#server-name指令：" class="headerlink" title="server_name指令："></a><strong>server_name指令：</strong></h2><p><strong>用来设置虚拟主机服务名称</strong></p>
<p><img src="/2022/07/13/3-nginx-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2/4.png"></p>
<p><strong>三种匹配方式：精确匹配、通配符匹配、正则表达式匹配</strong></p>
<br>

<h3 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a><strong>精确匹配</strong></h3><p><img src="/2022/07/13/3-nginx-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2/5.png"></p>
<p>域名是要收取一定的费用，所以可以使用修改hosts文件来制作一些虚拟域名来使用。需要修改 <code>/etc/hosts</code> 文件来添加</p>
<p><img src="/2022/07/13/3-nginx-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2/6.png"></p>
<br>

<h3 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a><strong>通配符匹配</strong></h3><p><strong>server_name中支持通配符”*“,但需要注意的是通配符不能出现在域名的中间，只能出现在首段或尾段</strong></p>
<p><strong>(*)代表任意字符</strong></p>
<p><img src="/2022/07/13/3-nginx-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2/7.png"></p>
<p><img src="/2022/07/13/3-nginx-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2/8.png"></p>
<br>

<h3 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a><strong>正则表达式匹配</strong></h3><p><strong>server_name中可以使用正则表达式，并且使用 ~ 作为正则表达式字符串的开始标记</strong></p>
<p><img src="/2022/07/13/3-nginx-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2/9.png"></p>
<p>括号取值</p>
<p><img src="/2022/07/13/3-nginx-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2/10.png"></p>
<p><img src="/2022/07/13/3-nginx-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2/11.png"></p>
<br>

<h3 id="匹配执行顺序"><a href="#匹配执行顺序" class="headerlink" title="匹配执行顺序"></a><strong>匹配执行顺序</strong></h3><p><em><strong>1、准确匹配</strong></em></p>
<p><em><strong>2、通配符在开始时匹配</strong></em></p>
<p><em><strong>3、通配符在结束时匹配</strong></em></p>
<p><em><strong>4、正则表达式匹配</strong></em></p>
<p><em><strong>5、被默认的default_server处理，如果没有指定默认找第一个server</strong></em></p>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>ComponentScan的模拟实现</title>
    <url>/2022/07/15/ComponentScan%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟 @ComponentScan 注解的解析</span></span><br><span class="line"><span class="comment">//1、让自定义类实现 BeanDefinitionRegistryPostProcessor 接口，并重写 postProcessBeanFactory 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentScanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// context.refresh</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2、使用 AnnotationUtils 工具类从Config类中找到 @ComponentScan 注解对象</span></span><br><span class="line">            <span class="type">ComponentScan</span> <span class="variable">componentScan</span> <span class="operator">=</span> AnnotationUtils.findAnnotation(Config.class, ComponentScan.class);</span><br><span class="line">            <span class="keyword">if</span> (componentScan != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//3、不为空，获取包名（包名转换为classpath下的资源路径）</span></span><br><span class="line">                <span class="comment">//com.itheima.a05.component -&gt; classpath*:com/itheima/a05/component/**/*.class</span></span><br><span class="line">                <span class="keyword">for</span> (String p : componentScan.basePackages()) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;classpath*:&quot;</span> + p.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;/**/*.class&quot;</span>;</span><br><span class="line">                    <span class="comment">//4、读取类的元信息</span></span><br><span class="line">                    <span class="type">CachingMetadataReaderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">                    Resource[] resources = <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>().getResources(path);</span><br><span class="line">                    <span class="type">AnnotationBeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line">                    <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                        <span class="type">MetadataReader</span> <span class="variable">reader</span> <span class="operator">=</span> factory.getMetadataReader(resource);</span><br><span class="line">                        <span class="comment">//5、判断是否间接或者直接加了@Component注解</span></span><br><span class="line">                        <span class="keyword">if</span> (reader.getAnnotationMetadata().hasMetaAnnotation(Component.class.getName())</span><br><span class="line">                                || reader.getAnnotationMetadata().hasAnnotation(Component.class.getName())) &#123;</span><br><span class="line">                            <span class="comment">//6、创建一个BeanDefinition</span></span><br><span class="line">                            <span class="type">AbstractBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> BeanDefinitionBuilder</span><br><span class="line">                                .genericBeanDefinition(reader.getClassMetadata().getClassName())</span><br><span class="line">                                .getBeanDefinition();</span><br><span class="line">                            <span class="keyword">if</span> (configurableListableBeanFactory <span class="keyword">instanceof</span> </span><br><span class="line">                                DefaultListableBeanFactory beanFactory) &#123;</span><br><span class="line">                                <span class="comment">//7、将BeanDefinition加入到Bean工厂</span></span><br><span class="line">                                <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> generator.generateBeanName(bd, beanFactory);</span><br><span class="line">                                beanFactory.registerBeanDefinition(beanName,bd);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>当其他类使用时，只需要调用 context的 registerBean方法，并传入自定义类的.class即可</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">context.registerBean(ComponentScanPostProcessor.class);</span><br><span class="line"><span class="comment">//初始化容器</span></span><br><span class="line">context.refresh();</span><br><span class="line"><span class="comment">//for (String name : context.getBeanDefinitionNames()) &#123;</span></span><br><span class="line"><span class="comment">//    System.out.println(name);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//销毁容器</span></span><br><span class="line">context.close();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>spring高级</category>
      </categories>
      <tags>
        <tag>底层源码</tag>
        <tag>spring高级</tag>
      </tags>
  </entry>
  <entry>
    <title>spring源码-1-BeanFactory与ApplicationContext</title>
    <url>/2022/07/15/spring%E6%BA%90%E7%A0%81-1-BeanFactory%E4%B8%8EApplicationContext/</url>
    <content><![CDATA[<h1 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h1><p>1、它是ApplicationContext的父接口</p>
<p>2、它才是Spring的核心容器，主要的ApplicationContext的实现都组合了它的功能</p>
<img src="/2022/07/15/spring%E6%BA%90%E7%A0%81-1-BeanFactory%E4%B8%8EApplicationContext/1.png" style="zoom:80%;">

<p>比如使用ApplicationContext的getBean方法，实际上先拿到BeanFactory对象，再去调用BeanFactory的getBean方法</p>
<img src="/2022/07/15/spring%E6%BA%90%E7%A0%81-1-BeanFactory%E4%B8%8EApplicationContext/2.png" style="zoom:80%;">

<p><strong>3、BeanFactory表面上只有getBean功能实际上，控制反转，基本的依赖注入，直至Bean的生命周期都是由它的实现类提供</strong></p>
<br>

<h1 id="ApplicationContext功能"><a href="#ApplicationContext功能" class="headerlink" title="ApplicationContext功能"></a>ApplicationContext功能</h1><img src="/2022/07/15/spring%E6%BA%90%E7%A0%81-1-BeanFactory%E4%B8%8EApplicationContext/3.png" style="zoom:80%;">

<p><strong>1、MessageSource：处理国际化资源的能力（翻译）</strong> <em><strong>比如 getMessage方法</strong></em></p>
<p><img src="/2022/07/15/spring%E6%BA%90%E7%A0%81-1-BeanFactory%E4%B8%8EApplicationContext/5.png" style="zoom:80%;"><img src="/2022/07/15/spring%E6%BA%90%E7%A0%81-1-BeanFactory%E4%B8%8EApplicationContext/4.png" style="zoom:80%;"></p>
<br>

<p><strong>2、RessourcePatternResolver：通配符匹配资源的能力</strong> <em><strong>比如 getResources方法</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示在resources目录下的META-INF子目录下的spring.factories文件和jar包内的......</span></span><br><span class="line"><span class="comment">//*号表示也可以jar内进行搜索</span></span><br><span class="line">Resource[] resources = context.getResources(<span class="string">&quot;classpath*:META-INF/spring.factories&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">    System.out.println(resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p><strong>3、ApplicationEventPublisher：发布事件能力</strong> <em><strong>比如 publishEvent方法</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Component1然后进行注册</span></span><br><span class="line">context.getBean(Component1.class).register();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Component1中进行声明</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(Component1.class);</span><br><span class="line"><span class="comment">//该容器对象具备发送事件的功能</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ApplicationEventPublisher context;	<span class="comment">//事件发生器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;用户注册&quot;</span>);</span><br><span class="line">    context.publishEvent(<span class="keyword">new</span> <span class="title class_">UserRegisteredEvent</span>(<span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Component2中监听该事件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(Component2.class);</span><br><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aaa</span><span class="params">(UserRegisteredEvent event)</span> &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, event);</span><br><span class="line">    log.debug(<span class="string">&quot;发送短信&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>4、EnvironmentCapable：读取环境信息</strong> <em><strong>比如getProperty方法</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取properties文件和系统环境变量对应键的值</span></span><br><span class="line">System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;java_home&quot;</span>));</span><br><span class="line">System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;server.port&quot;</span>));</span><br></pre></td></tr></table></figure>

<br>

<h1 id="BeanFactory的实现"><a href="#BeanFactory的实现" class="headerlink" title="BeanFactory的实现"></a>BeanFactory的实现</h1><h2 id="1、给Bean添加定义并进行注册"><a href="#1、给Bean添加定义并进行注册" class="headerlink" title="1、给Bean添加定义并进行注册"></a><em><strong>1、给Bean添加定义并进行注册</strong></em></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line"><span class="comment">// bean 的定义（class, scope, 初始化, 销毁）</span></span><br><span class="line"><span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span></span><br><span class="line">        BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope(<span class="string">&quot;singleton&quot;</span>).getBeanDefinition();</span><br><span class="line"><span class="comment">//注册</span></span><br><span class="line">beanFactory.registerBeanDefinition(<span class="string">&quot;config&quot;</span>, beanDefinition);</span><br></pre></td></tr></table></figure>

<br>

<h2 id="2、添加-BeanFactory-后处理器"><a href="#2、添加-BeanFactory-后处理器" class="headerlink" title="2、添加 BeanFactory 后处理器"></a><em><strong>2、添加 BeanFactory 后处理器</strong></em></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给 BeanFactory 添加一些常用的后处理器</span></span><br><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果只是添加后处理器不进行扩展，则无法解析@Confident和@bean注解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanFactory 后处理器主要功能，补充了一些 bean 定义</span></span><br><span class="line"><span class="comment">// getBeansOfType 根据类型获取多个bean（bean后处理器）</span></span><br><span class="line">beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values().forEach(beanFactoryPostProcessor -&gt; &#123;</span><br><span class="line">    beanFactoryPostProcessor.postProcessBeanFactory(beanFactory);   <span class="comment">//执行beanFactory 后处理器</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();&#125;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();&#125;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean3 <span class="title function_">bean3</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean3</span>();&#125;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean4 <span class="title function_">bean4</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean4</span>();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Inter</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean4</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(Bean1.class);</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Bean1</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;构造 Bean1()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line">        <span class="keyword">public</span> Bean2 <span class="title function_">getBean2</span><span class="params">()</span> &#123;<span class="keyword">return</span> bean2;&#125;</span><br><span class="line">        <span class="comment">//同时添加两个注解（后处理器的顺序决定了哪个先被解析）</span></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="meta">@Resource(name = &quot;bean4&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> Inter bean3;</span><br><span class="line">        <span class="keyword">public</span> Inter <span class="title function_">getInter</span><span class="params">()</span> &#123;<span class="keyword">return</span> bean3;&#125;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(Bean2.class);</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Bean2</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;构造 Bean2()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="3、添加-Bean-后处理器"><a href="#3、添加-Bean-后处理器" class="headerlink" title="3、添加 Bean 后处理器"></a><em><strong>3、添加 Bean 后处理器</strong></em></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bean 后处理器, 针对 bean 的生命周期的各个阶段提供扩展, 例如 @Autowired @Resource ...</span></span><br><span class="line">beanFactory.getBeansOfType(BeanPostProcessor.class).values().stream()</span><br><span class="line">        .forEach(beanPostProcessor -&gt; &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(beanPostProcessor);    <span class="comment">//建立Bean工厂和后处理器的关系</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<br>

<h2 id="4、后处理器器顺序"><a href="#4、后处理器器顺序" class="headerlink" title="4、后处理器器顺序"></a><em><strong>4、后处理器器顺序</strong></em></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认是Common的后处理器排在前面，Autowired的排在后面</span></span><br><span class="line">System.out.println(<span class="string">&quot;Common:&quot;</span> + (Ordered.LOWEST_PRECEDENCE - <span class="number">3</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;Autowired:&quot;</span> + (Ordered.LOWEST_PRECEDENCE - <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<br>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><em><strong>BeanFactory总结：</strong></em></p>
<ol>
<li>不会主动调用 BeanFactory 后处理器</li>
<li>不会主动添加 Bean 后处理器</li>
<li>不会主动初始化单例</li>
<li>不会解析beanFactory 还不会解析 ${ } 与 #{ }</li>
</ol>
<p><em><strong>Bean后处理器会有排序的逻辑</strong></em></p>
<br>

<h1 id="ApplicationContext的实现"><a href="#ApplicationContext的实现" class="headerlink" title="ApplicationContext的实现"></a>ApplicationContext的实现</h1><h2 id="1、ClassPathXmlApplicationContext"><a href="#1、ClassPathXmlApplicationContext" class="headerlink" title="1、ClassPathXmlApplicationContext"></a>1、ClassPathXmlApplicationContext</h2><p><strong>在类路径下读取XML配置文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testClassPathXmlApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;a02.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line">    <span class="comment">/**	</span></span><br><span class="line"><span class="comment">     *  结果：</span></span><br><span class="line"><span class="comment">     *	bean1</span></span><br><span class="line"><span class="comment">     *	bean2</span></span><br><span class="line"><span class="comment">     *	com.itheima.a02.A02$Bean1@6392827e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//a02.xml</span><br><span class="line"><span class="comment">&lt;!-- 控制反转, 让 bean1和bean2 被 Spring 容器管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.a02.A02.Bean1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.a02.A02.Bean2&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 依赖注入, 让 bean2 建立与 bean1 的依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bean1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="2、FileSystemXmlApplicationContext"><a href="#2、FileSystemXmlApplicationContext" class="headerlink" title="2、FileSystemXmlApplicationContext"></a>2、FileSystemXmlApplicationContext</h2><p><strong>在磁盘路径下读取XML配置文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testFileSystemXmlApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileSystemXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;src\\main\\resources\\a02.xml&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="3、AnnotationConfigApplicationContext"><a href="#3、AnnotationConfigApplicationContext" class="headerlink" title="3、AnnotationConfigApplicationContext"></a>3、AnnotationConfigApplicationContext</h2><p><strong>基于java配置类来完成</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Config.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();&#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">(Bean1 bean1)</span> &#123;</span><br><span class="line">        <span class="type">Bean2</span> <span class="variable">bean2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">        bean2.setBean1(bean1);</span><br><span class="line">        <span class="keyword">return</span> bean2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123; &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Bean1 bean1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean1</span><span class="params">(Bean1 bean1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bean1 = bean1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">getBean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bean1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/07/15/spring%E6%BA%90%E7%A0%81-1-BeanFactory%E4%B8%8EApplicationContext/6.png" style="zoom:80%;">

<br>

<h2 id="4、AnnotationConfigServletWebServerApplicationContext"><a href="#4、AnnotationConfigServletWebServerApplicationContext" class="headerlink" title="4、AnnotationConfigServletWebServerApplicationContext"></a>4、AnnotationConfigServletWebServerApplicationContext</h2><p><strong>基于 java 配置类来创建，用于 web 环境</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAnnotationConfigServletWebServerApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//产生内嵌的 tomcat 容器</span></span><br><span class="line">    <span class="keyword">public</span> ServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();&#125;</span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//创建 dispatcherServlet 对象</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();&#125;</span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//将 dispatcherServlet 注册到tomcat容器中</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">registrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Controller <span class="title function_">controller1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (request, response) -&gt; &#123;</span><br><span class="line">            response.getWriter().print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
]]></content>
      <categories>
        <category>spring高级</category>
      </categories>
      <tags>
        <tag>底层源码</tag>
        <tag>spring高级</tag>
      </tags>
  </entry>
  <entry>
    <title>spring源码-2-Bean的生命周期</title>
    <url>/2022/07/15/spring%E6%BA%90%E7%A0%81-2-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="bean生命周期"><a href="#bean生命周期" class="headerlink" title="bean生命周期"></a>bean生命周期</h1><p><img src="/2022/07/15/spring%E6%BA%90%E7%A0%81-2-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/3.png"></p>
<p><strong>在各个阶段里都会有由bean后处理器提供的功能增强</strong></p>
<br>

<p><em><strong>bean的后处理器</strong></em></p>
<p><strong>创建前后的增强</strong></p>
<ul>
<li>postProcessBeforeInstantiation<ul>
<li>这里返回的对象若不为 null 会替换掉原本的 bean，并且仅会走 postProcessAfterInitialization 流程</li>
</ul>
</li>
<li>postProcessAfterInstantiation<ul>
<li>这里如果返回 false 会跳过依赖注入阶段</li>
</ul>
</li>
</ul>
<p><strong>依赖注入前的增强</strong></p>
<ul>
<li>postProcessProperties<ul>
<li>如 @Autowired、@Value、@Resource</li>
</ul>
</li>
</ul>
<p><strong>初始化前后的增强</strong></p>
<ul>
<li>postProcessBeforeInitialization<ul>
<li>这里返回的对象会替换掉原本的 bean</li>
<li>如 @PostConstruct、@ConfigurationProperties</li>
</ul>
</li>
<li>postProcessAfterInitialization <ul>
<li>这里返回的对象会替换掉原本的 bean</li>
<li>如代理增强</li>
</ul>
</li>
</ul>
<p><strong>销毁之前的增强</strong></p>
<ul>
<li>postProcessBeforeDestruction<ul>
<li>如 @PreDestroy</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">InstantiationAwareBeanPostProcessor</span>, DestructionAwareBeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(MyBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//postProcessBeforeDestruction：在销毁之前执行 bean 后处理器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeforeDestruction</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>))</span><br><span class="line">            log.debug(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt; 销毁之前执行, 如 @PreDestroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//postProcessBeforeInstantiation：在实例化之前执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>))</span><br><span class="line">            log.debug(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之前执行, 这里返回的对象会替换掉原本的 bean&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//postProcessAfterInstantiation：实例化之后执行，如果返回 false 会跳过依赖注入阶段，返回true则不会跳过</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>)) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之后执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//postProcessProperties：依赖注入阶段执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>))</span><br><span class="line">            log.debug(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt; 依赖注入阶段执行, 如 @Autowired、@Value、@Resource&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//postProcessBeforeInitialization：初始化之前执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>))</span><br><span class="line">            log.debug(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt; 初始化之前执行, 这里返回的对象会替换掉原本的 bean, 如 @PostConstruct、@ConfigurationProperties&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//postProcessAfterInitialization：初始化之后执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>))</span><br><span class="line">            log.debug(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt; 初始化之后执行, 这里返回的对象会替换掉原本的 bean, 如代理增强&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBeanFactory</span>();</span><br><span class="line">    beanFactory.addBeanPostProcessor(bean -&gt; System.out.println(<span class="string">&quot;解析 @Autowired&quot;</span>));</span><br><span class="line">    beanFactory.addBeanPostProcessor(bean -&gt; System.out.println(<span class="string">&quot;解析 @Resource&quot;</span>));</span><br><span class="line">    beanFactory.getBean();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;构造 &quot;</span> + bean);</span><br><span class="line">        System.out.println(<span class="string">&quot;依赖注入 &quot;</span> + bean); <span class="comment">// @Autowired, @Resource</span></span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor processor : processors) &#123;</span><br><span class="line">            processor.inject(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化 &quot;</span> + bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;BeanPostProcessor&gt; processors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//后处理器集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBeanPostProcessor</span><span class="params">(BeanPostProcessor processor)</span> &#123;processors.add(processor);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object bean)</span>; <span class="comment">// 对依赖注入阶段的扩展</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="Bean后处理器"><a href="#Bean后处理器" class="headerlink" title="Bean后处理器"></a>Bean后处理器</h1><blockquote>
<p>前言：</p>
<p>1、先创建一个干净容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br></pre></td></tr></table></figure>

<p>2、用原始形式注入bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.registerBean(<span class="string">&quot;bean1&quot;</span>, Bean1.class);</span><br><span class="line">context.registerBean(<span class="string">&quot;bean2&quot;</span>, Bean2.class);</span><br><span class="line">context.registerBean(<span class="string">&quot;bean3&quot;</span>, Bean3.class);</span><br></pre></td></tr></table></figure>

<p>3、利用后处理器进行加载测试<br>4、初始化容器，并打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行beanFactory后处理器, 添加bean后处理器, 初始化所有单例</span></span><br><span class="line">context.refresh();</span><br><span class="line">System.out.println(context.getBean(Bean1.class));</span><br></pre></td></tr></table></figure>
<p>5、销毁容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.refresh();</span><br></pre></td></tr></table></figure>
</blockquote>
<br>


<h2 id="AutowiredAnnotationBeanPostProcessor后处理器"><a href="#AutowiredAnnotationBeanPostProcessor后处理器" class="headerlink" title="AutowiredAnnotationBeanPostProcessor后处理器"></a>AutowiredAnnotationBeanPostProcessor后处理器</h2><p><strong>在依赖注入阶段，解析@Autowired和@Value注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析@Value注解的值注入问题，暂时不要求掌握</span></span><br><span class="line">context.getDefaultListableBeanFactory()</span><br><span class="line">    .setAutowireCandidateResolver(<span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析@Autowired @Value</span></span><br><span class="line">context.registerBean(AutowiredAnnotationBeanPostProcessor.class); </span><br></pre></td></tr></table></figure>

<br>

<h3 id="运行过程分析"><a href="#运行过程分析" class="headerlink" title="运行过程分析"></a>运行过程分析</h3><p><em><strong>执行依赖注入的 postProcessProperties 方法</strong></em></p>
<p><img src="/2022/07/15/spring%E6%BA%90%E7%A0%81-2-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/2.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 查找哪些属性、方法加了 @Autowired, 这称之为 InjectionMetadata</span></span><br><span class="line">        <span class="type">AutowiredAnnotationBeanPostProcessor</span> <span class="variable">processor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span>();</span><br><span class="line">        processor.setBeanFactory(beanFactory);</span><br><span class="line">        <span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">findAutowiringMetadata</span> <span class="operator">=</span> AutowiredAnnotationBeanPostProcessor.class.getDeclaredMethod(<span class="string">&quot;findAutowiringMetadata&quot;</span>, String.class, Class.class, PropertyValues.class);</span><br><span class="line">        findAutowiringMetadata.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、获取 Bean1 上加了 @Value @Autowired 的成员变量，方法参数信息</span></span><br><span class="line">        <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> (InjectionMetadata) findAutowiringMetadata.invoke(processor, <span class="string">&quot;bean1&quot;</span>, Bean1.class, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(metadata);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、调用 InjectionMetadata 来进行依赖注入, 注入时按类型查找值</span></span><br><span class="line">        metadata.inject(bean1, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(bean1);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4、inject内部</span></span><br><span class="line"><span class="comment">//4.1、成员变量注入</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">bean3</span> <span class="operator">=</span> Bean1.class.getDeclaredField(<span class="string">&quot;bean3&quot;</span>);</span><br><span class="line"><span class="comment">//将成员变量信息进行封装</span></span><br><span class="line"><span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(bean3, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//根据成员变量信息得到类型，进行根据类型找到容器中符合此类型中的一个bean</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd1, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">System.out.println(o);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.2、方法注入</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">setBean2</span> <span class="operator">=</span> Bean1.class.getDeclaredMethod(<span class="string">&quot;setBean2&quot;</span>, Bean2.class);</span><br><span class="line"><span class="comment">//将方法进行封装（以参数为单位进行封装，此处的0指的是第一个参数）</span></span><br><span class="line"><span class="type">DependencyDescriptor</span> <span class="variable">dd2</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(setBean2, <span class="number">0</span>), <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//根据方法参数的类型在容器中找到符合此类型的bean</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd2, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">System.out.println(o1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.3、值注入</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">setHome</span> <span class="operator">=</span> Bean1.class.getDeclaredMethod(<span class="string">&quot;setHome&quot;</span>, String.class);</span><br><span class="line"><span class="type">DependencyDescriptor</span> <span class="variable">dd3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(setHome, <span class="number">0</span>), <span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd3, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">System.out.println(o2);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><ol>
<li><strong>AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata 用来获取某个 bean 上加了 @Value @Autowired 的成员变量，方法参数的信息，表示为 InjectionMetadata</strong></li>
<li><strong>InjectionMetadata 可以完成依赖注入</strong></li>
<li><strong>InjectionMetadata 内部根据成员变量，方法参数封装为 DependencyDescriptor 类型</strong></li>
<li><strong>有了 DependencyDescriptor，就可以利用 beanFactory.doResolveDependency 方法进行基于类型的查找</strong></li>
</ol>
<br>

<h2 id="CommonAnnotationBeanPostProcessor后处理器"><a href="#CommonAnnotationBeanPostProcessor后处理器" class="headerlink" title="CommonAnnotationBeanPostProcessor后处理器"></a>CommonAnnotationBeanPostProcessor后处理器</h2><p><strong>依赖注入阶段解析@Resource，初始化前解析@PostConstruct，销毁前@PreDestroy注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br></pre></td></tr></table></figure>

<br>

<h2 id="ConfigurationPropertiesBindingPostProcessor后处理器"><a href="#ConfigurationPropertiesBindingPostProcessor后处理器" class="headerlink" title="ConfigurationPropertiesBindingPostProcessor后处理器"></a>ConfigurationPropertiesBindingPostProcessor后处理器</h2><p><strong>初始化前@ConfigurationProperties</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationPropertiesBindingPostProcessor.register(context.getDefaultListableBeanFactory());</span><br></pre></td></tr></table></figure>

<br>

<h1 id="BeanFactory后处理器"><a href="#BeanFactory后处理器" class="headerlink" title="BeanFactory后处理器"></a>BeanFactory后处理器</h1><h2 id="ConfigurationClassPostProcessor后处理器"><a href="#ConfigurationClassPostProcessor后处理器" class="headerlink" title="ConfigurationClassPostProcessor后处理器"></a>ConfigurationClassPostProcessor后处理器</h2><p><em><strong>可以用来解析@ComponentScan、@Bean、@Import、@ImportResource注解</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.registerBean(ConfigurationClassPostProcessor.class);</span><br></pre></td></tr></table></figure>

<br>

<h2 id="MapperScannerConfigurer后处理器"><a href="#MapperScannerConfigurer后处理器" class="headerlink" title="MapperScannerConfigurer后处理器"></a>MapperScannerConfigurer后处理器</h2><p><em><strong>解析@MapperScanner注解</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.registerBean(MapperScannerConfigurer.class, bd -&gt; &#123;</span><br><span class="line">    bd.getPropertyValues().add(<span class="string">&quot;basePackage&quot;</span>, <span class="string">&quot;com.itheima.a05.mapper&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<br>

<h2 id="模拟实现-ComponentScan注解"><a href="#模拟实现-ComponentScan注解" class="headerlink" title="模拟实现@ComponentScan注解"></a>模拟实现@ComponentScan注解</h2><p><a href="https://www.hzzzzzy.icu/2022/07/15/ComponentScan%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/">ComponentScan的模拟实现（点我）</a></p>
<br>



















]]></content>
      <categories>
        <category>spring高级</category>
      </categories>
      <tags>
        <tag>底层源码</tag>
        <tag>spring高级</tag>
      </tags>
  </entry>
</search>
