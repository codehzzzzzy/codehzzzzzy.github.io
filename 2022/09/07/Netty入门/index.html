<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Z.yang | Z.yang</title><meta name="keywords" content="博客"><meta name="author" content="Z.yang"><meta name="copyright" content="Z.yang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概述Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端 注意：Netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO   优势  入门案例添加依赖12345&lt;dependency&gt;    &lt;groupId&gt;io.netty&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;netty-al">
<meta property="og:type" content="article">
<meta property="og:title" content="Z.yang">
<meta property="og:url" content="http://www.hzzzzzy.icu/2022/09/07/Netty%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="Z.yang">
<meta property="og:description" content="概述Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端 注意：Netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO   优势  入门案例添加依赖12345&lt;dependency&gt;    &lt;groupId&gt;io.netty&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;netty-al">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://pic.yupoo.com/hzzzzzy/799f3a9a/1f656da2.webp">
<meta property="article:published_time" content="2022-09-07T13:45:15.533Z">
<meta property="article:modified_time" content="2022-09-21T14:16:31.488Z">
<meta property="article:author" content="Z.yang">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://pic.yupoo.com/hzzzzzy/799f3a9a/1f656da2.webp"><link rel="shortcut icon" href="https://i.postimg.cc/3x9LfnT5/01.jpg"><link rel="canonical" href="http://www.hzzzzzy.icu/2022/09/07/Netty%E5%85%A5%E9%97%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Z.yang',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-21 22:16:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"  media="defer" onload="this.media='all'"><script src="https://cyan-blog.oss-cn-shenzhen.aliyuncs.com/cdn/js/three.min.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.postimg.cc/3x9LfnT5/01.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="canvas-container" id="canvas"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://pic.yupoo.com/hzzzzzy/799f3a9a/1f656da2.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Z.yang</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-07T13:45:15.533Z" title="发表于 2022-09-07 21:45:15">2022-09-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-21T14:16:31.488Z" title="更新于 2022-09-21 22:16:31">2022-09-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</strong></p>
<p><strong style="color:red">注意：Netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</strong></p>
<br>

<h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921220936680.png" alt="image-20220921220936680" style="zoom:67%;">

<h1 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.39.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="服务器步骤"><a href="#服务器步骤" class="headerlink" title="服务器步骤"></a>服务器步骤</h2><p>1、创建启动器类，添加组件（NioEventLoopGroup）</p>
<p>2、添加一个ServerSocketChannel的实现</p>
<p>3、添加处理器和初始化器</p>
<p>4、绑定监听端口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1、启动器：负责组装 netty 组件，启动服务器</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                <span class="comment">//2、BossEventLoop，WorkEventLoop(selector,thread)，group组</span></span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                <span class="comment">//3、选择服务器的 ServerSocketChannel 实现</span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 4、childHandler：决定了worker(child) 能执行哪些操作(handler)</span></span><br><span class="line"><span class="comment">                 * (boss 负责处理连接)</span></span><br><span class="line"><span class="comment">                 * (worker(child) 负责处理读写)</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .childHandler(</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 5、负责添加别的handler(在initChannel方法里进行添加)</span></span><br><span class="line"><span class="comment">                         * Channel：代表和客户端进行数据读写的通道</span></span><br><span class="line"><span class="comment">                         * Initializer：初始化器</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="comment">//负责解码，将ByteBuf转换为字符串</span></span><br><span class="line">                        nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                        <span class="comment">//自定义handler</span></span><br><span class="line">                        nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                             <span class="comment">//7、channelRead：在读事件发生后，执行该方法</span></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                System.out.println(msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//8、服务器启动后绑定的监听端口</span></span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="客户端步骤"><a href="#客户端步骤" class="headerlink" title="客户端步骤"></a>客户端步骤</h2><p>1、创建启动器类，添加组件</p>
<p>2、添加一个SocketChannel的实现</p>
<p>3、添加处理器</p>
<p>4、连接到服务器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//1、启动器</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                <span class="comment">//2、添加 EventLoop</span></span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                <span class="comment">//3、选择客户端 channel 实现</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">//4、添加处理器</span></span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span>  <span class="comment">//在连接建立后被调用</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>()); <span class="comment">//将ByteBuf解码为字符串</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//5、连接到服务器</span></span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>))</span><br><span class="line">                .sync()<span class="comment">//阻塞方法，知道连接建立</span></span><br><span class="line">                .channel()</span><br><span class="line">                <span class="comment">//6、向服务器发送数据</span></span><br><span class="line">                .writeAndFlush(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a><strong style="color:red">整体流程</strong></h2><blockquote>
<p><strong>Channel 可以理解为数据的通道</strong></p>
<p><strong>msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf</strong></p>
<p><strong>handler 可以理解为数据的处理工序</strong></p>
<ul>
<li>工序有多道，合在一起就是 pipeline（传递途径）pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li>
<li>pipeline 中有多个 handler，处理时会依次调用其中的 handler</li>
<li>handler 分 Inbound（入栈） 和 Outbound（出栈） 两类</li>
</ul>
<p><strong>EventLoop 可以理解为处理数据的工人</strong></p>
<ul>
<li><strong>EventLoop 可以管理多个 channel 的 IO 操作，并且一旦 EventLoop 负责了某个 channel，就会将其与channel进行绑定</strong>，以后该 channel 中的 IO 操作都由该 EventLoop 负责</li>
<li><strong>EventLoop 既可以执行 IO 操作，也可以进行任务处理</strong>，每个 EventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li>
<li><strong>EventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据</strong>，可以为每个 handler 指定不同的 EventLoop</li>
</ul>
</blockquote>
<br>

<p><strong>左侧为Client，右侧为server</strong></p>
<p><img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221000675.png" alt="image-20220921221000675"></p>
<br>

<h1 id="EventLoop相关"><a href="#EventLoop相关" class="headerlink" title="EventLoop相关"></a>EventLoop相关</h1><p><strong>EventLoop本质上是一个单线程执行器（同时维护了一个Selector），里面由run方法处理Channel上源源不断的IO事件</strong></p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><ul>
<li>一条线继承自：java.util.concurrent.ScheduledExecutorService 因此包含了线程池中所有的方法</li>
<li>另外一条线继承自Netty本身的OrderedEventExecutor<ul>
<li>提供了 BooleaninEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>
<li>提供了 EventLoopGroup parent() 方法来看看自身属于哪个 EventLoopGroup</li>
</ul>
</li>
</ul>
<br>

<h2 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h2><p><strong>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 IO 事件都由此 EventLoop 来处理（保证了 IO 事件处理时的线程安全）</strong></p>
<p><strong style="color:red">注意：EventLoopGroup继承自 Netty 自己的 EventExecutorGroup</strong></p>
<ul>
<li><strong style="color:red">实现了 Iterable 接口提供遍历 EventLoop 的能力</strong></li>
<li><strong style="color:red">另有 next 方法获取集合中下一个 EventLoop</strong></li>
</ul>
<br>

<h2 id="处理普通任务"><a href="#处理普通任务" class="headerlink" title="处理普通任务"></a>处理普通任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTestEventLoop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1、创建事件循环组</span></span><br><span class="line"><span class="comment">//        EventLoopGroup group = new DefaultEventLoopGroup();//可以处理普通任务和定时任务</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();<span class="comment">//可以处理IO事件，普通任务和定时任务</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、获取下一个循环对象</span></span><br><span class="line">        group.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、执行普通任务</span></span><br><span class="line">        group.next().submit(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        log.debug(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong></p>
<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221010946.png" alt="image-20220921221010946" style="zoom:67%;">

<br>

<h2 id="处理定时任务"><a href="#处理定时任务" class="headerlink" title="处理定时任务"></a>处理定时任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTestEventLoop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1、创建事件循环组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();<span class="comment">//可以处理IO事件，普通任务和定时任务</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、获取下一个循环对象</span></span><br><span class="line">        group.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 4、执行定时任务</span></span><br><span class="line"><span class="comment">         * 参数一：任务对象</span></span><br><span class="line"><span class="comment">         * 参数二：初始延迟时间，设置为0代表立刻执行</span></span><br><span class="line"><span class="comment">         * 参数三：间隔时间</span></span><br><span class="line"><span class="comment">         * 参数四：时间单位</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        group.next().scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;,<span class="number">0</span>,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：每隔一秒打印一次</strong></p>
<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221019654.png" alt="image-20220921221019654" style="zoom:67%;">

<br>

<h2 id="处理IO事件"><a href="#处理IO事件" class="headerlink" title="处理IO事件"></a>处理IO事件</h2><p><strong>服务器代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventLoopServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span>   <span class="comment">//ByteBuf类型</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                log.debug(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventLoopClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//1、启动器</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                <span class="comment">//2、添加 EventLoop</span></span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                <span class="comment">//3、选择客户端 channel 实现</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">//4、添加处理器</span></span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span>  <span class="comment">//在连接建立后被调用</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>()); <span class="comment">//将ByteBuf解码为字符串</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//5、连接到服务器</span></span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>))</span><br><span class="line">                .sync()</span><br><span class="line">                .channel();</span><br><span class="line">        <span class="comment">// 此处打断点调试，调用 channel.writeAndFlush(...);</span></span><br><span class="line">        System.out.println(channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h2><p>Bootstrap的group()方法<strong>可以传入两个EventLoopGroup参数</strong>，分别负责处理不同的事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">            	<span class="comment">// 两个Group，分别为Boss 负责Accept事件，Worker 负责读写事件</span></span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">				...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个客户端分别发送：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nioEventLoopGroup-3-1 hello1</span><br><span class="line">nioEventLoopGroup-3-2 hello2</span><br><span class="line">nioEventLoopGroup-3-1 hello3</span><br><span class="line">nioEventLoopGroup-3-2 hello4</span><br><span class="line">nioEventLoopGroup-3-2 hello4</span><br></pre></td></tr></table></figure>

<p><strong style="color:red">总结：一个EventLoop可以负责多个Channel，且EventLoop一旦与Channel绑定，则一直负责处理该Channel中的事件</strong></p>
<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221040084.png" alt="image-20220921221040084" style="zoom:67%;">

<h3 id="增加自定义EventLoopGroup"><a href="#增加自定义EventLoopGroup" class="headerlink" title="增加自定义EventLoopGroup"></a>增加自定义EventLoopGroup</h3><p>当有的<strong>任务需要较长的时间处理时，可以使用非NioEventLoopGroup</strong>，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventLoopServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//细分2：创建一个独立的 EventLoopGroup</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                <span class="comment">//细分1：boss只负责accept事件，worker只负责socketChannel上的读写</span></span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(),<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="string">&quot;handler-1&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span>   <span class="comment">//ByteBuf类型</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                log.debug(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                                <span class="comment">//将消息传递给下一个Handler</span></span><br><span class="line">                                ctx.fireChannelRead(msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;).addLast(group,<span class="string">&quot;handler-2&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                    <span class="meta">@Override</span>   <span class="comment">//ByteBuf类型</span></span><br><span class="line">                                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                        log.debug(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动四个客户端发送数据</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nioEventLoopGroup-4-1 hello1</span><br><span class="line">defaultEventLoopGroup-2-1 hello1</span><br><span class="line">nioEventLoopGroup-4-2 hello2</span><br><span class="line">defaultEventLoopGroup-2-2 hello2</span><br><span class="line">nioEventLoopGroup-4-1 hello3</span><br><span class="line">defaultEventLoopGroup-2-3 hello3</span><br><span class="line">nioEventLoopGroup-4-2 hello4</span><br><span class="line">defaultEventLoopGroup-2-4 hello4</span><br></pre></td></tr></table></figure>

<p><strong style="color:red">总结：客户端与服务器之间的事件，被nioEventLoopGroup和defaultEventLoopGroup分别处理</strong></p>
<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221055645.png" alt="image-20220921221055645" style="zoom:60%;">

<br>

<h3 id="切换线程"><a href="#切换线程" class="headerlink" title="切换线程"></a>切换线程</h3><p><strong>不同的EventLoopGroup切换的实现原理如下：</strong></p>
<p><strong>（当handler中绑定的Group不同时，需要切换Group来执行不同的任务）</strong></p>
<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221109152.png" alt="image-20220921221109152" style="zoom:67%;">

<p><strong style="color:red">如果两个handler绑定的是同一个线程，那么就直接调用；否则把要调用的代码封装为一个任务对象，由下一个handler的线程来调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>), next);</span><br><span class="line">    <span class="comment">// 获得下一个EventLoop, excutor 即为 EventLoopGroup</span></span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();	<span class="comment">//返回下一个handler的EventLoop</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断当前handler中的线程是否和下一个handler的EventLoop是否是同一个线程</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="comment">// 使用当前 EventLoopGroup 中的 EventLoop 来处理任务</span></span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行</span></span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="Channel相关"><a href="#Channel相关" class="headerlink" title="Channel相关"></a>Channel相关</h1><p><strong style="color:red">close() 可以用来关闭Channel</strong></p>
<p><strong style="color:red">closeFuture() 用来处理 Channel 的关闭</strong></p>
<ul>
<li><strong>sync 方法作用是同步等待 Channel 关闭</strong></li>
<li><strong>而 addListener 方法是异步等待 Channel 关闭</strong></li>
</ul>
<p><strong style="color:red">pipeline() 方法用于添加处理器</strong></p>
<p><strong style="color:red">write() 方法将数据写入到缓冲区中</strong></p>
<ul>
<li><strong style="color:green">因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送</strong></li>
<li><strong style="color:green">只有当缓冲满了或者调用了flush()方法后，才会将数据通过 Channel 发送出去</strong></li>
</ul>
<p><strong style="color:red">writeAndFlush() 方法将数据写入并<em>立即发送（刷出）</em></strong></p>
<br>

<h2 id="连接问题"><a href="#连接问题" class="headerlink" title="连接问题"></a>连接问题</h2><p>当我们注释了<code>channelFuture.sync();</code>后，服务器无法收到<code>hello world</code></p>
<p>因为建立连接的过程是异步非阻塞的，若不通过<code>sync()</code>方法阻塞主线程，等待连接真正建立，<strong>这时通过 channelFuture.channel() 拿到的 Channel 对象，并不是真正与服务器建立好连接的 Channel</strong>，也就没法将信息正确的传输给服务器端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventLoopClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span>  <span class="comment">//在连接建立后被调用</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>()); <span class="comment">//将ByteBuf解码为字符串</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 1、连接到服务器</span></span><br><span class="line"><span class="comment">                 * 异步非阻塞的方法</span></span><br><span class="line"><span class="comment">                 * 主线程发起了调用，真正执行connect方法的是另一个线程(NIO线程)</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//channelFuture.sync();</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 无阻塞的向下执行，获取channel</span></span><br><span class="line"><span class="comment">         * 此时获取到的channel是一个还没完全建立好连接的channel</span></span><br><span class="line"><span class="comment">         * 此时发送数据就会失败</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">        <span class="comment">//2、向服务器发送数据</span></span><br><span class="line">        channel.writeAndFlush(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>1、调用<code>channelFuture.sync();</code>方法。</strong><strong style="color:red">阻塞主线程，同步处理结果，等待连接真正建立好以后，再去获得 Channel 传递数据。</strong>使用该方法，获取 Channel 和发送数据的线程都是主线程</p>
<p>2、使用 <code>addListener</code> 方法异步处理结果。<strong style="color:red">通过这种方法可以在NIO线程中获取 Channel 并发送数据，而不是在主线程中执行这些操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span></span><br><span class="line">                <span class="comment">// NIO线程：NioEventLoop 中的线程</span></span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 当connect方法执行完毕后，也就是连接真正建立后</span></span><br><span class="line">        <span class="comment">// 会在NIO线程中调用operationComplete方法</span></span><br><span class="line">        channelFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.channel();</span><br><span class="line">                channel.writeAndFlush(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="关闭问题"><a href="#关闭问题" class="headerlink" title="关闭问题"></a>关闭问题</h2><p>要关闭channel时，可以调用channel.close()方法进行关闭。该方法也是一个<strong>异步方法</strong>。真正的关闭操作并不是在调用该方法的线程中执行的，而是<strong>在NIO线程中执行真正的关闭操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventLoopClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span>  <span class="comment">//在连接建立后被调用</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>()); <span class="comment">//将ByteBuf解码为字符串</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.sync().channel();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line))&#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.writeAndFlush(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;input&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><p>可以选择两种方法实现：在真正关闭channel后执行的一些额外操作</p>
<p><strong style="color:red">1、通过channel.closeFuture()方法获得对应的ChannelFuture对象，然后调用sync()方法阻塞执行操作的线程，等待channel真正关闭后，再执行其他操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 CloseFuture 对象</span></span><br><span class="line"><span class="comment"> * 1)同步模式处理关闭</span></span><br><span class="line"><span class="comment"> * 2)异步模式处理关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ChannelFuture</span> <span class="variable">closeFuture</span> <span class="operator">=</span> channel.closeFuture();</span><br><span class="line">closeFuture.sync();</span><br><span class="line"><span class="comment">//......sync()方法可以保证关闭操作执行完</span></span><br></pre></td></tr></table></figure>

<p><strong style="color:red">2、调用closeFuture.addListener方法，添加close的后续操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">closeFuture</span> <span class="operator">=</span> channel.closeFuture();</span><br><span class="line">closeFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//......此处可以写处理关闭后的相关操作</span></span><br><span class="line">        <span class="comment">// 关闭EventLoopGroup</span></span><br><span class="line">        group.shutdownGracefully();	<span class="comment">//优雅地停止：先拒绝接受新的任务，将运行中的线程执行完毕后才停止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<br>

<h1 id="Future与Promise"><a href="#Future与Promise" class="headerlink" title="Future与Promise"></a>Future与Promise</h1><p><strong>netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口</strong></p>
<p><strong>netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</strong></p>
<ul>
<li><strong style="color:red">jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</strong></li>
<li><strong style="color:red">netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束</strong></li>
<li><strong style="color:red">netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器</strong></li>
</ul>
<table>
<thead>
<tr>
<th><strong>功能&#x2F;名称</strong></th>
<th><strong>jdk Future</strong></th>
<th><strong>netty Future</strong></th>
<th><strong>Promise</strong></th>
</tr>
</thead>
<tbody><tr>
<td>cancel</td>
<td>取消任务</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isCanceled</td>
<td>任务是否取消</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isDone</td>
<td>任务是否完成，不能区分成功失败</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><strong style="color:red">get</strong></td>
<td><strong style="color:red">获取任务结果，阻塞等待</strong></td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><strong style="color:red">getNow</strong></td>
<td>-</td>
<td><strong style="color:red">获取任务结果，非阻塞，还未产生结果时返回 null</strong></td>
<td>-</td>
</tr>
<tr>
<td><strong style="color:red">await</strong></td>
<td>-</td>
<td><strong style="color:red">等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断</strong></td>
<td>-</td>
</tr>
<tr>
<td>sync</td>
<td>-</td>
<td>等待任务结束，如果任务失败，抛出异常</td>
<td>-</td>
</tr>
<tr>
<td>isSuccess</td>
<td>-</td>
<td>判断任务是否成功</td>
<td>-</td>
</tr>
<tr>
<td><strong style="color:red">cause</strong></td>
<td>-</td>
<td><strong style="color:red">获取失败信息，非阻塞，如果没有失败，返回null</strong></td>
<td>-</td>
</tr>
<tr>
<td><strong style="color:red">addLinstener</strong></td>
<td>-</td>
<td><strong style="color:red">添加回调，异步接收结果</strong></td>
<td>-</td>
</tr>
<tr>
<td>setSuccess</td>
<td>-</td>
<td>-</td>
<td>设置成功结果</td>
</tr>
<tr>
<td>setFailure</td>
<td>-</td>
<td>-</td>
<td>设置失败结果</td>
</tr>
</tbody></table>
<br>

<h2 id="JDK-Future"><a href="#JDK-Future" class="headerlink" title="JDK Future"></a>JDK Future</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJdkFuture</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//1、线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//2、提交任务</span></span><br><span class="line">        Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;线程池中的线程执行计算......&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//3、主线程通过 future 来获取结果</span></span><br><span class="line">        log.debug(<span class="string">&quot;等待结果......&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">res</span> <span class="operator">=</span> future.get();</span><br><span class="line">        log.debug(<span class="string">&quot;结果是&#123;&#125;&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221129167.png" alt="image-20220921221129167" style="zoom:67%;">

<br>

<h2 id="Netty-Future"><a href="#Netty-Future" class="headerlink" title="Netty Future"></a>Netty Future</h2><p><strong style="color:red">Netty中的Future对象，可以通过EventLoop的sumbit()方法得到</strong></p>
<ul>
<li>可以通过Future对象的<strong>get方法</strong>，阻塞地获取返回结果</li>
<li>可以通过<strong>getNow方法</strong>，获取结果，若还没有结果，则返回null，该方法是非阻塞的</li>
<li>可以通过<strong>future.addListener方法</strong>，在Callable方法执行的线程中，异步获取返回结果</li>
</ul>
<h3 id="同步方式获取结果"><a href="#同步方式获取结果" class="headerlink" title="同步方式获取结果"></a>同步方式获取结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNettyFuture</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> group.next();</span><br><span class="line">        <span class="comment">//提交任务</span></span><br><span class="line">        Future&lt;Integer&gt; future = eventLoop.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;线程池中的线程执行计算......&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//主线程通过 future 来获取结果</span></span><br><span class="line">        log.debug(<span class="string">&quot;等待结果......&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">res</span> <span class="operator">=</span> future.get();</span><br><span class="line">        log.debug(<span class="string">&quot;结果是&#123;&#125;&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221138285.png" alt="image-20220921221138285" style="zoom:67%;">

<br>

<h3 id="异步方式获取结果"><a href="#异步方式获取结果" class="headerlink" title="异步方式获取结果"></a>异步方式获取结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNettyFuture</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> group.next();</span><br><span class="line">        <span class="comment">//提交任务</span></span><br><span class="line">        Future&lt;Integer&gt; future = eventLoop.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;线程池中的线程执行计算......&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// NIO线程中异步获取结果</span></span><br><span class="line">        future.addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="built_in">super</span> Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;? <span class="built_in">super</span> Integer&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;接收结果：&#123;&#125;&quot;</span>,future.getNow());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221150212.png" alt="image-20220921221150212" style="zoom:67%;">

<br>

<h2 id="Netty-Promise"><a href="#Netty-Promise" class="headerlink" title="Netty Promise"></a>Netty Promise</h2><p><strong style="color:red">Promise相当于一个容器，可以用于存放各个线程中的结果，然后让其他线程去获取该结果</strong></p>
<h3 id="演示向promise填充正确结果"><a href="#演示向promise填充正确结果" class="headerlink" title="演示向promise填充正确结果"></a>演示向promise填充正确结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNettyPromise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//1.准备一个EventLoop对象</span></span><br><span class="line">        <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>().next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.主动创建 promise 对象</span></span><br><span class="line">        DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//3.任意一个线程执行计算，计算完毕后向promise填充结果</span></span><br><span class="line">            log.debug(<span class="string">&quot;开始计算...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            promise.setSuccess(<span class="number">80</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.接受结果的线程</span></span><br><span class="line">        log.debug(<span class="string">&quot;等待结果...&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;结果是：&#123;&#125;&quot;</span>,promise.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221159397.png" alt="image-20220921221159397" style="zoom:67%;">

<br>

<h3 id="演示向promise填充错误结果"><a href="#演示向promise填充错误结果" class="headerlink" title="演示向promise填充错误结果"></a>演示向promise填充错误结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNettyPromise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//1.准备一个EventLoop对象</span></span><br><span class="line">        <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>().next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.主动创建 promise 对象</span></span><br><span class="line">        DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//3.任意一个线程执行计算，计算完毕后向promise填充结果</span></span><br><span class="line">            log.debug(<span class="string">&quot;开始计算...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                promise.setSuccess(<span class="number">80</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                promise.setFailure(e);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.接受结果的线程</span></span><br><span class="line">        log.debug(<span class="string">&quot;等待结果...&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;结果是：&#123;&#125;&quot;</span>,promise.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221209027.png" alt="image-20220921221209027" style="zoom:67%;">

<br>

<h1 id="Handler与Pipeline"><a href="#Handler与Pipeline" class="headerlink" title="Handler与Pipeline"></a>Handler与Pipeline</h1><p>Pipeline代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPipeline</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="comment">//1.通过channel拿到pipeline</span></span><br><span class="line">                        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 2.添加处理器</span></span><br><span class="line"><span class="comment">                         * addLast字面意思上是把 pipeline 加入到流水线的最后一个位置</span></span><br><span class="line"><span class="comment">                         * Netty在建立的时候会将自动加上两个handler</span></span><br><span class="line"><span class="comment">                         * 一个是head Handler，另外一个是tail Handler</span></span><br><span class="line"><span class="comment">                         * 此处所加的handler是加在tail之前</span></span><br><span class="line"><span class="comment">                         *</span></span><br><span class="line"><span class="comment">                         * 此处添加了四个处理器：head -&gt; h1 -&gt; h2 -&gt; h3 -&gt; h4 -&gt;h5 -&gt; h6 -&gt;tail</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;handler-1&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;handler-1&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;handler-2&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;handler-2&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;handler-3&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;handler-3&quot;</span>);</span><br><span class="line">                               	<span class="comment">/**</span></span><br><span class="line"><span class="comment">                               	 * 此处可以不需要调用channelRead方法</span></span><br><span class="line"><span class="comment">                                 * 因为channelRead方法目的是为了唤醒下一个入站的handler</span></span><br><span class="line"><span class="comment">                                 * 此时下一个是出站的，所以没必要进行唤醒</span></span><br><span class="line"><span class="comment">                                 */</span></span><br><span class="line">                                <span class="comment">//super.channelRead(ctx, msg);</span></span><br><span class="line">                                </span><br><span class="line">                                <span class="comment">//分配了一个ByteBuffer对象，然后往ByteBuffer里面写入字节，目的为了触发下面三个出站处理器</span></span><br><span class="line">                               	<span class="comment">//只有执行该方法才会触发出栈动作，如果没有写出，那么只会触发读或者写</span></span><br><span class="line">                                channel.writeAndFlush(ctx.alloc().buffer().writeBytes(<span class="string">&quot;server....&quot;</span>.getBytes()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;handler-4&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;handler-4&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;handler-5&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;handler-5&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">                                channel.writeAndFlush(ctx.alloc().buffer().writeBytes(<span class="string">&quot;server....&quot;</span>.getBytes()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;handler-6&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;handler-6&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">                                channel.writeAndFlush(ctx.alloc().buffer().writeBytes(<span class="string">&quot;server....&quot;</span>.getBytes()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221220729.png" alt="image-20220921221220729" style="zoom:67%;">

<br>

<p>对channelRead传递的信息进行加工</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPipeline</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="comment">//1.通过channel拿到pipeline</span></span><br><span class="line">                        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 2.添加处理器</span></span><br><span class="line"><span class="comment">                         * addLast字面意思上是把 pipeline 加入到流水线的最后一个位置</span></span><br><span class="line"><span class="comment">                         * Netty在建立的时候会将自动加上两个handler</span></span><br><span class="line"><span class="comment">                         * 一个是head Handler，另外一个是tail Handler</span></span><br><span class="line"><span class="comment">                         * 此处所加的handler是加在tail之前</span></span><br><span class="line"><span class="comment">                         *</span></span><br><span class="line"><span class="comment">                         * 此处添加了四个处理器：head -&gt; h1 -&gt; h2 -&gt; h3 -&gt; h4 -&gt; tail</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;handler-1&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;handler-1&quot;</span>);</span><br><span class="line">                                <span class="comment">//将byteBuf加工成字符串，传递到下一个handler中</span></span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> buf.toString(Charset.defaultCharset());</span><br><span class="line">                                <span class="built_in">super</span>.channelRead(ctx, name);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line"></span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;handler-2&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object name)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;handler-2&quot;</span>);</span><br><span class="line">                                <span class="comment">//拿到上一个handler中的字符串，然后加工成Student对象，然后进行传递</span></span><br><span class="line">                                <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(name.toString());</span><br><span class="line">                                <span class="built_in">super</span>.channelRead(ctx, student);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line"></span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;handler-3&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;handler-3,结果：&#123;&#125;,class：&#123;&#125;&quot;</span>,msg,msg.getClass());</span><br><span class="line">                                <span class="comment">//分配了一个ByteBuffer对象，然后往ByteBuffer里面写入字节，目的为了触发下面三个出站处理器</span></span><br><span class="line">                                channel.writeAndFlush(ctx.alloc().buffer().writeBytes(<span class="string">&quot;server....&quot;</span>.getBytes()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line"></span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;handler-4&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;handler-4&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line"></span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;handler-5&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;handler-5&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">                                channel.writeAndFlush(ctx.alloc().buffer().writeBytes(<span class="string">&quot;server....&quot;</span>.getBytes()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line"></span><br><span class="line">                        pipeline.addLast(<span class="string">&quot;handler-6&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                log.debug(<span class="string">&quot;handler-6&quot;</span>);</span><br><span class="line">                                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">                                channel.writeAndFlush(ctx.alloc().buffer().writeBytes(<span class="string">&quot;server....&quot;</span>.getBytes()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、通过<code>channel.pipeline().addLast(name, handler)</code>添加handler时，<em><strong>记得给handler取名字</strong></em>。<strong style="color:red">这样可以调用pipeline的addAfter、addBefore等方法更灵活地向pipeline中添加handler</strong></p>
<p><strong style="color:red">2、pipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler</strong></p>
<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221240384.png" alt="image-20220921221240384" style="zoom:67%;">

<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221249204.png" alt="image-20220921221249204" style="zoom:67%;">

<ul>
<li><p>要通过ctx.fireChannelRead(msg)等方法，<strong>将当前handler的处理结果传递给下一个handler</strong></p>
</li>
<li><p>当有<strong>入站</strong>（Inbound）操作时，会从<strong>head开始向后</strong>调用handler，直到handler不是处理Inbound操作为止</p>
</li>
<li><p>当有<strong>出站</strong>（Outbound）操作时，会从<strong>tail开始向前</strong>调用handler，直到handler不是处理Outbound操作为止</p>
</li>
<li><p>如果不调用<code>ctx.fireChannelRead(msg)</code>方法，就无法将当前handler的处理结果传递给下一个handler，从而无法进行下一个InboundHandler的调用。也可以使用ChannelRead内部的<code>ctx.fireChannelRead(msg)</code>来进行结果的传递</p>
</li>
</ul>
<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221259899.png" alt="image-20220921221259899" style="zoom:67%;">

<br>

<h2 id="socketChannel-writeAndFlush"><a href="#socketChannel-writeAndFlush" class="headerlink" title="socketChannel.writeAndFlush()"></a>socketChannel.writeAndFlush()</h2><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从tail向前寻找OutboundHandler</strong></p>
<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221307743.png" alt="image-20220921221307743" style="zoom:67%;">

<h2 id="ctx-writeAndFlush"><a href="#ctx-writeAndFlush" class="headerlink" title="ctx.writeAndFlush()"></a>ctx.writeAndFlush()</h2><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从当前handler向前寻找OutboundHandler</strong></p>
<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221315793.png" alt="image-20220921221315793" style="zoom:67%;">

<br>

<h2 id="EmbeddedChannel进行测试"><a href="#EmbeddedChannel进行测试" class="headerlink" title="EmbeddedChannel进行测试"></a>EmbeddedChannel进行测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEmbeddedChannel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ChannelInboundHandlerAdapter</span> <span class="variable">h1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;h1&quot;</span>);</span><br><span class="line">                <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChannelInboundHandlerAdapter</span> <span class="variable">h2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;h2&quot;</span>);</span><br><span class="line">                <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChannelOutboundHandlerAdapter</span> <span class="variable">h3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;h3&quot;</span>);</span><br><span class="line">                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChannelOutboundHandlerAdapter</span> <span class="variable">h4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;h4&quot;</span>);</span><br><span class="line">                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(h1, h2, h3, h4);</span><br><span class="line">        <span class="comment">//模拟入站输入数据</span></span><br><span class="line">        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;hello&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟出战写出数据</span></span><br><span class="line">        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;world&quot;</span>.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221323440.png" alt="image-20220921221323440" style="zoom:67%;">

<br>

<h1 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//不指定容量，默认是256</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">    System.out.println(buf.toString());</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">//测试ByteBuf容量的可变性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buf.writeBytes(stringBuilder.toString().getBytes());</span><br><span class="line">    System.out.println(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221331119.png" alt="image-20220921221331119" style="zoom:60%;">

<p>ByteBuf<strong>通过<code>ByteBufAllocator</code>选择allocator并调用对应的buffer()方法来创建的</strong>，默认使用<strong>直接内存</strong>作为ByteBuf，容量为256个字节，可以指定初始容量的大小</p>
<p><strong style="color:red">当ByteBuf的容量无法容纳所有数据时，ByteBuf会进行扩容操作，如果在handler中创建ByteBuf，建议使用<code>ChannelHandlerContext ctx.alloc().buffer()</code>来创建</strong></p>
<br>

<h2 id="直接内存与堆内存"><a href="#直接内存与堆内存" class="headerlink" title="直接内存与堆内存"></a>直接内存与堆内存</h2><p>ByteBuf支持两种内存分配，一种是直接内存，一种是堆内存，Netty默认使用的是直接内存</p>
<p>堆内存的分配效率比较高，但是读写效率比较低</p>
<p>直接内存分配效率比较低，读写效率比较高</p>
<blockquote>
<p><em><strong>1、直接内存使用的是系统内存，在磁盘中读取文件时，可以将文件直接读入系统内存，系统内存可以用直接内存的方式映射到JVM中，他们访问的都是同一块内存，可以减少一次内存的复制</strong></em></p>
<p><em><strong>2、堆内存收到垃圾回收的影响，垃圾回收会涉及到对象的复制和移动，会影响效率</strong></em></p>
</blockquote>
<br>

<h2 id="池化与非池化"><a href="#池化与非池化" class="headerlink" title="池化与非池化"></a>池化与非池化</h2><p><strong>对于一些创建比较耗时的资源，可以使用池的思想进行优化，池化的最大意义在于可以重用ByteBuf</strong></p>
<blockquote>
<p>比如数据库连接创建很耗时，所以我们就可以用预先将连接对象创建好，在使用的过程中，就可以直接拿到连接，在使用完毕后，再将连接归还</p>
</blockquote>
<p><em><strong style="color:red">池化优点：</strong></em></p>
<p><strong style="color:red">1、如果没有池化，那么每次都得创建新的 ByteBuf 实例，这个操作堆直接内存代价很高，就算是堆内存，也会增加GC的压力</strong></p>
<p><strong style="color:red">2、池化可以重用池中的ByteBuf实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</strong></p>
<p><strong style="color:red">3、高并发时，池化功能更节约内存，减少内存溢出的可能</strong></p>
<p>池化功能默认是开启的，也可以通过系统环境变量来进行设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>在构造ByteBuf时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为Integer.MAX_VALUE</li>
<li>当ByteBuf容量无法容纳所有数据时，会进行扩容操作，若<strong>超出最大容量</strong>，会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li>
</ul>
<p><em><strong>注意：最开始读写指针都在 0 位置</strong></em></p>
<p><strong style="color:red">读写操作不同于ByteBuffer只用position进行控制，ByteBuf分别由读指针和写指针两个指针控制</strong></p>
<ul>
<li><p><strong style="color:green">进行读写操作时，无需进行模式的切换</strong></p>
</li>
<li><p><strong style="color:green">读指针前的部分被称为废弃部分，是已经读过的内容</strong></p>
</li>
<li><p><strong style="color:green">读指针与写指针之间的空间称为可读部分</strong></p>
</li>
<li><p><strong style="color:green">写指针与当前容量之间的空间称为可写部分</strong></p>
</li>
</ul>
<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221346623.png" alt="image-20220921221346623" style="zoom:67%;">

<br>

<h2 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">含义</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">writeBoolean(boolean value)</td>
<td align="center">写入 boolean 值</td>
<td align="center"><em><strong>用一个字节 01|00 代表 true|false</strong></em></td>
</tr>
<tr>
<td align="center">writeByte(int value)</td>
<td align="center">写入 byte 值</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">writeShort(int value)</td>
<td align="center">写入 short 值</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><em><strong>writeInt(int value)</strong></em></td>
<td align="center">写入 int 值</td>
<td align="center">Big Endian<strong>（大端写入）</strong>如 0x250，写入后 00 00 02 50</td>
</tr>
<tr>
<td align="center"><em><strong>writeIntLE(int value)</strong></em></td>
<td align="center">写入 int 值</td>
<td align="center">Little Endian<strong>（小端写入）</strong>，即 0x250，写入后 50 02 00 00</td>
</tr>
<tr>
<td align="center">writeLong(long value)</td>
<td align="center">写入 long 值</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">writeChar(int value)</td>
<td align="center">写入 char 值</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">writeFloat(float value)</td>
<td align="center">写入 float 值</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">writeDouble(double value)</td>
<td align="center">写入 double 值</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">writeBytes(ByteBuf src)</td>
<td align="center">写入 netty 的 ByteBuf</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">writeBytes(byte[] src)</td>
<td align="center"><strong>写入 byte[]</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">writeBytes(ByteBuffer src)</td>
<td align="center"><strong>写入 nio 的 ByteBuffer</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">int writeCharSequence(CharSequence sequence, Charset charset)</td>
<td align="center">写入字符串</td>
<td align="center">CharSequence为字符串类的父类，第二个参数为对应的字符集</td>
</tr>
</tbody></table>
<p><strong style="color:red">注意</strong></p>
<ul>
<li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着<strong style="color:red">可以链式调用来写入不同的数据</strong></li>
<li>网络传输中，<strong>默认习惯是 Big Endian</strong>，使用 writeInt(int value)</li>
<li>还有一类方法是 <strong>set 开头</strong>的一系列方法，也<strong>可以写入数据，但不会改变写指针位置</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteBufStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建ByteBuf</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">16</span>, <span class="number">20</span>);</span><br><span class="line">        ByteBufUtil.log(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向buffer中写入数据</span></span><br><span class="line">        buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        ByteBufUtil.log(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//大端写入</span></span><br><span class="line">        buffer.writeInt(<span class="number">5</span>);</span><br><span class="line">        ByteBufUtil.log(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小端写入</span></span><br><span class="line">        buffer.writeIntLE(<span class="number">6</span>);</span><br><span class="line">        ByteBufUtil.log(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入Long值</span></span><br><span class="line">        buffer.writeLong(<span class="number">7</span>);</span><br><span class="line">        ByteBufUtil.log(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221404096.png" alt="image-20220921221404096" style="zoom:60%;">

<br>

<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p><strong style="color:red">当ByteBuf中的容量无法容纳写入的数据时（初始容量是10），会进行扩容操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer.writeInt(<span class="number">6</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221415418.png" alt="image-20220921221415418" style="zoom:67%;">

<p><em><strong>扩容规则</strong></em></p>
<p><strong style="color:red">如果写入后数据大小未超过 512 字节，则选择下一个 16 的整数倍进行扩容</strong></p>
<ul>
<li>例如写入后大小为 12 字节，则扩容后 capacity 是 16 字节</li>
</ul>
<p><strong style="color:red">如果写入后数据大小超过 512 字节，则选择下一个 2^n</strong></p>
<ul>
<li>例如写入后大小为 513 字节，则扩容后 capacity 是 2^10&#x3D;1024 字节（2^9&#x3D;512 已经不够了）</li>
</ul>
<p><strong style="color:red">扩容不能超过 maxCapacity，否则会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</strong></p>
<br>

<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>读取主要是通过一系列read方法进行读取，读取时会根据读取数据的字节数移动读指针</p>
<p><strong style="color:red">注意：读过的内容，属于废弃部分，再次读取只能读取那些尚未读取的部分</strong></p>
<p><strong style="color:red">如果需要重复读取，需要调用<code>buffer.markReaderIndex()</code>对读指针进行标记，并通过<code>buffer.resetReaderIndex()</code>将读指针恢复到mark标记的位置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteBufStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建ByteBuf</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">16</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向buffer中写入数据</span></span><br><span class="line">        buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        buffer.writeInt(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取4个字节</span></span><br><span class="line">        System.out.println(buffer.readByte());</span><br><span class="line">        System.out.println(buffer.readByte());</span><br><span class="line">        System.out.println(buffer.readByte());</span><br><span class="line">        System.out.println(buffer.readByte());</span><br><span class="line">        ByteBufUtil.log(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过mark与reset实现重复读取</span></span><br><span class="line">        buffer.markReaderIndex();</span><br><span class="line">        System.out.println(buffer.readInt());</span><br><span class="line">        ByteBufUtil.log(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复到mark标记处</span></span><br><span class="line">        buffer.resetReaderIndex();</span><br><span class="line">        ByteBufUtil.log(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221426655.png" alt="image-20220921221426655" style="zoom:67%;">

<br>

<h2 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h2><p><strong style="color:red">由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是通过手动来进行释放，而不是等待垃圾回收</strong></p>
<ul>
<li><em><strong>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</strong></em></li>
<li><em><strong>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</strong></em></li>
<li><em><strong>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</strong></em></li>
</ul>
<p><strong style="color:red">Netty采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</strong></p>
<ul>
<li><em><strong>每个 ByteBuf 对象的初始计数为1</strong></em></li>
<li><em><strong>调用 release 方法计数减1，如果计数为0，ByteBuf 内存被回收</strong></em></li>
<li><em><strong>调用 retain 方法计数加1，表示调用者没用完之前，其他 handler 即使调用了 release 也不会造成回收</strong></em></li>
<li><em><strong>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还存在，其各个方法均无法正常使用</strong></em></li>
</ul>
<br>

<blockquote>
<p>因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果传递到最后，则总是由tail和head进行释放。在这个过程中，如果 ByteBuf 进行了转换，tail或head拿到的就不是原本的 ByteBuf 了，也就无法进行释放。所以一般谁最后使用了，谁负责 release</p>
</blockquote>
<p>1、起点，对于 NIO 实现来讲，在 <code>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read</code> 方法中首次创建 ByteBuf 放入 <code>pipeline(line 163 pipeline.fireChannelRead(byteBuf))</code></p>
<p><strong style="color:red">2、入站 ByteBuf 处理原则</strong></p>
<ul>
<li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li>
<li><strong>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</strong></li>
<li><strong>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</strong></li>
<li><strong>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</strong></li>
<li>假设消息<strong>一直向后传</strong>，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li>
</ul>
<p><strong style="color:red">3、出站 ByteBuf 处理原则</strong></p>
<ul>
<li><strong>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</strong></li>
</ul>
<p><strong style="color:red">4、异常处理原则</strong>：不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以<strong>循环调用 release 直到返回 true</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!buffer.release()) &#123;&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong style="color:red">当ByteBuf被传到了pipeline的head与tail时，ByteBuf会被其中的方法彻底释放，但前提是ByteBuf被传递到了head与tail中</strong></p>
<p><strong>TailConext中释放ByteBuf的源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. Please check your pipeline configuration.&quot;</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 具体的释放方法</span></span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判断传过来的是否为ByteBuf，是的话才需要释放</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> msg <span class="keyword">instanceof</span> ReferenceCounted ? ((ReferenceCounted)msg).release() : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a><strong style="color:red">slice</strong></h3><p>是零拷贝的体现之一，<em><strong>对原始的 ByteBuf 进行切片成多个 ByteBuf（逻辑上并非物理上）</strong></em>，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write指针</p>
<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921215859047.png" alt="image-20220921215859047" style="zoom:75%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">    buf.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;j&#x27;</span>&#125;);</span><br><span class="line">    log(buf);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数一：切片的起点</span></span><br><span class="line"><span class="comment">     * 参数二：切片的长度</span></span><br><span class="line"><span class="comment">     * 在切片的过程中并没有出现数据的复制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">f1</span> <span class="operator">=</span> buf.slice(<span class="number">0</span>, <span class="number">5</span>);log(f1);</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">f2</span> <span class="operator">=</span> buf.slice(<span class="number">5</span>, <span class="number">5</span>);log(f2);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * slice方法对切片出来的ByteBuf做了限制</span></span><br><span class="line"><span class="comment">     * UnpooledSlicedByteBuf(ridx: 0, widx: 5, cap: 5/5</span></span><br><span class="line"><span class="comment">     * unwrapped: PooledUnsafeDirectByteBuf(ridx: 0, widx: 10, cap: 10))</span></span><br><span class="line"><span class="comment">     * f1.writeByte(&#x27;x&#x27;);	</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921220124685.png" alt="image-20220921220124685" style="zoom:65%;">

<p><strong>当原有的ByteBuf调用release释放的时候，为了避免切片出来的f1和f2受到影响，一般在slice后，调用retain方法</strong></p>
<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221450641.png" alt="image-20220921221450641" style="zoom:67%;">

<h3 id="duplicate"><a href="#duplicate" class="headerlink" title="duplicate"></a>duplicate</h3><p>也是零拷贝的体现之一，截取了原始ByteBuf的所有内容，并且没有 max capacity 的限制，<em><strong>也是和原来的ByteBuf 使用同一块底层内存，只是读写指针是独立的</strong></em></p>
<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221501863.png" alt="image-20220921221501863" style="zoom:67%;">

<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关</p>
<br>

<h3 id="CompositeByteBuf"><a href="#CompositeByteBuf" class="headerlink" title="CompositeByteBuf"></a><strong style="color:red">CompositeByteBuf</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        buf2.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        <span class="comment">//此处会发生两次数据复制，将 buf1 和 buf2 的数据分别复制到 buf 中</span></span><br><span class="line"><span class="comment">//        buf.writeBytes(buf1).writeBytes(buf2);log(buf);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">CompositeByteBuf</span> <span class="variable">compositeByteBuf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line">        compositeByteBuf.addComponents(<span class="literal">true</span>,buf1,buf2);</span><br><span class="line">        log(compositeByteBuf);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221513171.png" alt="image-20220921221513171" style="zoom:67%;">

<br>

<h2 id="Unpooled工具类"><a href="#Unpooled工具类" class="headerlink" title="Unpooled工具类"></a>Unpooled工具类</h2><p>提供了非池化的 ByteBuf 创建，组合，复制等操作</p>
<p>例子：wrappedBuffer方法，包装 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> Unpooled.wrappedBuffer(buf1, buf2);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></table></figure>

<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221524022.png" alt="image-20220921221524022" style="zoom:60%;">

<p><strong>也可以用来包装普通字节数组，底层也不会有拷贝操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf4</span> <span class="operator">=</span> Unpooled.wrappedBuffer(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;);</span><br><span class="line">System.out.println(buf4.getClass());</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf4));</span><br></pre></td></tr></table></figure>

<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221533537.png" alt="image-20220921221533537" style="zoom:67%;">

<br>

<h2 id="总结优势"><a href="#总结优势" class="headerlink" title="总结优势"></a><strong style="color:red">总结优势</strong></h2><img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221542304.png" alt="image-20220921221542304" style="zoom:70%;">

<br>

<h1 id="粘包现象"><a href="#粘包现象" class="headerlink" title="粘包现象"></a>粘包现象</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><strong>服务端</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(TestServer.class);</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">                            <span class="built_in">super</span>.channelActive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">                            <span class="built_in">super</span>.channelInactive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());</span><br><span class="line">            channelFuture.sync();</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">            log.debug(<span class="string">&quot;stoped&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TestServer</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><strong>客户端</strong></h2><p><strong>客户端代码希望发送 10 个消息，每个消息是 16 字节</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(TestClient.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 加入自定义的入站 handler</span></span><br><span class="line"><span class="comment">                     * channelActive：在channel连接建立好后触发该事件</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">//每循环一次，就往 ByteBuf 添加16个byte的数据，并发送</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                                buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                                ctx.writeAndFlush(buffer);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务器端一次就接收了 160 个字节，而非分 10 次接收</strong></p>
<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221600029.png" alt="image-20220921221600029" style="zoom:100%;">

<br>

<h1 id="半包现象"><a href="#半包现象" class="headerlink" title="半包现象"></a>半包现象</h1><h2 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a><strong>客户端</strong></h2><p><strong>客户端代码希望发送 1 个消息，这个消息是 160 字节，代码改为</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">ctx.writeAndFlush(buffer);</span><br></pre></td></tr></table></figure>

<h2 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h2><p><strong>服务端修改一下接收缓冲区，其它代码不变</strong></p>
<blockquote>
<p>注意：<code>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10)</code> 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p><strong>服务器端输出可以看到，接收的消息被分为两节，第一次 20 字节，第二次 140 字节</strong></p>
<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221617581.png" alt="image-20220921221617581" style="zoom:60%;">

<br>

<h1 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h1><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><strong style="color:red">TCP 以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长，性能就越差</strong></p>
<img src="https://hzzzzzy-others.oss-cn-guangzhou.aliyuncs.com/images/image-20220921221629455.png" alt="image-20220921221629455" style="zoom:67%;">

<p><strong style="color:red">为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值</strong></p>
<blockquote>
<ul>
<li>窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用</li>
<li>窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动</li>
<li>如果数据 ack 返回了，窗口就可以向前滑动</li>
<li>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</li>
</ul>
</blockquote>
<img src="https://hzzzzzy-typora.oss-cn-guangzhou.aliyuncs.com/images/image-20220921211849252.png" style="zoom:60%;">

<br>

<h2 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h2><p>现象：发送 abc def，接受为 abcdef</p>
<p>原因</p>
<ul>
<li>应用层：接受方 ByteBuf 设置太大（Netty默认为1024）</li>
<li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接受方处理不及时且窗口大小足够大，这部分256 bytes 字节就会缓冲在接受方的滑动窗口中，当滑动窗口中缓冲了多个报文就会造成粘包</li>
<li>Nagle算法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wdscq1234/article/details/52432095">TCP-IP详解：Nagle算法</a></li>
</ul>
<h2 id="半包"><a href="#半包" class="headerlink" title="半包"></a>半包</h2><p>现象：</p>
<ul>
<li>发送 abcdef，接收 abc def</li>
</ul>
<p>原因</p>
<ul>
<li>应用层：接收方 ByteBuf 小于实际发送数据量</li>
<li>传输层-网络层：滑动窗口的问题，假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时<strong>接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</strong></li>
<li>数据链路层：MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Leo_wl/p/10297113.html">粘包、拆包发生原因滑动窗口、MSS&#x2F;MTU限制、Nagle算法（博客园）</a></p>
<br>

<h1 id="解决粘包半包现象"><a href="#解决粘包半包现象" class="headerlink" title="解决粘包半包现象"></a>解决粘包半包现象</h1><h2 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h2><p><strong style="color:red">可以解决粘包的现象，但是不能解决半包的现象</strong></p>
<p><strong>客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开</strong>。这时便无需使用滑动窗口等技术来缓冲数据，则不会发生粘包现象。但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以<strong>短链接无法解决半包现象</strong></p>
<p><strong>客户端代码改进</strong></p>
<p>修改channelActive方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer(<span class="number">16</span>);</span><br><span class="line">    buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">    ctx.writeAndFlush(buffer);</span><br><span class="line">    <span class="comment">// 使用短链接，每次发送完毕后就断开连接</span></span><br><span class="line">    ctx.channel().close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将发送步骤整体封装为send()方法，调用10次send()方法，模拟发送10次数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 发送10次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="定长解码器"><a href="#定长解码器" class="headerlink" title="定长解码器"></a>定长解码器</h2><p><strong style="color:red">客户端于服务器约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度。若发送数据长度不足则需要补齐至该长度</strong></p>
<p>服务器接收数据时，<strong>将接收到的数据按照约定的最大长度进行拆分</strong>，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。<strong>服务端需要用到<code>FixedLengthFrameDecoder</code>对数据进行定长解码</strong>，具体使用方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">16</span>));</span><br></pre></td></tr></table></figure>

<p><strong style="color:green">待补充……</strong></p>
<br>

<h2 id="行解码器"><a href="#行解码器" class="headerlink" title="行解码器"></a>行解码器</h2><p><strong style="color:green">待补充……</strong></p>
<h2 id="长度字段解码器"><a href="#长度字段解码器" class="headerlink" title="长度字段解码器"></a>长度字段解码器</h2><p><strong style="color:green">待补充……</strong></p>
<h1 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h1><p><strong style="color:green">待补充……</strong></p>
<h1 id="聊天室案例"><a href="#聊天室案例" class="headerlink" title="聊天室案例"></a>聊天室案例</h1><h2 id="业务概述"><a href="#业务概述" class="headerlink" title="业务概述"></a>业务概述</h2><h3 id="用户登录接口"><a href="#用户登录接口" class="headerlink" title="用户登录接口"></a>用户登录接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 登录成功返回 true, 否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String username, String password)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用户会话接口"><a href="#用户会话接口" class="headerlink" title="用户会话接口"></a>用户会话接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Session</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel 要绑定会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 会话绑定用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Channel channel, String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解绑会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel 要解绑会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unbind</span><span class="params">(Channel channel)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 属性名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">getAttribute</span><span class="params">(Channel channel, String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 属性名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(Channel channel, String name, Object value)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名获取 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Channel <span class="title function_">getChannel</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>

<h3 id="群聊会话接口"><a href="#群聊会话接口" class="headerlink" title="群聊会话接口"></a>群聊会话接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GroupSession</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> members 成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功时返回组对象, 失败返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Group <span class="title function_">createGroup</span><span class="params">(String name, Set&lt;String&gt; members)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加入聊天组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> member 成员名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Group <span class="title function_">joinMember</span><span class="params">(String name, String member)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除组成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> member 成员名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Group <span class="title function_">removeMember</span><span class="params">(String name, String member)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除聊天组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Group <span class="title function_">removeGroup</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取组成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成员集合, 如果群不存在或没有成员会返回 empty set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Set&lt;String&gt; <span class="title function_">getMembers</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成员 channel 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Channel&gt; <span class="title function_">getMembersChannel</span><span class="params">(String name)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断群聊是否一被创建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 群聊名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCreated</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(<span class="string">&quot;client handler&quot;</span>,<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 在链接建立后触发 active 事件</span></span><br><span class="line"><span class="comment">                         * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">                         * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">//在负责接收用户在控制台的输入，向服务器发送消息</span></span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                                <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                                System.out.println(<span class="string">&quot;请输入用户名:&quot;</span>);</span><br><span class="line">                                <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                                System.out.println(<span class="string">&quot;请输入密码:&quot;</span>);</span><br><span class="line">                                <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                                <span class="comment">//构造消息对象</span></span><br><span class="line">                                <span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(username, password);</span><br><span class="line">                                <span class="comment">//发送消息</span></span><br><span class="line">                                ctx.writeAndFlush(message);</span><br><span class="line"></span><br><span class="line">                                System.out.println(<span class="string">&quot;等待后续操作&quot;</span>);</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    System.in.read();</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;,<span class="string">&quot;system in&quot;</span>).start();</span><br><span class="line">                            <span class="built_in">super</span>.channelActive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    <span class="comment">//处理 LoginRequestMessage</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;LoginRequestMessage&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> msg.getUsername();</span><br><span class="line">                            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> msg.getPassword();</span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">login</span> <span class="operator">=</span> UserServiceFactory.getUserService().login(username, password);</span><br><span class="line">                            LoginResponseMessage responseMessage;</span><br><span class="line">                            <span class="comment">//登录成功</span></span><br><span class="line">                            <span class="keyword">if</span> (login)&#123;</span><br><span class="line">                                responseMessage = <span class="keyword">new</span> <span class="title class_">LoginResponseMessage</span>(<span class="literal">true</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">                            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">//登录失败</span></span><br><span class="line">                                responseMessage = <span class="keyword">new</span> <span class="title class_">LoginResponseMessage</span>(<span class="literal">false</span>, <span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//返回消息给客户端</span></span><br><span class="line">                            ctx.writeAndFlush(responseMessage);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://www.hzzzzzy.icu">Z.yang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.hzzzzzy.icu/2022/09/07/Netty%E5%85%A5%E9%97%A8/">http://www.hzzzzzy.icu/2022/09/07/Netty%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.hzzzzzy.icu" target="_blank">Z.yang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="http://pic.yupoo.com/hzzzzzy/799f3a9a/1f656da2.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/16/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/"><img class="prev-cover" src="http://pic.yupoo.com/hzzzzzy/f73747f2/e0af2823.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前端入门</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/05/Netty-NIO%E5%9F%BA%E7%A1%80/"><img class="next-cover" src="https://bu.dusays.com/2022/05/01/626e8fc2c9cb8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Netty-NIO基础</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.postimg.cc/3x9LfnT5/01.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Z.yang</div><div class="author-info__description">欢迎访问Z.yang的博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hzzzzzy" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://i.postimg.cc/WzyLPdsw/wechat.png" target="_blank" title="WeChat"><i class="fa-brands fa-weixin"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客，该博客使用hexo，github pages进行搭建，vercel进行网站托管。 目前大二，该博客将持续更新java相关的笔记与技术文章，有问题请通过微信或邮箱联系我!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">2.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">3.</span> <span class="toc-text">入门案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96"><span class="toc-number">3.1.</span> <span class="toc-text">添加依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.2.</span> <span class="toc-text">服务器步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.3.</span> <span class="toc-text">客户端步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">整体流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#EventLoop%E7%9B%B8%E5%85%B3"><span class="toc-number">4.</span> <span class="toc-text">EventLoop相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">4.1.</span> <span class="toc-text">继承关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventLoopGroup"><span class="toc-number">4.2.</span> <span class="toc-text">EventLoopGroup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%99%AE%E9%80%9A%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.3.</span> <span class="toc-text">处理普通任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.4.</span> <span class="toc-text">处理定时任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86IO%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.5.</span> <span class="toc-text">处理IO事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B7%A5"><span class="toc-number">4.6.</span> <span class="toc-text">分工</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89EventLoopGroup"><span class="toc-number">4.6.1.</span> <span class="toc-text">增加自定义EventLoopGroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.6.2.</span> <span class="toc-text">切换线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Channel%E7%9B%B8%E5%85%B3"><span class="toc-number">5.</span> <span class="toc-text">Channel相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">连接问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">解决方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.</span> <span class="toc-text">关闭问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-1"><span class="toc-number">5.4.</span> <span class="toc-text">解决方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Future%E4%B8%8EPromise"><span class="toc-number">6.</span> <span class="toc-text">Future与Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-Future"><span class="toc-number">6.1.</span> <span class="toc-text">JDK Future</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty-Future"><span class="toc-number">6.2.</span> <span class="toc-text">Netty Future</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%9C"><span class="toc-number">6.2.1.</span> <span class="toc-text">同步方式获取结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%96%B9%E5%BC%8F%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%9C"><span class="toc-number">6.2.2.</span> <span class="toc-text">异步方式获取结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty-Promise"><span class="toc-number">6.3.</span> <span class="toc-text">Netty Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA%E5%90%91promise%E5%A1%AB%E5%85%85%E6%AD%A3%E7%A1%AE%E7%BB%93%E6%9E%9C"><span class="toc-number">6.3.1.</span> <span class="toc-text">演示向promise填充正确结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA%E5%90%91promise%E5%A1%AB%E5%85%85%E9%94%99%E8%AF%AF%E7%BB%93%E6%9E%9C"><span class="toc-number">6.3.2.</span> <span class="toc-text">演示向promise填充错误结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Handler%E4%B8%8EPipeline"><span class="toc-number">7.</span> <span class="toc-text">Handler与Pipeline</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.1.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socketChannel-writeAndFlush"><span class="toc-number">7.2.</span> <span class="toc-text">socketChannel.writeAndFlush()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ctx-writeAndFlush"><span class="toc-number">7.3.</span> <span class="toc-text">ctx.writeAndFlush()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EmbeddedChannel%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">7.4.</span> <span class="toc-text">EmbeddedChannel进行测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ByteBuf"><span class="toc-number">8.</span> <span class="toc-text">ByteBuf</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">8.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-number">8.2.</span> <span class="toc-text">直接内存与堆内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%A0%E5%8C%96%E4%B8%8E%E9%9D%9E%E6%B1%A0%E5%8C%96"><span class="toc-number">8.3.</span> <span class="toc-text">池化与非池化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E6%88%90"><span class="toc-number">8.4.</span> <span class="toc-text">组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%85%A5"><span class="toc-number">8.5.</span> <span class="toc-text">写入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9"><span class="toc-number">8.6.</span> <span class="toc-text">扩容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96"><span class="toc-number">8.7.</span> <span class="toc-text">读取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8A%E6%94%BE"><span class="toc-number">8.8.</span> <span class="toc-text">释放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">8.9.</span> <span class="toc-text">零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#slice"><span class="toc-number">8.9.1.</span> <span class="toc-text">slice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#duplicate"><span class="toc-number">8.9.2.</span> <span class="toc-text">duplicate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy"><span class="toc-number">8.9.3.</span> <span class="toc-text">copy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CompositeByteBuf"><span class="toc-number">8.9.4.</span> <span class="toc-text">CompositeByteBuf</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unpooled%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">8.10.</span> <span class="toc-text">Unpooled工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%BC%98%E5%8A%BF"><span class="toc-number">8.11.</span> <span class="toc-text">总结优势</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B2%98%E5%8C%85%E7%8E%B0%E8%B1%A1"><span class="toc-number">9.</span> <span class="toc-text">粘包现象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">9.1.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">9.2.</span> <span class="toc-text">客户端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8A%E5%8C%85%E7%8E%B0%E8%B1%A1"><span class="toc-number">10.</span> <span class="toc-text">半包现象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-1"><span class="toc-number">10.1.</span> <span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-1"><span class="toc-number">10.2.</span> <span class="toc-text">服务端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%B0%E8%B1%A1%E5%88%86%E6%9E%90"><span class="toc-number">11.</span> <span class="toc-text">现象分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">11.1.</span> <span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%98%E5%8C%85"><span class="toc-number">11.2.</span> <span class="toc-text">粘包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8A%E5%8C%85"><span class="toc-number">11.3.</span> <span class="toc-text">半包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%E5%8D%8A%E5%8C%85%E7%8E%B0%E8%B1%A1"><span class="toc-number">12.</span> <span class="toc-text">解决粘包半包现象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%AD%E9%93%BE%E6%8E%A5"><span class="toc-number">12.1.</span> <span class="toc-text">短链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E9%95%BF%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">12.2.</span> <span class="toc-text">定长解码器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">12.3.</span> <span class="toc-text">行解码器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%BF%E5%BA%A6%E5%AD%97%E6%AE%B5%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">12.4.</span> <span class="toc-text">长度字段解码器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">13.</span> <span class="toc-text">协议设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%81%8A%E5%A4%A9%E5%AE%A4%E6%A1%88%E4%BE%8B"><span class="toc-number">14.</span> <span class="toc-text">聊天室案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">14.1.</span> <span class="toc-text">业务概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.1.1.</span> <span class="toc-text">用户登录接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%BC%9A%E8%AF%9D%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.1.2.</span> <span class="toc-text">用户会话接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BE%A4%E8%81%8A%E4%BC%9A%E8%AF%9D%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.1.3.</span> <span class="toc-text">群聊会话接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BB%E5%BD%95"><span class="toc-number">14.2.</span> <span class="toc-text">登录</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/16/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/" title="前端入门"><img src="http://pic.yupoo.com/hzzzzzy/f73747f2/e0af2823.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端入门"/></a><div class="content"><a class="title" href="/2022/09/16/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/" title="前端入门">前端入门</a><time datetime="2022-09-16T09:06:18.000Z" title="发表于 2022-09-16 17:06:18">2022-09-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/07/Netty%E5%85%A5%E9%97%A8/" title="无题"><img src="http://pic.yupoo.com/hzzzzzy/799f3a9a/1f656da2.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/09/07/Netty%E5%85%A5%E9%97%A8/" title="无题">无题</a><time datetime="2022-09-07T13:45:15.533Z" title="发表于 2022-09-07 21:45:15">2022-09-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/05/Netty-NIO%E5%9F%BA%E7%A1%80/" title="Netty-NIO基础"><img src="https://bu.dusays.com/2022/05/01/626e8fc2c9cb8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty-NIO基础"/></a><div class="content"><a class="title" href="/2022/09/05/Netty-NIO%E5%9F%BA%E7%A1%80/" title="Netty-NIO基础">Netty-NIO基础</a><time datetime="2022-09-05T08:11:48.000Z" title="发表于 2022-09-05 16:11:48">2022-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/04/LeetCode-SQL/" title="LeetCode-SQL"><img src="http://pic.yupoo.com/hzzzzzy/f73747f2/e0af2823.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode-SQL"/></a><div class="content"><a class="title" href="/2022/09/04/LeetCode-SQL/" title="LeetCode-SQL">LeetCode-SQL</a><time datetime="2022-09-04T00:58:01.000Z" title="发表于 2022-09-04 08:58:01">2022-09-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/31/Stream%E6%B5%81/" title="Stream流"><img src="http://pic.yupoo.com/hzzzzzy/f73747f2/e0af2823.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Stream流"/></a><div class="content"><a class="title" href="/2022/08/31/Stream%E6%B5%81/" title="Stream流">Stream流</a><time datetime="2022-08-31T00:03:22.000Z" title="发表于 2022-08-31 08:03:22">2022-08-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Z.yang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="2089623328" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script async data-pjax src="/js/sky.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="ture"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>