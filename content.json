{"meta":{"title":"Z.yang","subtitle":"Z.yang的博客","description":"欢迎访问Z.yang的博客","author":"Z.yang","url":"http://example.com","root":"/"},"pages":[{"title":"关于我","date":"2022-07-10T01:26:06.000Z","updated":"2022-07-10T01:59:51.459Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Z.yang“ 认识自我，超越自我 “ 那么你就离成功更进了一步 联系我​ QQ：&#x32;&#x39;&#x33;&#57;&#50;&#57;&#52;&#56;&#53;&#52;&#64;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;​ WeChat：https://postimg.cc/N2RP6f9K​ Outlook：&#x68;&#122;&#122;&#122;&#x7a;&#x7a;&#x79;&#64;&#x6f;&#x75;&#116;&#108;&#111;&#x6f;&#x6b;&#46;&#x63;&#111;&#x6d;"},{"title":"Zyang的好朋友们","date":"2022-07-09T08:00:38.000Z","updated":"2022-07-09T08:05:37.397Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"Zyang的标签页","date":"2022-07-09T07:56:18.000Z","updated":"2022-07-09T08:05:44.554Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-09T07:59:10.000Z","updated":"2022-07-10T01:13:31.420Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"06-本地方法栈和本地方法","slug":"06-本地方法栈和本地方法","date":"2022-07-12T01:37:44.000Z","updated":"2022-07-12T01:41:00.716Z","comments":true,"path":"2022/07/12/06-本地方法栈和本地方法/","link":"","permalink":"http://example.com/2022/07/12/06-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95/","excerpt":"","text":"本地方法实际上是一个java调用非java代码的一个接口 （ 使用native关键字进行修饰 ） 本地方法的作用： 1、Java应用与Java外面的环境交互 2、与操作系统进行交互 3、Sun公司解释器由C实现 本地方法栈 （线程私有）Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用 本地方法栈中登记本地方法，然后执行引擎执行时，加载本地方法库 当某一个线程调用本地方法时 本地方法可通过本地方法接口来访问虚拟机内部的运行时数据区 可以使用本地处理器中的寄存器 ……（和虚拟机拥有一样的权限）","categories":[{"name":"底层源码","slug":"底层源码","permalink":"http://example.com/categories/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"}]},{"title":"05-虚拟机栈及相关问题","slug":"05-虚拟机栈及相关问题","date":"2022-07-12T01:35:21.000Z","updated":"2022-07-12T01:48:54.033Z","comments":true,"path":"2022/07/12/05-虚拟机栈及相关问题/","link":"","permalink":"http://example.com/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","excerpt":"","text":"虚拟机栈 （线程私有） 不存在GC，存在OOM 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧，对应着一次次的方法调用 虚拟机栈的生命周期和线程一致。作用是主管java程序的运行，保存方法的局部变量（8种基本数据类型，对象的引用地址，对象实际存储在堆空间中），部分结果，并参与方法的调用和返回 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器 JVM直接对栈的操作：1、每个方法执行，伴随着进栈（入栈，压栈） 2、执行结束后的出栈操作 设置栈内存的大小使用参数-Xss选项设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度 栈的存储单位1）栈中的数据都是以栈帧为基本单位存在 2）在这个线程上正在执行的每个方法都各自对应着一个栈帧 3）栈帧是一个内存区块，是一个数据集，****维系着方法执行过程中的各种数据信息 4）在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧，与当前栈帧相对应的方法就是当前方法，定义这个方法的类就是当前类。 5）执行引擎运行的所有字节码指令只针对当前栈帧进行操作。 6）如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。 ​ 栈帧的内部结构每个栈帧都存储着： 局部变量表 操作数栈（表达式栈） 动态链接（或指向运行时常量池的方法引用） 方法返回地址（或方法正常退出或异常退出的定义） 一些附加信息 方法嵌套调用的次数由栈的大小决定，栈越大，方法嵌套调用的次数就越多。 对于一个函数，参数和局部变量越多，局部变量表就会膨胀，栈帧就越大 局部变量表1、存放编译器的各种基本数据类型（8种）引用类型（reference）returnAddress类型的变量 2、定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量 3、由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题 4、局部变量表所需的容量大小是在编译器就确定下来的（一旦确定就不会更改） 注意：局部变量表中的变量只在当前方法调用中有效，当方法调用结束后，随着方法栈帧的销毁，局部变量表也会销毁 123456789101112131415161718/** * @Description 字节码中方法内部结构的剖析 * @Author hzy * @Date 2022/7/11 14:54 * @Version 1.0 **///使用javap -v 类.class 或者使用jclasslibpublic class LocalVariableTest &#123; public static void main(String[] args) &#123; LocalVariableTest test=new LocalVariableTest(); int num=10; test.test1(); &#125; public static void test1()&#123; Date date = new Date(); String name=&quot;xiaozhi&quot;; &#125;&#125; ​ ​ ​ 比如此处，num对应的起始pc是8，对应代码的实际行数第14行，字节码指令长度是17 所以起始pc加上长度就是字节码的指令长度 textcolor{red}{局部变量表的基本存储单元是Slot(变量槽) 32位以内的类型只占用一个Slot（包括returnAddress类型） 64位的类型占用两个Slot（long和double） byte，short，char在存储前转化为int boolean也被转换为int，0表示false，1表示true JVM会为局部变量中的每一个Slot都分配一个访问索引，通过这个索引可以访问局部变量中指定的值 ​ 如果需要访问一个64bit的局部变量值时，只需要使用前一个索引即可 如果当前帧是由构造方法或者实例的方法进行创建的，那么该对象引用this将会存放在index为0的Slot处，其余的继续排列 例子：​ *this代表对象实例，而static是随类的加载而加载，先于实例之前就有的，所以不存在于局部变量表中，所以不能使用。 变量的分类 一、按照数据类型分：1、基本数据类型 2、引用数据类型 二、按照在类中声明的位置分： 1、成员变量：在使用前都经过默认初始化赋值 ​ 类变量：linking的prepare阶段，给类变量默认赋值 —&gt; initial阶段，给类变量显式赋值即静态代码块赋值 **实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值** **2、局部变量：使用前必须进行显示赋值，否则编译不通过** 局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中的直接或间接引用的对象都不会被回收 操作数（表达式）栈 每一个独立的栈帧中除了包含局部变量表以外，还包含了一个后进先出的操作数栈，也可以称之为表达式栈 在方法执行的过程中，根据字节码指令，往栈中写入数据（入栈）或提取数据（出栈） 主要用于保存计算过程的中间结果，同时作为计算机过程中变量临时的存储空间 当一个方法开始执行的时候，一个新的栈帧也会被创建出来，这个方法的操作数栈是空的 每一个操作数栈都会拥有一个栈深度用于存储数值（max_stack）32bit类型占用一个栈单位深度，64bit类型占用两个栈单位深度 操作数栈不是通过访问索引的方式来进行数据访问的，而只能通过标准的入栈出栈来进行数据访问 代码追踪12345public void testAddOperation()&#123; byte i = 15; int j = 8; int k = i + j;&#125; 操作数栈的最大深度123456789101112public class OperandStackTest &#123; public void testAddOperation()&#123; //byte、short、char、boolean:都以int型保存 byte i=15; short j=8; int k=i+j; long m=12L; int n=800; //存在宽化类型转换 m=m*n; &#125;&#125; 栈顶缓存技术为了解决指令过多导致频繁地执行内存读&#x2F;写操作，影响执行速度的问题 将栈顶元素全部缓存在物理CPU的寄存器中,以此降低对内存的读&#x2F;写次数 (将计算的操作放到CPU寄存器里面去) 动态链接栈帧内部包含了一个指向运行时常量池中该栈帧所属方法的引用—动态链接 每一个栈帧内部都包含一个指向运行时常量池Constant pool或该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如invokedynamic指令 动态链接的作用就是为了将这些符号引用(#)最终转换为调用方法的直接引用 方法的调用： 静态链接：在字节码文件装载进JVM内部时，被调用的方法在编译期可知，而且在运行的期间保持不变，这时候符号引用就会转换为直接引用。这个过程即为静态链接 动态链接：被调用的方法在编译期不可确定，在程序运行的期间才将符号引用进行转换，这个过程为动态链接 绑定：一个字段，方法，类在符号引用转换为直接引用的过程 早期绑定：被调用的目标方法在编译期内可知，运行期间不变 晚期绑定：调用方法在编译期无法确定，到运行期才确定 非虚方法：在编译器确定调用的版本，这个版本运行时不变，比如：静态方法，私有方法，final方法，实例构造器，父类方法 虚方法：其他 虚方法表每个类中都有一个虚方法表，表中存放着各个方法的实际入口。 如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中 虚方法表会在类加载的链接阶段被创建并开始初始化 ，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。 方法返回地址存储调用该方法的PC寄存器的值 在方法推出后都会返回到该方法被调用的位置。 方法正常退出时，调用者的PC计数器的值作为返回地址（调用该方法的指令的下一条指令的地址） 方法异常退出时，返回地址通过异常表来确定 相关问题1、举例栈溢出的情况：通过-Xss设置栈的大小（OOM） 2、调整栈大小，就能保证不出现溢出吗？不能 3、分配的栈内存越大越好吗？不是，栈空间大了线程数就少了，栈空间和线程数目成反比 4、垃圾回收是否会涉及到虚拟机栈？不会 5、方法中定义的局部变量是否线程安全？看情况 6、代码演示：（内部产生，在内部消亡，线程安全） 12345678910111213141516171819202122232425262728293031//s1的声明方式是线程安全的public static void method1()&#123; //StringBuilder线程不安全 StringBuilder s1 = new StringBuilder(); s1.append(&quot;a&quot;);&#125;//s2的操作过程是线程不安全的public static void method2(StringBuilder s2)&#123; s2.append(&quot;a&quot;);&#125;//s3的操作是线程不安全的public static StringBuilder method3() &#123; StringBuilder s3 = new StringBuilder(); s3.append(&quot;a&quot;); return s3;&#125;//s4的操作是线程安全的,s4其实在内部消亡了public static String method4() &#123; StringBuilder s4 = new StringBuilder(); s4.append(&quot;a&quot;); return s4.toString();&#125;public static void main(String[] args) &#123; StringBuilder s = new StringBuilder(); new Thread(()-&gt; &#123; s.append(&quot;a&quot;); &#125;).start(); method2(s);&#125;","categories":[{"name":"底层源码","slug":"底层源码","permalink":"http://example.com/categories/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"}]},{"title":"04-程序计数器","slug":"04-程序计数器","date":"2022-07-12T01:31:14.000Z","updated":"2022-07-12T01:39:49.820Z","comments":true,"path":"2022/07/12/04-程序计数器/","link":"","permalink":"http://example.com/2022/07/12/04-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/","excerpt":"","text":"程序计数器（PC寄存器）概述既不存在GC也不存在OOM PC寄存器用来存储指向下一条指令的地址，也是即将要执行的指令代码。由执行引擎读取下一条指令 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。 代码演示 通过PC寄存器，我们就可以知道当前程序执行到哪一步了 ​ 使用PC寄存器存储字节码地址有什么用？（为什么要使用PC寄存器记录当前线程的执行地址呢？）1、CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。 2、JVM的字节码解释器需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。 PC寄存器为什么被设定为线程私有的？由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。 这样必然导致经常中断或恢复，为了保证分毫无差。每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。 比如一个cpu负责3个线程，cpu会在3个线程间轮流执行，为了能够保证CPU在切换的过程中，每个线程都可以按照切换之前的指令继续执行，而不影响其他线程，所以PC寄存器设定为线程私有的 CPU时间片（*）","categories":[{"name":"底层源码","slug":"底层源码","permalink":"http://example.com/categories/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"}]},{"title":"03-数据区概述与线程","slug":"03-数据区概述与线程","date":"2022-07-12T01:30:10.000Z","updated":"2022-07-12T01:39:24.736Z","comments":true,"path":"2022/07/12/03-数据区概述与线程/","link":"","permalink":"http://example.com/2022/07/12/03-%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"数据区JVM在执行java程序的过程中会把它管理的内存划分为若干个不同的数据区域（包括5个运行时数据区） 1、方法区 2、虚拟机栈 3、本地方法栈 4、堆 5、程序计数器 ​ 运行时数据区的完整图 ​ Java的内存区域 ​ 灰色的为单独线程私有的，红色的为多个线程共享的。 即： 1、每个线程：独立包括程序计数器、虚拟机栈、本地方法栈。 2、线程间共享：堆、堆外内存（永久代或元空间、代码缓存） ​ 线程的简单介绍线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。 操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。 JVM线程（*） 虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。 GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。 编译线程：这种线程在运行时会将字节码编译成到本地代码。 信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。","categories":[{"name":"底层源码","slug":"底层源码","permalink":"http://example.com/categories/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"}]},{"title":"02-类加载器和类加载过程","slug":"02-类加载器和类加载过程","date":"2022-07-11T01:26:01.000Z","updated":"2022-07-11T01:45:16.698Z","comments":true,"path":"2022/07/11/02-类加载器和类加载过程/","link":"","permalink":"http://example.com/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"","text":"类加载过程 加载1、通过一个类的全限定名获取定义此类的二进制字节流 2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 链接：一共分为三个部分，验证、准备和解析一、验证目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身。 验证阶段是十分重要的，直接决定了Java虚拟机是否能承受恶意代码的攻击，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重。 主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证 二、准备1、为类变量分配内存并且设置该变量的默认初始值，即零值。 2、这里不包括含用final修饰的static,因为final在编译的时候就会分配数值了，准备阶段会显式初始化。 3、这里不会为实例变量分配初始化，类变量会分配在方法区，而实例变量是会随着对象一起分配到java堆中。 三、解析1、将常量池内的符号引用转换为直接引用过程 2、实际上，解析操作往往会伴随着JVM在执行完初始化之后再执行。 3、符号引用就是一组符号来描述所引用的目标。符号引用的字面形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 4、主要解析动作针对类或接口、字段、类方法、接口方法、方法类型等。 初始化1）初始化阶段就是执行类构造器方法()的过程该方法不需要定义，而是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来的 构造器方法中的指令按照语句在源文件中出现的顺序来决定 变量已经赋过一次系统要求的初始零值，而在初始化阶段 则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。 2）若该类有父类，JVM会保证子子类的()执行前，父类的()已经执行完毕虚拟机必须保证一个类的()方法在多线程下被同步加锁 3）在类加载的Linking链接的准备阶段，所有类变量以符号引用的方法存储在方法区而当静态代码尝试获取类变量时候需要通过直接引用，这就导致了编译的出错 4）Java编译器并不会为所有的类都产生()初始化方法一个类中并没有声明任何的类变量,也没有静态代码块时 一个类中声明类变量,但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时 一个类中包含static final修饰的基本数据类型的字段,这些类字段初始化语句采用编译时常量表达式 (如果这个static final 不是通过方法或者构造器,则在链接阶段) 5）赋值的阶段性问题 在链接阶段的准备环节赋值的情况: 1、对于基本数据类型的字段来说,如果使用static final修饰,则显式赋值(直接赋值常量,而非调用方法)通常是在链接阶段的准备环节进行 2、对于String来说,如果使用字面量的方式赋值,使用static final修饰的话,则显式赋值通常是在链接阶段的准备环节进行 3、使用static + final修饰,且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值,是在链接阶段的准备环节进行。 在初始化阶段()中赋值的情况: 排除上述的在准备环节赋值的情况之外的情况 类加载器 引导(启动)类加载器这个类加载使用C&#x2F;C++语言实现的,嵌套在JVM内部 1、它用来加载Java的核心类库(JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resource.jar或sum.boot.class.path路径下的内容) 用于提供JVM自身需要的类(String类就是使用的这个类加载器) 2、由于安全考虑,Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 3、并不继承自java.lang.ClassLoader,没有父加载器 4、加载扩展类和应用程序类加载器,并指定为他们的父类加载器 自定义加载器****（将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器） 1、Java语言编写 2、派生于ClassLoader类,父类加载器为启动类加载器 3、从java.ext.dirs系统属性所指定的目录中加载类库,或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录(扩展目录)下加载类库。 如果用户创建的JAR放在此目录下,也会自动由扩展类加载器加载 扩展类加载器1、Java语言编写 2、派生于ClassLoader类,父类加载器为启动类加载器 3、从java.ext.dirs系统属性所指定的目录中加载类库,或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录(扩展目录)下加载类库 如果用户创建的JAR放在此目录下,也会自动由扩展类加载器加载 应用程序(系统)类加载器 AppClassLoader1、java语言编写 2、派生于ClassLoader类,父类加载器为扩展类加载器 3、它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库 4、该类加载是程序中默认的类加载器 5、通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器 用户自定义类加载器目的隔离记载类 修改类的加载方式 扩展加载源 防止源码泄露 方法1）重写 loadClass() 方法（不推荐,这个方法会保证类的双亲委派机制） 2）重写 findClass() 方法 –&gt;推荐 这两种方法本质上差不多,毕竟loadClass()也会调用findClass(),但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法,根据参数指定类的名字,返回对应的Class对象的引用 获取ClassLoader的方法 ​ 双亲委派机制java虚拟机对class文件采用按需加载的方式进行加载，当需要使用该类时才会将它的class文件加载到内存中生成class对象 在加载这个类的时候，采用的就是双亲委派模式。 1、如果 一个类加载收到了类加载请求,它并不会自己先去加载 ,而是把这个请求 委托给父类加载器去执行 2、如果 父类加载器还存在其父类加载器 ,则进一步 向上委托 ,依次递归,请求最终将 到达顶层的启动类加载器 3、如果父类的加载器可以完成类的加载任务,就成功返回,倘若 父类加载器无法完成此加载任务,子加载器才会尝试自己去加载, 这就是双亲委派模式 ​ 源码分析（双亲委派机制在 java.lang.ClassLoader.loadClass(String,boolean) 中体现） 1、先在当前加载器的缓存中*查找有无目标类,如果有,直接返回。* 2、判断当前加载器的父加载器是否为空 ,如果不为空,则调用 parent.loadClass(name, false) 接口进行加载 3、反之,如果当前加载器的父类加载器为空,则调用 findBootstrapClassOrNull(name) 接口,让引导类加载器进行加载 4、如果通过以上3条路径都没能成功加载,则调用 findClass(name) 接口进行加载。该接口最终会调用 java.lang.ClassLoader 接口的 defineClass 系列的native接口加载目标Java类。 双亲委派的模型就隐藏在这第2和第3步中 双亲委派机制的优势1、避免类的重复加载，确保一个类的全局唯一性（当父ClassLoader已经加载了该类的时候,就没有必要子ClassLoader再加载一次） 2、保护程序的安全，防止API随意被篡改 沙箱安全机制Java代码限定在虚拟机JVM特定的运行范围中，并且严格限制代码对本地资源的访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏 ​ 类的使用方式java虚拟机在每个类或接口被java程序“首次主动使用”时才初始化它们。被动使用不会初始化类，但又可能会加载类 在加载的过程中，遇到.class文件的缺失或者存在错误，类加载器只会在首次主动使用它们时才会报错，如果一直没使用，则不会报错 主动使用1、创建类的实例 2、访问某个类或接口的静态变量，或者对该静态变量赋值 3、调用类的静态方法 4、反射 5、初始化一个类的子类 6、java虚拟机启动时被标明为启动类的类 注意： 初始化一个类的子类这条规则，不适用于接口，即：初始化一个类的子类，会先初始化它的父类，但是不一定会初始化它的接口。只有当首次使用该接口的静态变量时，才会初始化。 被动使用除了主动使用的其他使用方式，例如： 1）通过子类引用父类的静态字段，为子类的被动使用，不会导致子类初始化 2）通过数组定义类引用类，为类的被动使用，不会触发此类的初始化 ​ 3）常量在编译阶段会存入调用方法所在的类的常量池中（这个例子存在F类的常量池中） 本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化","categories":[{"name":"底层源码","slug":"底层源码","permalink":"http://example.com/categories/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"}]},{"title":"01-什么是JVM?","slug":"01-什么是JVM","date":"2022-07-10T12:25:14.000Z","updated":"2022-07-11T00:49:41.731Z","comments":true,"path":"2022/07/10/01-什么是JVM/","link":"","permalink":"http://example.com/2022/07/10/01-%E4%BB%80%E4%B9%88%E6%98%AFJVM/","excerpt":"","text":"什么是JVM？①. JVM 是 java虚拟机，是用来执行java字节码(二进制的形式)的虚拟计算机 ②. jvm是运行在操作系统之上的，与硬件没有任何关系 Java的跨平台及原理①. 跨平台：由Java编写的程序可以在不同的操作系统上运行：一次编写，多处运行 ②. 原理：编译之后的字节码文件和平台无关，需要在不同的操作系统上安装一个对应版本的虚拟机(JVM) JVM的整体的理解①. 类加载子系统 ②. 运行时数据区(我们核心关注这里 的栈、堆、方法区) ③. 执行引擎(一般都是JIT编译器和解释器共存) java代码执行流程​ java源码—java编译器—生成字节码—进入java虚拟机（类加载器—字节码校验器—翻译字节码—JIT编译器） JVM的架构模型Java编译器输入的指令流基木上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。 基于栈式架构的特点 跨平台性 指令集小 指令多 执行性能比寄存器差 基于寄存器架构的特点 指令集架构则完全依赖硬件，可移植性差 性能优秀和执行更高效 举例 同样执行2+3这种逻辑操作，其指令分别如下： 1、基于栈的计算流程（以Java虚拟机为例) 2、基于寄存器的计算流程 总结 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。 JVM的生命周期虚拟机的启动 Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。 虚拟机的执行 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。 程序开始执行时他才运行，程序结束时他就停止。 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。 虚拟机的退出 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统用现错误而导致Java虚拟机进程终止 某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。 除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。","categories":[{"name":"底层源码","slug":"底层源码","permalink":"http://example.com/categories/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"}]}],"categories":[{"name":"底层源码","slug":"底层源码","permalink":"http://example.com/categories/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"}]}