{"meta":{"title":"Z.yang","subtitle":"Z.yang的博客","description":"欢迎访问Z.yang的博客","author":"Z.yang","url":"http://www.hzzzzzy.icu","root":"/"},"pages":[{"title":"关于我","date":"2022-07-10T01:26:06.000Z","updated":"2022-07-10T01:59:51.459Z","comments":true,"path":"about/index.html","permalink":"http://www.hzzzzzy.icu/about/index.html","excerpt":"","text":"Z.yang“ 认识自我，超越自我 “ 那么你就离成功更进了一步 联系我​ QQ：&#x32;&#x39;&#x33;&#57;&#x32;&#x39;&#52;&#56;&#x35;&#52;&#64;&#x71;&#113;&#x2e;&#99;&#x6f;&#109;​ WeChat：https://postimg.cc/N2RP6f9K​ Outlook：&#x68;&#122;&#x7a;&#122;&#x7a;&#122;&#x79;&#64;&#111;&#117;&#116;&#x6c;&#x6f;&#111;&#107;&#46;&#99;&#x6f;&#109;"},{"title":"相关链接整理","date":"2022-07-09T08:00:38.000Z","updated":"2022-07-14T08:54:03.684Z","comments":true,"path":"link/index.html","permalink":"http://www.hzzzzzy.icu/link/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-09T07:59:10.000Z","updated":"2022-07-10T01:13:31.420Z","comments":true,"path":"categories/index.html","permalink":"http://www.hzzzzzy.icu/categories/index.html","excerpt":"","text":""},{"title":"Zyang的标签页","date":"2022-07-09T07:56:18.000Z","updated":"2022-07-09T08:05:44.554Z","comments":true,"path":"tags/index.html","permalink":"http://www.hzzzzzy.icu/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"spring源码-2-Bean的生命周期","slug":"spring源码-2-Bean的生命周期","date":"2022-07-15T01:51:36.000Z","updated":"2022-07-15T08:43:50.530Z","comments":true,"path":"2022/07/15/spring源码-2-Bean的生命周期/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/15/spring%E6%BA%90%E7%A0%81-2-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"bean生命周期 在各个阶段里都会有由bean后处理器提供的功能增强 bean的后处理器 创建前后的增强 postProcessBeforeInstantiation 这里返回的对象若不为 null 会替换掉原本的 bean，并且仅会走 postProcessAfterInitialization 流程 postProcessAfterInstantiation 这里如果返回 false 会跳过依赖注入阶段 依赖注入前的增强 postProcessProperties 如 @Autowired、@Value、@Resource 初始化前后的增强 postProcessBeforeInitialization 这里返回的对象会替换掉原本的 bean 如 @PostConstruct、@ConfigurationProperties postProcessAfterInitialization 这里返回的对象会替换掉原本的 bean 如代理增强 销毁之前的增强 postProcessBeforeDestruction 如 @PreDestroy 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Componentpublic class MyBeanPostProcessor implements InstantiationAwareBeanPostProcessor, DestructionAwareBeanPostProcessor &#123; private static final Logger log = LoggerFactory.getLogger(MyBeanPostProcessor.class); //postProcessBeforeDestruction：在销毁之前执行 bean 后处理器 @Override public void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException &#123; if (beanName.equals(&quot;lifeCycleBean&quot;)) log.debug(&quot;&lt;&lt;&lt;&lt;&lt;&lt; 销毁之前执行, 如 @PreDestroy&quot;); &#125; //postProcessBeforeInstantiation：在实例化之前执行 @Override public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123; if (beanName.equals(&quot;lifeCycleBean&quot;)) log.debug(&quot;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之前执行, 这里返回的对象会替换掉原本的 bean&quot;); return null; &#125; //postProcessAfterInstantiation：实例化之后执行，如果返回 false 会跳过依赖注入阶段，返回true则不会跳过 @Override public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException &#123; if (beanName.equals(&quot;lifeCycleBean&quot;)) &#123; log.debug(&quot;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之后执行&quot;); &#125; return true; &#125; //postProcessProperties：依赖注入阶段执行 @Override public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException &#123; if (beanName.equals(&quot;lifeCycleBean&quot;)) log.debug(&quot;&lt;&lt;&lt;&lt;&lt;&lt; 依赖注入阶段执行, 如 @Autowired、@Value、@Resource&quot;); return pvs; &#125; //postProcessBeforeInitialization：初始化之前执行 @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; if (beanName.equals(&quot;lifeCycleBean&quot;)) log.debug(&quot;&lt;&lt;&lt;&lt;&lt;&lt; 初始化之前执行, 这里返回的对象会替换掉原本的 bean, 如 @PostConstruct、@ConfigurationProperties&quot;); return bean; &#125; //postProcessAfterInitialization：初始化之后执行 @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if (beanName.equals(&quot;lifeCycleBean&quot;)) log.debug(&quot;&lt;&lt;&lt;&lt;&lt;&lt; 初始化之后执行, 这里返回的对象会替换掉原本的 bean, 如代理增强&quot;); return bean; &#125;&#125; 模板方法设计模式12345678910111213141516171819202122232425public static void main(String[] args) &#123; MyBeanFactory beanFactory = new MyBeanFactory(); beanFactory.addBeanPostProcessor(bean -&gt; System.out.println(&quot;解析 @Autowired&quot;)); beanFactory.addBeanPostProcessor(bean -&gt; System.out.println(&quot;解析 @Resource&quot;)); beanFactory.getBean();&#125;static class MyBeanFactory &#123; public Object getBean() &#123; Object bean = new Object(); System.out.println(&quot;构造 &quot; + bean); System.out.println(&quot;依赖注入 &quot; + bean); // @Autowired, @Resource for (BeanPostProcessor processor : processors) &#123; processor.inject(bean); &#125; System.out.println(&quot;初始化 &quot; + bean); return bean; &#125; private List&lt;BeanPostProcessor&gt; processors = new ArrayList&lt;&gt;(); //后处理器集合 public void addBeanPostProcessor(BeanPostProcessor processor) &#123;processors.add(processor);&#125;&#125;static interface BeanPostProcessor &#123; public void inject(Object bean); // 对依赖注入阶段的扩展&#125; Bean后处理器 前言： 1、先创建一个干净容器 1GenericApplicationContext context = new GenericApplicationContext(); 2、用原始形式注入bean 123context.registerBean(&quot;bean1&quot;, Bean1.class);context.registerBean(&quot;bean2&quot;, Bean2.class);context.registerBean(&quot;bean3&quot;, Bean3.class); 3、利用后处理器进行加载测试4、初始化容器，并打印 123//执行beanFactory后处理器, 添加bean后处理器, 初始化所有单例context.refresh();System.out.println(context.getBean(Bean1.class)); 5、销毁容器 1context.refresh(); AutowiredAnnotationBeanPostProcessor后处理器在依赖注入阶段，解析@Autowired和@Value注解 123456//解析@Value注解的值注入问题，暂时不要求掌握context.getDefaultListableBeanFactory() .setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());//解析@Autowired @Valuecontext.registerBean(AutowiredAnnotationBeanPostProcessor.class); 运行过程分析执行依赖注入的 postProcessProperties 方法 1234567891011121314// 1. 查找哪些属性、方法加了 @Autowired, 这称之为 InjectionMetadata AutowiredAnnotationBeanPostProcessor processor = new AutowiredAnnotationBeanPostProcessor(); processor.setBeanFactory(beanFactory); Bean1 bean1 = new Bean1(); Method findAutowiringMetadata = AutowiredAnnotationBeanPostProcessor.class.getDeclaredMethod(&quot;findAutowiringMetadata&quot;, String.class, Class.class, PropertyValues.class); findAutowiringMetadata.setAccessible(true); //2、获取 Bean1 上加了 @Value @Autowired 的成员变量，方法参数信息 InjectionMetadata metadata = (InjectionMetadata) findAutowiringMetadata.invoke(processor, &quot;bean1&quot;, Bean1.class, null); System.out.println(metadata); //3、调用 InjectionMetadata 来进行依赖注入, 注入时按类型查找值 metadata.inject(bean1, &quot;bean1&quot;, null); System.out.println(bean1); 1234567891011121314151617181920212223//4、inject内部//4.1、成员变量注入Field bean3 = Bean1.class.getDeclaredField(&quot;bean3&quot;);//将成员变量信息进行封装DependencyDescriptor dd1 = new DependencyDescriptor(bean3, false);//根据成员变量信息得到类型，进行根据类型找到容器中符合此类型中的一个beanObject o = beanFactory.doResolveDependency(dd1, null, null, null);System.out.println(o);//4.2、方法注入Method setBean2 = Bean1.class.getDeclaredMethod(&quot;setBean2&quot;, Bean2.class);//将方法进行封装（以参数为单位进行封装，此处的0指的是第一个参数）DependencyDescriptor dd2 = new DependencyDescriptor(new MethodParameter(setBean2, 0), true);//根据方法参数的类型在容器中找到符合此类型的beanObject o1 = beanFactory.doResolveDependency(dd2, null, null, null);System.out.println(o1);//4.3、值注入Method setHome = Bean1.class.getDeclaredMethod(&quot;setHome&quot;, String.class);DependencyDescriptor dd3 = new DependencyDescriptor(new MethodParameter(setHome, 0), true);Object o2 = beanFactory.doResolveDependency(dd3, null, null, null);System.out.println(o2); 总结： AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata 用来获取某个 bean 上加了 @Value @Autowired 的成员变量，方法参数的信息，表示为 InjectionMetadata InjectionMetadata 可以完成依赖注入 InjectionMetadata 内部根据成员变量，方法参数封装为 DependencyDescriptor 类型 有了 DependencyDescriptor，就可以利用 beanFactory.doResolveDependency 方法进行基于类型的查找 CommonAnnotationBeanPostProcessor后处理器依赖注入阶段解析@Resource，初始化前解析@PostConstruct，销毁前@PreDestroy注解 1context.registerBean(CommonAnnotationBeanPostProcessor.class); ConfigurationPropertiesBindingPostProcessor后处理器初始化前@ConfigurationProperties 1ConfigurationPropertiesBindingPostProcessor.register(context.getDefaultListableBeanFactory()); BeanFactory后处理器ConfigurationClassPostProcessor后处理器可以用来解析@ComponentScan、@Bean、@Import、@ImportResource注解 1context.registerBean(ConfigurationClassPostProcessor.class); MapperScannerConfigurer后处理器解析@MapperScanner注解 123context.registerBean(MapperScannerConfigurer.class, bd -&gt; &#123; bd.getPropertyValues().add(&quot;basePackage&quot;, &quot;com.itheima.a05.mapper&quot;);&#125;); 模拟实现@Component注解@Component的模拟实现（点我）","categories":[{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/categories/spring%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"},{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/tags/spring%E9%AB%98%E7%BA%A7/"}]},{"title":"spring源码-1-BeanFactory与ApplicationContext","slug":"spring源码-1-BeanFactory与ApplicationContext","date":"2022-07-14T23:12:38.000Z","updated":"2022-07-15T01:51:03.762Z","comments":true,"path":"2022/07/15/spring源码-1-BeanFactory与ApplicationContext/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/15/spring%E6%BA%90%E7%A0%81-1-BeanFactory%E4%B8%8EApplicationContext/","excerpt":"","text":"BeanFactory1、它是ApplicationContext的父接口 2、它才是Spring的核心容器，主要的ApplicationContext的实现都组合了它的功能 比如使用ApplicationContext的getBean方法，实际上先拿到BeanFactory对象，再去调用BeanFactory的getBean方法 3、BeanFactory表面上只有getBean功能实际上，控制反转，基本的依赖注入，直至Bean的生命周期都是由它的实现类提供 ApplicationContext功能 1、MessageSource：处理国际化资源的能力（翻译） 比如 getMessage方法 2、RessourcePatternResolver：通配符匹配资源的能力 比如 getResources方法 1234567//表示在resources目录下的META-INF子目录下的spring.factories文件和jar包内的......//*号表示也可以jar内进行搜索Resource[] resources = context.getResources(&quot;classpath*:META-INF/spring.factories&quot;);for (Resource resource : resources) &#123; System.out.println(resource);&#125; 3、ApplicationEventPublisher：发布事件能力 比如 publishEvent方法 1234567891011121314151617181920//获取Component1然后进行注册context.getBean(Component1.class).register();//在Component1中进行声明private static final Logger log = LoggerFactory.getLogger(Component1.class);//该容器对象具备发送事件的功能@Autowiredprivate ApplicationEventPublisher context; //事件发生器public void register() &#123; log.debug(&quot;用户注册&quot;); context.publishEvent(new UserRegisteredEvent(this));&#125;//在Component2中监听该事件private static final Logger log = LoggerFactory.getLogger(Component2.class);@EventListenerpublic void aaa(UserRegisteredEvent event) &#123; log.debug(&quot;&#123;&#125;&quot;, event); log.debug(&quot;发送短信&quot;);&#125; 4、EnvironmentCapable：读取环境信息 比如getProperty方法 123//获取properties文件和系统环境变量对应键的值System.out.println(context.getEnvironment().getProperty(&quot;java_home&quot;));System.out.println(context.getEnvironment().getProperty(&quot;server.port&quot;)); BeanFactory的实现1、给Bean添加定义并进行注册123456DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();// bean 的定义（class, scope, 初始化, 销毁）AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope(&quot;singleton&quot;).getBeanDefinition();//注册beanFactory.registerBeanDefinition(&quot;config&quot;, beanDefinition); 2、添加 BeanFactory 后处理器1234567891011121314151617181920212223242526272829303132333435363738394041424344// 给 BeanFactory 添加一些常用的后处理器AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);//如果只是添加后处理器不进行扩展，则无法解析@Confident和@bean注解// BeanFactory 后处理器主要功能，补充了一些 bean 定义// getBeansOfType 根据类型获取多个bean（bean后处理器）beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values().forEach(beanFactoryPostProcessor -&gt; &#123; beanFactoryPostProcessor.postProcessBeanFactory(beanFactory); //执行beanFactory 后处理器&#125;);@Configuration static class Config &#123; @Bean public Bean1 bean1() &#123;return new Bean1();&#125; @Bean public Bean2 bean2() &#123;return new Bean2();&#125; @Bean public Bean3 bean3() &#123;return new Bean3();&#125; @Bean public Bean4 bean4() &#123;return new Bean4();&#125; &#125; interface Inter &#123; &#125; static class Bean3 implements Inter &#123; &#125; static class Bean4 implements Inter &#123; &#125; static class Bean1 &#123; private static final Logger log = LoggerFactory.getLogger(Bean1.class); public Bean1() &#123; log.debug(&quot;构造 Bean1()&quot;); &#125; @Autowired private Bean2 bean2; public Bean2 getBean2() &#123;return bean2;&#125; //同时添加两个注解（后处理器的顺序决定了哪个先被解析） @Autowired @Resource(name = &quot;bean4&quot;) private Inter bean3; public Inter getInter() &#123;return bean3;&#125;&#125; static class Bean2 &#123; private static final Logger log = LoggerFactory.getLogger(Bean2.class); public Bean2() &#123; log.debug(&quot;构造 Bean2()&quot;); &#125; &#125; 3、添加 Bean 后处理器12345// Bean 后处理器, 针对 bean 的生命周期的各个阶段提供扩展, 例如 @Autowired @Resource ...beanFactory.getBeansOfType(BeanPostProcessor.class).values().stream() .forEach(beanPostProcessor -&gt; &#123; beanFactory.addBeanPostProcessor(beanPostProcessor); //建立Bean工厂和后处理器的关系&#125;); 4、后处理器器顺序123//默认是Common的后处理器排在前面，Autowired的排在后面System.out.println(&quot;Common:&quot; + (Ordered.LOWEST_PRECEDENCE - 3));System.out.println(&quot;Autowired:&quot; + (Ordered.LOWEST_PRECEDENCE - 2)); 总结BeanFactory总结： 不会主动调用 BeanFactory 后处理器 不会主动添加 Bean 后处理器 不会主动初始化单例 不会解析beanFactory 还不会解析 ${ } 与 #{ } Bean后处理器会有排序的逻辑 ApplicationContext的实现1、ClassPathXmlApplicationContext在类路径下读取XML配置文件 1234567891011121314private static void testClassPathXmlApplicationContext() &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;a02.xml&quot;); for (String name : context.getBeanDefinitionNames()) &#123; System.out.println(name); &#125; System.out.println(context.getBean(Bean2.class).getBean1()); /** * 结果： * bean1 * bean2 * com.itheima.a02.A02$Bean1@6392827e */&#125; 1234567//a02.xml&lt;!-- 控制反转, 让 bean1和bean2 被 Spring 容器管理 --&gt;&lt;bean id=&quot;bean1&quot; class=&quot;com.itheima.a02.A02.Bean1&quot;/&gt;&lt;bean id=&quot;bean2&quot; class=&quot;com.itheima.a02.A02.Bean2&quot;&gt; &lt;!-- 依赖注入, 让 bean2 建立与 bean1 的依赖关系 --&gt; &lt;property name=&quot;bean1&quot; ref=&quot;bean1&quot;/&gt;&lt;/bean&gt; 2、FileSystemXmlApplicationContext在磁盘路径下读取XML配置文件 1234private static void testFileSystemXmlApplicationContext() &#123; FileSystemXmlApplicationContext context = new FileSystemXmlApplicationContext(&quot;src\\\\main\\\\resources\\\\a02.xml&quot;);&#125; 3、AnnotationConfigApplicationContext基于java配置类来完成 1234567891011121314151617181920212223242526private static void testAnnotationConfigApplicationContext() &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Config.class);&#125;@Configurationstatic class Config &#123; @Bean public Bean1 bean1() &#123;return new Bean1();&#125; @Bean public Bean2 bean2(Bean1 bean1) &#123; Bean2 bean2 = new Bean2(); bean2.setBean1(bean1); return bean2; &#125;&#125;static class Bean1 &#123; &#125;static class Bean2 &#123; private Bean1 bean1; public void setBean1(Bean1 bean1) &#123; this.bean1 = bean1; &#125; public Bean1 getBean1() &#123; return bean1; &#125;&#125; 4、AnnotationConfigServletWebServerApplicationContext基于 java 配置类来创建，用于 web 环境 1234567private static void testAnnotationConfigServletWebServerApplicationContext() &#123; AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext(WebConfig.class); for (String name : context.getBeanDefinitionNames()) &#123; System.out.println(name); &#125;&#125; 123456789101112131415161718@Configurationstatic class WebConfig &#123; @Bean //产生内嵌的 tomcat 容器 public ServletWebServerFactory servletWebServerFactory()&#123;return new TomcatServletWebServerFactory();&#125; @Bean //创建 dispatcherServlet 对象 public DispatcherServlet dispatcherServlet() &#123;return new DispatcherServlet();&#125; @Bean //将 dispatcherServlet 注册到tomcat容器中 public DispatcherServletRegistrationBean registrationBean(DispatcherServlet dispatcherServlet) &#123; return new DispatcherServletRegistrationBean(dispatcherServlet, &quot;/&quot;); &#125; @Bean(&quot;/hello&quot;) public Controller controller1() &#123; return (request, response) -&gt; &#123; response.getWriter().print(&quot;hello&quot;); return null; &#125;; &#125;&#125;","categories":[{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/categories/spring%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"},{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/tags/spring%E9%AB%98%E7%BA%A7/"}]},{"title":"09-对象的实例化，内存布局和访问定位","slug":"09-对象的实例化，内存布局和访问定位","date":"2022-07-14T08:02:22.000Z","updated":"2022-07-14T14:28:39.736Z","comments":true,"path":"2022/07/14/09-对象的实例化，内存布局和访问定位/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/14/09-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%8C%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"对象实例化与创建对象实例化的概述（点我） 测试对象实例化的过程 ①加载类元信息 ②为对象分配内存 ③处理并发问题 ④属性的默认初始化（零值初始化） ⑤设置对象头信息 ⑥属性的显示初始化、代码块中初始化、构造器中初始化 创建的过程（字节码角度） 对象的内存布局内存布局（点我） 对象的访问定位对象访问定位概述（点我）","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"08-方法区","slug":"08-方法区","date":"2022-07-14T06:34:12.000Z","updated":"2022-07-14T08:56:23.555Z","comments":true,"path":"2022/07/14/08-方法区/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/14/08-%E6%96%B9%E6%B3%95%E5%8C%BA/","excerpt":"","text":"方法区的演变 只有HotSpot虚拟机才有永久代 1、jdk1.6之前：又永久代，静态变量存储在永久代上 2、jdk1.7：又永久代，字符串常量池，静态变量移除，保存在堆中 3、jdk1.8以后：无永久代，类型信息、字段、方法、常量池保存在本地内存的元空间，但字符串常量池，静态变量仍在堆 永久代为什么要被元空间替换？1、为永久代设置空间大小是很难确定的如果动态加载类过多，容易产生永久代的OOM，而元空间使用本地内存，只受本地内存的影响 2、对永久代调优困难 字符串常量池为什么要放到堆空间？因为永久代的回收率很低，在进行full GC的时候才会触发，而full GC是老年代空间不足、永久代不足时才会触发，所以导致回收效率不高。但是实际中又有大量字符会被创建，回收效率低导致永久代空间不足。放到堆里，可以及时回收。 方法区的概述1、方法区在JVM启动的时候被创建，它的实际的物理内存空间可以是不连续的（关闭 JVM 就会释放这个区域的内存） 2、方法区时逻辑上是堆的一个组成部分，但是在不同虚拟机里头实现是不一样的，最典型的就是永久代(PermGen space)和元空间(Metaspace)（注意：方法区是一种规范，而永久代和元空间是它的一种实现方式） 3、方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类,导致方法区溢出，虚拟机同样会抛出内存溢出错误：(java.lang.OutOfMemoryError:PermGen space、java.lang.OutOfMemoryError:Metaspace) 加载过多的jar包 tomcat部署的过程过多 反射类太多 4、jdk7及以前，将方法区的实现称为永久代，jdk8之后，使用元空间取代了永久代 5、元空间和永久代的区别：元空间不在虚拟机设置的内存中，而是使用本地内存 设置方法区大小与OOMjdk7及以前 -XX:PermSize=100m（默认值是20.75M） -XX:MaxPermSize=100m（32位机器默认是64M，64位是82M） jdk1.8及以后 -XX:MetaspaceSize=100m（windows默认约等于21M） -XX:MaxMetaspaceSize=100m（默认是-1,即没有限制） 方法区的内部结构存储已被虚拟机记载的类型信息、常量、静态变量、即时编译器编译后的代码缓存、域信息、方法信息 类型信息对每个加载的类型（类，接口，枚举，注解）JVM 必须在方法区中存储以下类型信息 1、类型的完整有效名称（全名&#x3D;包名.类名） 2、直接父类的完整有效名（接口和Object类没有） 3、修饰符 4、直接接口的一个有序列表 域信息域名称，域修饰符（public，private……），域类型 方法信息1、方法名称 2、方法返回类型 3、方法参数的数量和类型（按顺序） 4、方法的字节码，操作数栈和局部变量表的大小 non-final的类变量1、静态变量和类关联在一起，随着类的加载而加载 2、类变量被所有类的实例共享，即使没有类实例也可以访问它 以下代码不会报空指针异常 123456789101112131415public class MethodAreaTest &#123; public static void main(String[] args) &#123; Order order = null; order.hello(); System.out.println(order.count); &#125;&#125;class Order &#123; public static int count = 1; public static final int number = 2; public static void hello() &#123; System.out.println(&quot;hello!&quot;); &#125;&#125; 全局常量：static final每个全局常量在编译的时候就会被分配 常量池与运行时常量池方法区内部包含了运行时常量池 字节码文件中包含了常量池 当类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址 常量池的理解常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型、字面量等信息（主要是字面量和符号引用） 一个 java 程序编译生成字节码文件后，字节码文件需要大量数据支持进行解析，如果将数据直接存进字节码，文件过大所以将数据存进常量池，字节码中包含了指向常量池的引用 运行时常量池字节码文件中的常量池表经过类加载器放到方法区后，对应的结构就称为运行时常量池 当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址 注意： 1、运行时常量池是方法区的一部分。 2、运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用 此时不再是常量池中的符号地址了，这里换为真实地址。 3、运行时常量池相较于Class文件中的常量池的特征：动态性 4、符号地址变为真实地址其实就是，在*.class文件被加载到内存以后，将*.class文件中常量池中的#x符号地址，转化为内存中的地址。 方法区的垃圾收集 前言： 方法区内常量池之中主要存放的两大类常量：字面量和符号引用。 字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。 符号引用则属于编译原理方面的概念，包括 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 方法区中主要回收 1、常量池中废弃的常量 2、不再使用的类型 只要常量池中的常量没有被任何地方引用，就可以被回收（与堆中回收对象类似） 判断一个类是否要进行回收（*）","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"3-nginx-静态资源部署","slug":"3-nginx-静态资源部署","date":"2022-07-13T13:21:21.000Z","updated":"2022-07-13T13:31:08.808Z","comments":true,"path":"2022/07/13/3-nginx-静态资源部署/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/13/3-nginx-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2/","excerpt":"","text":"静态资源的配置指令listen指令： 用来配置监听端口 default_server属性是标识符，用来将此虚拟主机设置成默认主机 所谓的默认主机指的是如果没有匹配到对应的address:port，则会默认执行的。 如果不指定默认使用的是第一个server server_name指令：用来设置虚拟主机服务名称 三种匹配方式：精确匹配、通配符匹配、正则表达式匹配 精确匹配 域名是要收取一定的费用，所以可以使用修改hosts文件来制作一些虚拟域名来使用。需要修改 /etc/hosts 文件来添加 通配符匹配server_name中支持通配符”*“,但需要注意的是通配符不能出现在域名的中间，只能出现在首段或尾段 (*)代表任意字符 正则表达式匹配server_name中可以使用正则表达式，并且使用 ~ 作为正则表达式字符串的开始标记 括号取值 匹配执行顺序1、准确匹配 2、通配符在开始时匹配 3、通配符在结束时匹配 4、正则表达式匹配 5、被默认的default_server处理，如果没有指定默认找第一个server","categories":[{"name":"nginx","slug":"nginx","permalink":"http://www.hzzzzzy.icu/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.hzzzzzy.icu/tags/nginx/"}]},{"title":"2-nginx-配置到系统服务和系统环境","slug":"2-nginx-配置到系统服务和系统环境","date":"2022-07-13T13:06:05.000Z","updated":"2022-07-13T13:10:46.355Z","comments":true,"path":"2022/07/13/2-nginx-配置到系统服务和系统环境/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/13/2-nginx-%E9%85%8D%E7%BD%AE%E5%88%B0%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83/","excerpt":"","text":"一、将nginx配置到系统服务1、在 /usr/lib/systemd/system 目录下添加nginx.service,内容如下 12345678910111213141516[Unit]Description=nginx web serviceDocumentation=http://nginx.org/en/docs/After=network.target[Service]Type=forkingPIDFile=/usr/local/nginx/logs/nginx.pidExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.confExecStart=/usr/local/nginx/sbin/nginxExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s stopPrivateTmp=true[Install]WantedBy=default.target 2、添加完成后如果权限有问题需要进行权限设置 1chmod 755 /usr/lib/systemd/system/nginx.service 3、使用系统命令来操作Nginx服务 二、将nginx命令配置到系统环境1、修改 /etc/profile 文件 123vim /etc/profile在最后一行添加export PATH=$PATH:/usr/local/nginx/sbin 2、使配置立即生效 1source /etc/profile","categories":[{"name":"nginx","slug":"nginx","permalink":"http://www.hzzzzzy.icu/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.hzzzzzy.icu/tags/nginx/"}]},{"title":"07-堆","slug":"07-堆","date":"2022-07-13T00:46:19.000Z","updated":"2022-07-13T11:59:26.367Z","comments":true,"path":"2022/07/13/07-堆/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/13/07-%E5%A0%86/","excerpt":"","text":"堆的核心概述一个进程对应一个JVM实例，一个JVM实例中有一个运行时数据区，一个运行时数据区中只有一个堆空间 进程中的多个线程各自拥有一套程序计数器，本地方法栈，虚拟机栈，但是多个线程共享同一个堆空间 一个JVM实例只存在一个堆内存，堆是Java内存管理的核心区域 堆区在JVM启动的时候就被创建，其空间大小也确定了（JVM管理的最大一块内存区域，大小可调节） 堆可以处于物理上不连续的内存空间，但在逻辑上它应该被视为连续的 多个线程共享一个堆区，容易造成并发性能差的问题，所以堆划分出线程私有的缓冲区，每个线程占一份 几乎所有的对象实例都在这里分配内存 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，指向对象或数组在堆中的位置 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾回收的时候会被移除（只是移除了方法区指向堆空间的索引，如果方法结束就移除堆中的对象的话，当方法多次调用时，会因为多次 GC而影响系统性能） 123456789101112public class SimpleHeap &#123; private int id; public SimpleHeap(int id) &#123;this.id = id;&#125; public void show() &#123; System.out.println(&quot;My ID is &quot; + id); &#125; public static void main(String[] args) &#123; SimpleHeap sl = new SimpleHeap(1); SimpleHeap s2 = new SimpleHeap(2); &#125;&#125; 堆内存结构概述和OOM堆空间细分为 JDK 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区 JDK 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间 新生区&lt;&#x3D;&gt;新生代&lt;&#x3D;&gt;年轻代 养老区&lt;&#x3D;&gt;老年区&lt;&#x3D;&gt;老年代 永久代&lt;&#x3D;&gt;永久区 堆空间大小的设置 -Xms -Xmx-Xms（默认：物理内存的1&#x2F;64）：表示堆空间（新生代＋老年代）的起始内存 -Xmx（默认：物理内存的1&#x2F;4）：则用于表示堆空间的最大内存 通常会将-Xms和-Xmx两个参数配置相同的值，目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提升性能 新生代与老年代堆区可细分为新生代和老年代，新生代又可划分为Eden空间，Survivor1空间和Survivor2空间（from区，to区） 配置新生代和老年代在堆结构中的占比（一般不进行调整） 默认情况下 -XX:NewRatio=2，表示新生代占1，老年代占2，即新生代占整个堆的1&#x2F;3 配置年轻代中的Eden和Survivor区的比例 -XX:SurvivorRatio=8，表示调整这个空间比例（Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1） 配置新生代的空间的大小：-Xmn，一般不设置 几乎所有的Java对象都是在Eden区被new出来的，大部分的Java对象的销毁都在新生代进行的 对象分配一般过程 首先对象先存储到Eden区，当Eden区存满的时候，会触发Young GC（Minor GC），此时会把用户工作进程停止，称为STW（stop the world），然后判断Eden区里面哪些对象需要回收。（如图所示，红色为回收的对象） 然后将不需要回收的对象放到from区，并加上年龄计数器1 当from区存满的时候，如果对象还不需要回收，那么就会转入到to区，然后在年龄计数器上加上1，此时Eden里面不需要回收的对象也会存储在to区 此时，form区为空，from和 to区就互相转换 当年龄计数器上的值为阈值时（默认为15）对象就会转存到老年区 采用-XX:MaxTenuringThreshold，参数可以设置对象在经过多少次GC后会被放入老年代 实际上时对 Eden区到 Survivor区过度的一种策略，是为了保证 Eden区到 Survivor区不会频繁的进行复制一直存活的对象且对Survivor区也能保证不会具有太多的一直占据的内存 关于垃圾回收，频繁在新生区进行收集，很少在养老区收集，几乎不在永久区 &#x2F; 元空间收集 特殊过程当存在一个超大对象，导致Eden区放不下的时候，该对象则会直接放到老年区 如果老年区放不下： 如果老年区本来的空间够放得下该对象，但是一部分被占用了。则进行Full GC，之后如果空间还是放不下，则直接OOM 如果老年区本来的空间就放不下该对象，直接返回OOM GC关于HotSpot VM的实现，GC按照回收区域可以分为部分收集和整堆收集 一、部分收集（Partial GC）：不是完整收集整个Java堆的垃圾收集，其中分为 新生代收集（Minor GC &#x2F; Young GC）：只是新生代（Eden&#x2F;S0&#x2F;S1）的垃圾收集 老年代收集（Major GC &#x2F; Old GC）：只是老年代的垃圾收集 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集 二、整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集 注意： 1、目前只有CMS GC会有单独收集老年代的行为 2、很多时候Major GC会和Full GC一起混合使用，需要具体分辨是老年代回收还是整堆回收 新生代GC（Minor GC）触发机制当新生代空间不足时，就会触发，这里的新生代空间不足指的是Eden区已满 注意： Survivor满不会引发GC（每次Minor GC都会清理新生代的内存） Minor GC非常频繁，回收速度较快 会引发STW 老年代GC（Major GC &#x2F; Full GC）触发机制当发生在老年代的GC，对象从老年代消失时，我们说老年代GC触发了 注意： 当老年代空间不足时，会尝试先触发Minor GC。如果之后空间还不足，则触发Major GC Major GC的速度比Minor GC满10倍以上，STW时间更长 Major GC后，如果内存还是不足，直接返回OOM Full GC触发机制（*）1、调用 System.gc() 时，系统建议执行Full GC，但是不必然执行 2、老年代空间不足 3、方法区空间不足 ………… 堆空间分代的思想分代的唯一目的就是优化GC的性能 如果没有分代，那么所有的对象都在一块，当要进行GC的时候，判断哪些对象需要回收，哪些不需要的时候，就需要对整个空间进行扫描。如果进行分代处理的话，就可以把新创建的一些对象，放在同一块区域，GC的时候就可以针对性地进行搜索，而且还可以腾出一大块区域 内存分配策略 优先分配到Eden区 大对象直接分配到老年代 长期存活的对象分配到老年代 动态对象的年龄判断：如果Survivor区中相同年龄的所有对象的和大于其空间的一般，年龄大于或等于该年龄的对象直接进入老年代 空间分配担保（*） TLAB为对象分配内存为什么要有TLAB？1、对象的创建在JVM中很频繁，所以在并发环境下从堆区中划分内存空间是线程不安全的 2、为了避免多个线程操作同一个地址，需要加锁，从而影响分配的速度 什么是TLAB？1、在Eden区域进行划分，为每个线程分配了一个私有缓存的区域 2、多个线程共同操作时，可以避免线程安全问题，提升内存分配吞吐量 注意： 1、JVM将TLAB作为内存分配的首选 2、TLAB只占 Eden的1%，当对象在TLAB空间分配内存失败后，JVM在Eden直接分配内存，而且通过加锁来确保原子性 3、TLAB大小可以通过 -XX:TLABWasteTargetPercent + 参数进行设置 总结堆空间参数设置1、-XX:+PrintFlagsInitial : 查看所有的参数的默认初始值 2、-XX:+PrintFlagsFinal : 查看所有的参数的最终值(可能会存在修改(:表示修改了),不再是初始值) 3、具体查看某个参数的指令: jps:查看当前运行中的进程 jinfo -flag SurvivorRatio 进程id 4、-Xms:初始堆空间内存 (默认为物理内存的1&#x2F;64) 5、-Xmx:最大堆空间内存(默认为物理内存的1&#x2F;4) 6、-Xmn:设置新生代的大小。(初始值及最大值) 7、-XX:NewRatio:配置新生代与老年代在堆结构的占比 默认:-XX:NewRatio=2,表示新生代占1,老年代占2,新生代占整个堆的1&#x2F;3 可以修改-XX:NewRatio=4,表示新生代占1,老年代占4,新生代占整个堆的1&#x2F;5 8、-XX:SurvivorRatio:设置新生代中Eden和S0&#x2F;S1空间的比例(Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1) 9、-XX:MaxTenuringThreshold设置新生代垃圾的最大年龄 10、-XX:+PrintGCDetails:输出详细的GC处理日志(如下这两种方式是简单的打印 gc 简要信息： 1） -XX:+PrintGC *2） -verbose:gc* 11、-XX:HandlePromotionFailure:是否设置空间分配担保(JDK6之后,只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC,否则将进行Full GC) 逃逸分析概述将堆上的对象分配到栈，需要使用逃逸分析手段 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸 当一个对象在方法中被定义后，它被外部方法所引用,则认为发生逃逸。例如作为调用参数传递到其他地方中 其实就是看new出来的对象是否有可能在方法外被调用 12345678910111213141516171819public EscapeAnalysis object; /** * 方法返回 EscapeAnalysis 对象，发生逃逸 */ public EscapeAnalysis getInstance() &#123; return object == null ? new EscapeAnalysis() : object; &#125; /** * 对象的作用域仅在当前方法中有效，没有发生逃逸 */ public void useEscapeAnalysis1() &#123; EscapeAnalysis e = new EscapeAnalysis(); &#125; /** * 引用成员变量的值，发生逃逸 */ public void useEscapeAnalysis2() &#123; EscapeAnalysis instance = getInstance(); &#125; 在jdk7及之后，可以通过 1、-XX:+DoEscapeAnalysis 显式开启逃逸分析 2、通过 -XX:+PrintEscapeAnalysis 查看逃逸分析的筛选结果 代码优化栈上分配 成员变量赋值 方法返回值 实例引用传递 在开启逃逸分析后执行时间变，而且没有发生GC 12345678910111213141516171819202122//栈上分配测试//-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetailspublic static void main(String[] args) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10000000; i++) &#123; alloc(); &#125; //查看执行时间 long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间为：&quot;+(end-start)+&quot;ms&quot;); //为了方便查看堆内存中对象的个数，线程sleep try &#123; Thread.sleep(1000000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; private static void alloc() &#123; User user = new User(); //未发生逃逸 &#125; static class User &#123; 同步省略也叫做锁消除，指在动态编译同步块时，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能被一个线程访问而没有被发布到其他线程，如果没有，那么在编译这个同步块的时候，就会取消这部分代码的同步，大大提高并发性和性能。 代码中堆obj进行加锁，但是obj对象的生命周期只在test1方法中，并不会被其他线程访问到，所以在JIT编译阶段就会优化成test2的 12345678910public void test1() &#123; Object obj = new Object(); synchronized (obj) &#123; System.out.println(obj); &#125;&#125;public void test2() &#123; Object obj = new Object(); System.out.println(obj);&#125; 分离对象或标量替换标量：一个无法再分解成更小的数据的数据，如基本数据类型 聚合量：还可以继续分解的数据，如对象 如果一个对象不会被外界访问的话，经过JIT的优化，就会把对象拆解成若干个成员变量来替代，这就是标量替换 标量替换可以大大减少堆内存的占用，因为不需要创建对象，也就不需要分配堆内存 参数：-XX:+EliminateAllocations开启标量替换，允许将对象打散分配在栈上（默认打开） 12345678910public static void main(String[] args) &#123; alloc();&#125; private static void alloc() &#123; Point point = new Point(1,2); System.out.println(&quot;x&quot; + point.x + &quot;;&quot; + &quot;y&quot; + point.y); &#125; static class Point&#123; private int x; private int y; public Point(int i, int i1) &#123;&#125; &#125; 12345private static void alloc() &#123; int x = 1; int y = 2; System.out.println(&quot;x&quot; + x + &quot;;&quot; + &quot;y&quot; + y);&#125;","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"1-nginx-目录，配置文件","slug":"1-nginx-目录，配置文件","date":"2022-07-12T23:44:07.000Z","updated":"2022-07-13T00:43:53.262Z","comments":true,"path":"2022/07/13/1-nginx-目录，配置文件/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"","text":"使用 工具tree查看目录结构1、安装tree工具： yum install -y tree 2、 tree &#x2F;usr&#x2F;local&#x2F;nginx (tree后面跟的是Nginx的安装目录) ​ 查看进程的PID1、查看nginx的master进程和worker进程： ps -ef | grep nginx 2、nginx的.&#x2F;configure的配置参数的时候，有一个参数是–pid-path&#x3D;PATH默认是 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid 所以可以通过查看该文件来获取nginx的master进程ID ​ ​ ​ 信号 信号 作用 TERM或INT 立即关闭整个服务 QUIT “优雅”地关闭整个服务 HUP 重读配置文件并使用服务对新配置项生效 USR1 重新打开日志文件，可以用来进行日志切割 USR2 平滑升级 到最新版的nginx WINCH 所有子进程不在接收处理新连接相当于给work进程发送QUIT指令 调用命令为 kill -signal PID1、发送 TERM 或 INT 信号给master进程，会将Nginx服务 立即关闭 。 2、发送 QUIT 信号给master进程，master进程会控制所有的work进程不再接收新的请求， 等所有请求处理完后，在把进程都关闭掉 3、发送 HUP 信号给master进程，master进程会把控制旧的work进程不再接收新的请求，等处理完请求后将旧的work进程关闭掉，然后根据nginx的配置文件重新启动新的work进程 4、发送 USR1 信号给master进程，告诉Nginx重新开启日志文件 5、 发送 USR2 信号给master进程， 重新开启对应的master进程和work进程 ，这时系统里会有两个master进程和四个master进程 新的master进程的PID会被记录在 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid 而之前的旧的master进程PID会被记在 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid.oldbin文件中 最后再发送 QUIT 信号给旧的master进程 6、发送 WINCH 信号给master进程,让master进程控制不让所有的work进程在接收新的请求了 请求处理完后关闭work进程。 注意master进程不会被关闭掉 nginx命令行控制在sbin目录下，可以对nginx进行状态控制 ​ .&#x2F;nginx-v 查看版本号信息 .&#x2F;nginx-V 查看版本号信息和配置信息 .&#x2F;nginx-t 测试配置文件语法是否正确 .&#x2F;nginx-T 测试nginx的配置文件语法是否正确并列出用到的配置文件信息然后退出 .&#x2F;nginx-q 在配置测试期间禁止显示非错误消息 .&#x2F;nginx-s s即signal信号，后面可以跟 stop[快速关闭，类似于TERM&#x2F;INT信号的作用] quit[优雅的关闭，类似于QUIT信号的作用] reopen[重新打开日志文件类似于USR1信号的作用] reload[类似于HUP信号的作用] .&#x2F;nginx-p 指定Nginx的prefix路径 .&#x2F;nginx-c 指定Nginx的配置文件路径 .&#x2F;nginx-g 补充Nginx配置文件，向Nginx服务指定启动时应用全局的配置 nginx.conf配置文件结构nginx.conf配置文件中默认有三大块：全局块、events块、http块 http块中可以配置多个server块，每个server块又可以配置多个location块 ​ 全局块一、user指令可以指定启动运行工作进程的用户及用户组，这样对于系统的权限访问控制的更加精细，也更加安全 二、work process指令1、master_process:用来指定是否开启工作进程 ​ 2、worker _ processes:用于配置Nginx生成工作进程的数量 ，这个是Nginx服务器实现并发处理服务的关键所在 process的值越大，可以支持的并发处理量也越多 但事实上这个值的设定是需要受到来自服务器自身的限制建议将该值和服务器CPU的内核数保存一致 ​ ​ 三、其他指令1、deamon： 设定Nginx是否以守护进程的方式启动 守护进程是linux后台一种服务进程，特点是独立于控制终端，不会随着终端的关闭而停止 ​ ​ 2、pid： 配置nginx当前master进程的进程号ID存储的文件路径 ​ 3、error_log： 配置nginx错误日志存放路径 ​ 日志级别的值有：debug|info|notice|warn|error|crit|alert|emerg ​ 调试 |信息| 通知 | 警告 | 错误 |临界|警报|紧急 4、include： 引入其他配置文件 ​ 测试：1）创建一个main.conf，在里面写上配置文件 ​ 2）引入配置文件 ​ 3）加载成功 ​ events块1、 accept_mutex： 设置nginx网络连接序列化​ 如果设置为on，将会对多个Nginx进程接收连接进行序列号，一个个来唤醒接收， 防止了多个进程对连接的争抢 2、 multi_accept： 用来设置是否允许同时接收多个网络连接​ 如果multi_accept被禁止了，nginx一个工作进程只能同时接受一个新的连接。否则，一个工作进程可以同时接受所有的新连接 3、 worker_connections： 用来配置单个worker进程最大的连接数​ 连接数不仅仅包括和前端用户建立的连接数，而是包括所有可能的连接数 4、 use：用来设置Nginx服务器选择哪种事件驱动来处理网络消息​ HTTP块自定义MIME-Type（网络资源的媒体类型）​ default_type:用来配置Nginx响应前端请求默认的MIME类型​ ​ 自定义服务日志1、access_log:用来设置用户访问日志的相关属性 ​ ​ 2、log_format:用来指定日志的输出格式。 ​ ​ 3、sendfile:用来设置Nginx服务器是否使用sendfile()传输文件 该属性可以大大提高Nginx处理静态资源的性能 ​ 4、keepalive_timeout:用来 设置长连接的超时时间 ​ 5、keepalive_requests:用来设置一个keep-alive 连接使用的次数","categories":[{"name":"nginx","slug":"nginx","permalink":"http://www.hzzzzzy.icu/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.hzzzzzy.icu/tags/nginx/"}]},{"title":"3-2-选择排序","slug":"3-2-选择排序","date":"2022-07-12T03:17:30.000Z","updated":"2022-07-12T03:20:37.606Z","comments":true,"path":"2022/07/12/3-2-选择排序/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/3-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","excerpt":"","text":"排序原理： 1.每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较 ​ **如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引 ** 2.交换第一个索引处和最小值所在的索引处的值 ​ 原始数据到第一趟排序：假定4是最小值，让4分别与数据的其他7位元素进行比较，如果有比4小的数，交换二者位置让那个数成为最小值放在第一位，然后继续比较，直到到了元素的最后一位 第六趟到第7趟排序：假定8是最小值，与后面的10，9进行比较，如果有比4小的数，交换二者位置让那个数成为最小值放在第一位，然后继续比较，直到到了元素的最后一位 ​ 123456789101112131415161718192021222324public static void sort(Comparable[] a)&#123; for (int i = 0; i &lt; a.length - 1; i++) &#123; //定义一个变量，记录最小元素所在的索引，默认为参与选择排序的第一个元素所在的位置 int min = i; for (int j = i + 1; j &lt; a.length; j++) &#123; //需要比较最小索引min处的值和j索引处的值 if (greater(a[min],a[j]))&#123; min = j; &#125; &#125; //交换最小元素所在的索引min处的值和j索引处的值 exch(a, i, min); &#125;&#125;private static boolean greater(Comparable v,Comparable w)&#123; return v.compareTo(w)&gt;0;&#125;private static void exch(Comparable[] a,int i,int j)&#123; Comparable temp; temp = a[i]; a[i] = a[j]; a[j] = temp;&#125; 假设数组长度为n 最开始，将数组的第一个元素作为最小值所在的索引，定义为min 用两个for循环进行嵌套，第一个for循环表示，需要进行n-1趟排序 第二个for循环为了比较最小索引的值min 与 后面元素的索引值。 如果存在比最小索引min的值小的元素，则交换min与该元素的索引，使其成为最小值的索引 注意： 第二个for循环中定义 j &#x3D; i + 1 是为了在排好顺序的元素的后一位才开始进行比较 而且 j 不能越界访问，所以 j 要小于数组的长度 选择排序的时间复杂度分析： 选择排序使用了双层for循环，其中外层循环完成了数据交换，内层循环完成了数据比较， 分别统计数据 交换次数和数据比较次数： 数据比较次数： (N-1)+(N-2)+(N-3)+…+2+1&#x3D;((N-1)+1)*(N-1)&#x2F;2&#x3D;N^2&#x2F;2-N&#x2F;2; 数据交换次数： N-1 时间复杂度：N^2&#x2F;2-N&#x2F;2+（N-1）&#x3D;N^2&#x2F;2+N&#x2F;2-1; 根据大O推导法则，保留最高阶项，去除常数因子，时间复杂度为O(N^2);","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.hzzzzzy.icu/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构基础知识","slug":"数据结构基础知识","permalink":"http://www.hzzzzzy.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"3-1-冒泡排序","slug":"3-1-冒泡排序","date":"2022-07-12T03:02:22.000Z","updated":"2022-07-12T03:16:34.797Z","comments":true,"path":"2022/07/12/3-1-冒泡排序/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/3-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","excerpt":"","text":"排序原理： 1. 比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。 2. 对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值。 **初始状态到第一次冒泡 : ** 比较 4,5，5比4大，不变。 比较5,6，6比5大，不变 比较6,3，3比6小，交换二者位置 4,5,3,6,2,1 比较6,2，2比6小，交换二者位置 4,5,3,2,6,1 比较6,1，1比6小，交换二者位置 4,5,3,2,1,6 假设数组长度为n，冒泡排序必须实现n-1次冒泡（令k &#x3D; n） 第一次冒泡要有k-1次比较 第二次冒泡要有k-2次比较 第n-1次冒泡要有k-n-1次比较 123456789public static void sort(Comparable[] a)&#123; for (int i = a.length-1;i &gt; 0;i--)&#123; for (int j = 0; j &lt; i; j++) &#123; if (greater(a[j],a[j+1]))&#123; exch(a,j,j+1); &#125; &#125; &#125;&#125; 使用两个for循环进行遍历，第一个for循环表示冒泡的次数为：数组长度-1 第二个for循环表示相邻数组元素依次比较，j &lt; i 表示排序完的元素放在数组的后面，不需要再次进行排序 123456789101112131415161718192021222324252627282930313233343536373839404142package SORT;/** * @author Hzy * @create 2022/1/14 * 10:59 */// 1.public static void sort(Comparable[] a)：对数组内的元素进行排序// 2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w// 3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值public class Bubble &#123; //对数组内的元素进行排序 public static void sort(Comparable[] a)&#123; for (int i = a.length-1;i &gt; 0;i--)&#123; for (int j = 0; j &lt; i; j++) &#123; if (greater(a[j],a[j+1]))&#123; exch(a,j,j+1); &#125; &#125; &#125; &#125; //判断v是否大于w private static boolean greater(Comparable v,Comparable w)&#123; int result = v.compareTo(w); if (result&gt;0) &#123; return true; &#125; else &#123; return false; &#125;// return result&gt;0; &#125; //交换a数组中，索引i和索引j处的值 private static void exch(Comparable[] a,int i,int j)&#123; Comparable temp; temp = a[i]; a[i] = a[j]; a[j] = temp; &#125;&#125; 冒泡排序的时间复杂度分析 冒泡排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码 **所以， 分析冒泡排序的时间复杂度，主要分析一下内层循环体的执行次数即可。 ** 在最坏情况下，也就是假如要排序的元素为{6,5,4,3,2,1}逆序， 那么： 元素比较的次数为： (N-1)+(N-2)+(N-3)+…+2+1&#x3D;((N-1)+1)*(N-1)&#x2F;2&#x3D;N^2&#x2F;2-N&#x2F;2; 元素交换的次数为： (N-1)+(N-2)+(N-3)+…+2+1&#x3D;((N-1)+1)*(N-1)&#x2F;2&#x3D;N^2&#x2F;2-N&#x2F;2; 总执行次数为： (N^2&#x2F;2-N&#x2F;2)+(N^2&#x2F;2-N&#x2F;2)&#x3D;N^2-N; 按照大O推导法则，保留函数中的最高阶项那么最终冒泡排序的时间复杂度为O(N^2)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.hzzzzzy.icu/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构基础知识","slug":"数据结构基础知识","permalink":"http://www.hzzzzzy.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"2-3-算法的空间复杂度分析","slug":"2-3-算法的空间复杂度分析","date":"2022-07-12T02:58:57.000Z","updated":"2022-07-12T03:15:09.881Z","comments":true,"path":"2022/07/12/2-3-算法的空间复杂度分析/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/2-3-%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","excerpt":"","text":"一、java中常见内存占用1.基本数据类型内存占用情况： ​ 2.计算机访问内存的方式都是一次一个字节 3.一个引用（机器地址）需要8个字节表示： 例如： Date date &#x3D; new Date(),则date这个变量需要占用8个字节来表示 4.创建一个对象，比如new Date()，除了Date对象内部存储的数据(例如年月日等信息)占用的内存，该对象本身也 有内存开销，每个对象的自身开销是16个字节，用来保存对象的头信息。 5.一般内存的使用，如果不够8个字节，都会被自动填充为8字节 6.java中数组被被限定为对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要24字节的头信息 (16个自己的对象开销，4字节用于保存长度以及4个填充字节)再加上保存值所需的内存。 二、算法的空间复杂度算法的空间复杂度计算公式记作：S(n)&#x3D;O(f(n)),其中n为输入规模，f(n)为语句关于n所占存储空间的函数。 案例： 对指定的数组元素进行反转，并返回反转的内容。 ​ ​ 根据大O推导法则，算法一的空间复杂度为O(1) 算法二的空间复杂度为O(n) 所以从空间占用的角度讲，算法一要优于算法二。 由于java中有内存垃圾回收机制，并且jvm对程序的内存占用也有优化（例如即时编译），我们无法精确的评估一 个java程序的内存占用情况，但是了解了java的基本内存占用，使我们可以对java程序的内存占用情况进行估算。 由于现在的计算机设备内存一般都比较大，基本上个人计算机都是4G起步，大的可以达到32G 所以内存占用一般 情况下并不是我们算法的瓶颈，普通情况下直接说复杂度，默认为算法的时间复杂度。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.hzzzzzy.icu/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构基础知识","slug":"数据结构基础知识","permalink":"http://www.hzzzzzy.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"2-2-函数调用时间复杂度分析","slug":"2-2-函数调用时间复杂度分析","date":"2022-07-12T02:53:17.000Z","updated":"2022-07-12T03:15:24.813Z","comments":true,"path":"2022/07/12/2-2-函数调用时间复杂度分析/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/2-2-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","excerpt":"","text":"案例一：123456789public static void main(String[] args) &#123; int n=100; for (int i = 0; i &lt; n; i++) &#123; show(i); &#125;&#125;private static void show(int i) &#123; System.out.println(i);&#125; show方法的时间复杂度为O(1),main方法的时间复杂度是O(n) 案例二：1234567891011public static void main(String[] args) &#123; int n=100; for (int i = 0; i &lt; n; i++) &#123; show(i); &#125;&#125;private static void show(int i) &#123; for (int j = 0; j &lt; i; i++) &#123; System.out.println(i); &#125;&#125; 在main方法中，有一个for循环，循环体调用了show方法，由于show方法内部也有一个for循环 所以show方法 的时间复杂度为O(n)，main方法的时间复杂度为O(n^2) 案例三：1234567891011121314151617public static void main(String[] args) &#123; int n=100; show(n); for (int i = 0; i &lt; n; i++) &#123; show(i); &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; System.out.println(j); &#125; &#125;&#125;private static void show(int i) &#123; for (int j = 0; j &lt; i; i++) &#123; System.out.println(i); &#125;&#125; 在show方法中，有一个for循环，所以show方法的时间复杂度为O(n),在main方法中，show(n)这行代码内部执行 的次数为n，第一个for循环内调用了show方法，所以其执行次数为n^2,第二个嵌套for循环内只执行了一行代码， 所以其执行次数为n^2,那么main方法总执行次数为n+n^2+n^2&#x3D;2n^2+n。 根据大O推导规则，去掉n保留最高阶 项，并去掉最高阶项的常数因子2，所以最终main方法的时间复杂度为O(n^2) 最坏情况123456789public int search(int num)&#123; int[] arr=&#123;11,10,8,9,7,22,23,0&#125;; for (int i = 0; i &lt; arr.length; i++) &#123; if (num==arr[i])&#123; return i; &#125; &#125; return -1;&#125; 最好情况： 查找的第一个数字就是期望的数字，那么算法的时间复杂度为O(1) 最坏情况： 查找的最后一个数字，才是期望的数字，那么算法的时间复杂度为O(n) 平均情况： 任何数字查找的平均成本是O(n&#x2F;2) 最坏情况是一种保证，在应用中，这是一种最基本的保障，即使在最坏情况下，也能够正常提供服务，所以，除非 特别指定， 我们提到的运行时间都指的是最坏情况下的运行时间。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.hzzzzzy.icu/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构基础知识","slug":"数据结构基础知识","permalink":"http://www.hzzzzzy.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"2-1-算法时间复杂度分析","slug":"2-1-算法时间复杂度分析","date":"2022-07-12T02:43:58.000Z","updated":"2022-07-12T03:15:29.298Z","comments":true,"path":"2022/07/12/2-1-算法时间复杂度分析/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/2-1-%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","excerpt":"","text":"最高次项的指数大的，随着n的增长，结果也会变得增长特别快 算法函数中n最高次幂越小，算法效率越高 1.算法函数中的常数可以忽略； 2.算法函数中最高次幂的常数因子可以忽略； 3.算法函数中最高次幂越小，算法效率越高。 大O记法在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随着n的变化情况并确定T(n)的 量级。算法的时间复杂度，就是算法的时间量度，记作:T(n)&#x3D;O(f(n))。 它表示随着问题规模n的增大，算法执行时间 的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度，其中f(n)是问题规模n的某个函数。 执行次数&#x3D;执行时间 算法一：12345678910public static void main(String[] args) &#123; int sum = 0;//执行1次 int n=100;//执行1次 sum = (n+1)*n/2;//执行1次 System.out.println(&quot;sum=&quot;+sum);&#125; 算法二：1234567891011121314public static void main(String[] args) &#123; int sum = 0;//执行1次 int n=100;//执行1次 for (int i = 1; i &lt;= n; i++) &#123; sum += i;//执行了n次 &#125; System.out.println(&quot;sum=&quot; + sum);&#125; 算法三：1234567891011121314151617public static void main(String[] args) &#123; int sum=0;//执行1次 int n=100;//执行1次 for (int i = 1; i &lt;=n ; i++) &#123; for (int j = 1; j &lt;=n ; j++) &#123; sum+=i;//执行n^2次 &#125; &#125; System.out.println(&quot;sum=&quot;+sum);&#125; **算法一：3次 ** **算法二：n+3次 ** 算法三：n^2+2次 推导大O阶 的表示法以下几个规则可以使用： **1.用常数1取代运行时间中的所有加法常数； ** 2.在修改后的运行次数中，只保留高阶项； 3.如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数； 所以，上述算法的大O记法分别为： ​ 算法一：O(1) ​ 算法二：O(n) ​ 算法三：O(n^2) 常见的大O阶1.线性阶一般含有非嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长，例如： 123456public static void main(String[] args) &#123; int sum = 0;//执行1次 int n=100;//执行1次 sum = (n+1)*n/2;//执行1次 System.out.println(&quot;sum=&quot;+sum);&#125; 上面这段代码，它的循环的时间复杂度为O(n),因为循环体中的代码需要执行n次 2.平方阶一般嵌套循环属于这种时间复杂度 123456789public static void main(String[] args) &#123; int sum=0,n=100; for (int i = 1; i &lt;=n ; i++) &#123; for (int j = 1; j &lt;=n ; j++) &#123; sum+=i; &#125; &#125; System.out.println(sum);&#125; 上面这段代码，n&#x3D;100，也就是说，外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环 中出来，就需要执行100100次，也就是n的平方次，所以*这段代码的时间复杂度是O(n^2). 3.立方阶一般三层嵌套循环属于这种时间复杂度 1234567891011public static void main(String[] args) &#123; int x = 0, n = 100; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i; j &lt;= n; j++) &#123; for (int j = i; j &lt;= n; j++) &#123; x++; &#125; &#125; &#125; System.out.println(x);&#125; 上面这段代码，n&#x3D;100，也就是说，外层循环每执行一次，中间循环循环就执行100次，中间循环每执行一次，最 内层循环需要执行100次，那总共程序想要从这三个循环中出来，就需要执行100100100次，也就是n的立方，所 以这段代码的时间复杂度是O(n^3). 4.对数阶12345int i=1,n=100;while(i&lt;n)&#123; i = i * 2; &#125; 由于每次i2之后，就距离n更近一步，假设有x个2相乘后大于n，则会退出循环。由于是2^x&#x3D;n,得到x&#x3D;log(2)n,所 以*这个循环的时间复杂度为O(logn); 对于对数阶，由于随着输入规模n的增大，不管底数为多少，他们的增长趋势是一样的，所以我们会忽略底数。 5.常数阶一般不涉及循环操作的都是常数阶，因为它不会随着n的增长而增加操作次数。例如： 12345public static void main(String[] args) &#123; int n=100; int i=n+2; System.out.println(i);&#125; 上述代码，不管输入规模n是多少，都执行2次，根据大O推导法则，常数用1来替换，所以上述代码的时间复杂度为O(1) ​ 他们的复杂程度从低到高依次为： ​ 所以，我们的算法，尽可能的追求的是O(1),O(logn),O(n),O(nlogn)这几种时间复杂度，而如果发现算法的时间复杂度为平方阶、 立方阶或者更复杂的，那我们可以分为这种算法是不可取的，需要优化。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.hzzzzzy.icu/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构基础知识","slug":"数据结构基础知识","permalink":"http://www.hzzzzzy.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"1-1-数据结构分类","slug":"1-1-数据结构分类","date":"2022-07-12T02:32:40.000Z","updated":"2022-07-12T03:15:35.885Z","comments":true,"path":"2022/07/12/1-1-数据结构分类/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/1-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB/","excerpt":"","text":"数据结构分类： 顺序存储结构： 把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的 ，比如我们常用的数组就是顺序存储结构。 ​ 链式存储结构： 是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。此时，数据元素之间并 不能反映元素间的逻辑关系，因此在链式存储结构中引进了一个指针存放数据元素的地址，这样通过地址就可以找 到相关联数据元素的位置 逻辑结构分类： 集合结构：集合结构中数据元素除了属于同一个集合外，他们之间没有任何其他的关系。 线性结构：线性结构中的数据元素之间存在一对一的关系 树形结构：树形结构中的数据元素之间存在一对多的层次关系 图形结构：图形结构的数据元素是多对多的关系","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.hzzzzzy.icu/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构基础知识","slug":"数据结构基础知识","permalink":"http://www.hzzzzzy.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"01-设计模式的原则","slug":"01-设计模式的原则","date":"2022-07-12T02:13:01.000Z","updated":"2022-07-13T00:44:11.530Z","comments":true,"path":"2022/07/12/01-设计模式的原则/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/","excerpt":"","text":"设计模式的目的1、代码重用性 2、可读性 3、可扩展性（增加功能时，对原来的功能没有影响） 4、可靠性（增加功能时，对原来的功能没有影响） 5、高内聚，低耦合 单一职责原则一个类应该只负责一项职责 如：类 A 负责两个不同职责：职责 1，职责 2。 当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2 注意： 降低类的复杂度，一个类负责一个职责 提高类的可读性 降低变更的风险 只有类中方法数量足够少时，可以在方法级别保持单一职责原则 ​ ​ ​ 接口隔离的原则客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上 类A和类C只需要依赖接口1的一部分接口，而不需要实现全部，所以可以将接口 Interface1 拆分为独立的几个接口(这里我们拆分成 3 个接口)，类 A 和类 C 分别与他们需要的接口建立依赖关系 ​ ​ 依赖倒转原则1）高层模块不应该依赖底层模块，二者都应该依赖其抽象 2）抽象不应该依赖细节，细节应该依赖抽象 3）核心思想：面向接口编程 三种方式：接口传递，构造方法传递，setter方法传递 ​ ​ 里氏替换原则继承给程序设计带来便利也带来了弊端： 使用继承会给程序带来侵入性 可移植性降低 增加对象间的耦合 当这个类要修改时，必须考虑到所有的子类 正确使用继承： 使用继承时，在子类中尽量不要重写父类的方法 在适当的情况，可以使用聚合，组合，依赖来解决 解决方法：让原来的子类和父类都继承一个更通俗的基类，将原有的继承关系去掉，采用聚合，组合，依赖等关系来代替 ​ ​ 开闭原则 （最基础，最重要）比如一个类，模块和函数一个对扩展开发（对提供方），对修改关闭（对使用方）。 当软件需要变化，尽量通过扩展代码，而不是通过修改已有代码的方法实现 案例： 如果需要增加新的功能，绘制别的图形，需要在使用方处修改代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Ocp &#123; public static void main(String[] args) &#123; //使用看看存在的问题 GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); graphicEditor.drawShape(new Triangle()); &#125;&#125;//这是一个用于绘图的类 [使用方]class GraphicEditor &#123; //接收Shape对象，然后根据type，来绘制不同的图形 public void drawShape(Shape s) &#123; if (s.m_type == 1) drawRectangle(s); else if (s.m_type == 2) drawCircle(s); else if (s.m_type == 3) drawTriangle(s); &#125; //绘制矩形 public void drawRectangle(Shape r) &#123; System.out.println(&quot; 绘制矩形 &quot;); &#125; //绘制圆形 public void drawCircle(Shape r) &#123; System.out.println(&quot; 绘制圆形 &quot;); &#125; //绘制三角形 public void drawTriangle(Shape r) &#123; System.out.println(&quot; 绘制三角形 &quot;); &#125;&#125;//Shape类，基类class Shape &#123; int m_type;&#125;class Rectangle extends Shape &#123; Rectangle() &#123; super.m_type = 1; &#125;&#125;class Circle extends Shape &#123; Circle() &#123; super.m_type = 2; &#125;&#125;//新增画三角形class Triangle extends Shape &#123; Triangle() &#123; super.m_type = 3; &#125;&#125; 改进： 创建一个抽象类Shape，提供一个抽象方法drow，然后让子类去继承该抽象方法，重写该抽象方法，当需要增加新的功能的时候，只需要创建一个新的类去继承抽象方法并重写即可，无需对使用方代码进行改动 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Ocp &#123; public static void main(String[] args) &#123; //使用看看存在的问题 GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); graphicEditor.drawShape(new Triangle()); graphicEditor.drawShape(new OtherGraphic()); &#125;&#125;//这是一个用于绘图的类 [使用方]class GraphicEditor &#123; //接收Shape对象，调用draw方法 public void drawShape(Shape s) &#123; s.draw(); &#125;&#125;//Shape类，基类abstract class Shape &#123; int m_type; public abstract void draw();//抽象方法&#125;class Rectangle extends Shape &#123; Rectangle() &#123; super.m_type = 1; &#125; @Override public void draw() &#123; System.out.println(&quot; 绘制矩形 &quot;); &#125;&#125;class Circle extends Shape &#123; Circle() &#123; super.m_type = 2; &#125; @Override public void draw() &#123; System.out.println(&quot; 绘制圆形 &quot;); &#125;&#125;//新增画三角形class Triangle extends Shape &#123; Triangle() &#123; super.m_type = 3; &#125; @Override public void draw() &#123; System.out.println(&quot; 绘制三角形 &quot;); &#125;&#125;//新增一个图形class OtherGraphic extends Shape &#123; OtherGraphic() &#123; super.m_type = 4; &#125; @Override public void draw() &#123; System.out.println(&quot; 绘制其它图形 &quot;); &#125;&#125; 迪米特法则 （最少知道原则） 一个对象应该对其他对象保持最少的了解 每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，则这两个对象之间是朋友关系 其中，出现成员变量，方法参数，方法返回值中的类为直接的朋友 迪米特法则只要要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系 合成复用原则尽量使用合成或者聚合的方式，而不是使用继承 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起 针对接口编程，而不是针对具体实现编程 松耦合设计 ​","categories":[{"name":"java","slug":"java","permalink":"http://www.hzzzzzy.icu/categories/java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.hzzzzzy.icu/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"06-本地方法栈和本地方法","slug":"06-本地方法栈和本地方法","date":"2022-07-12T01:37:44.000Z","updated":"2022-07-13T11:59:34.325Z","comments":true,"path":"2022/07/12/06-本地方法栈和本地方法/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/06-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95/","excerpt":"","text":"本地方法实际上是一个java调用非java代码的一个接口 （ 使用native关键字进行修饰 ） 本地方法的作用： 1、Java应用与Java外面的环境交互 2、与操作系统进行交互 3、Sun公司解释器由C实现 本地方法栈 （线程私有）Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用 本地方法栈中登记本地方法，然后执行引擎执行时，加载本地方法库 当某一个线程调用本地方法时 本地方法可通过本地方法接口来访问虚拟机内部的运行时数据区 可以使用本地处理器中的寄存器 ……（和虚拟机拥有一样的权限）","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"05-虚拟机栈及相关问题","slug":"05-虚拟机栈及相关问题","date":"2022-07-12T01:35:21.000Z","updated":"2022-07-13T11:59:42.423Z","comments":true,"path":"2022/07/12/05-虚拟机栈及相关问题/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","excerpt":"","text":"虚拟机栈 （线程私有） 不存在GC，存在OOM 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧，对应着一次次的方法调用 虚拟机栈的生命周期和线程一致。作用是主管java程序的运行，保存方法的局部变量（8种基本数据类型，对象的引用地址，对象实际存储在堆空间中），部分结果，并参与方法的调用和返回 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器 JVM直接对栈的操作：1、每个方法执行，伴随着进栈（入栈，压栈） 2、执行结束后的出栈操作 设置栈内存的大小使用参数-Xss选项设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度 栈的存储单位1）栈中的数据都是以栈帧为基本单位存在 2）在这个线程上正在执行的每个方法都各自对应着一个栈帧 3）栈帧是一个内存区块，是一个数据集，****维系着方法执行过程中的各种数据信息 4）在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧，与当前栈帧相对应的方法就是当前方法，定义这个方法的类就是当前类。 5）执行引擎运行的所有字节码指令只针对当前栈帧进行操作。 6）如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。 ​ 栈帧的内部结构每个栈帧都存储着： 局部变量表 操作数栈（表达式栈） 动态链接（或指向运行时常量池的方法引用） 方法返回地址（或方法正常退出或异常退出的定义） 一些附加信息 方法嵌套调用的次数由栈的大小决定，栈越大，方法嵌套调用的次数就越多。 对于一个函数，参数和局部变量越多，局部变量表就会膨胀，栈帧就越大 局部变量表1、存放编译器的各种基本数据类型（8种）引用类型（reference）returnAddress类型的变量 2、定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量 3、由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题 4、局部变量表所需的容量大小是在编译器就确定下来的（一旦确定就不会更改） 注意：局部变量表中的变量只在当前方法调用中有效，当方法调用结束后，随着方法栈帧的销毁，局部变量表也会销毁 123456789101112131415161718/** * @Description 字节码中方法内部结构的剖析 * @Author hzy * @Date 2022/7/11 14:54 * @Version 1.0 **///使用javap -v 类.class 或者使用jclasslibpublic class LocalVariableTest &#123; public static void main(String[] args) &#123; LocalVariableTest test=new LocalVariableTest(); int num=10; test.test1(); &#125; public static void test1()&#123; Date date = new Date(); String name=&quot;xiaozhi&quot;; &#125;&#125; ​ ​ ​ 比如此处，num对应的起始pc是8，对应代码的实际行数第14行，字节码指令长度是17 所以起始pc加上长度就是字节码的指令长度 textcolor{red}{局部变量表的基本存储单元是Slot(变量槽) 32位以内的类型只占用一个Slot（包括returnAddress类型） 64位的类型占用两个Slot（long和double） byte，short，char在存储前转化为int boolean也被转换为int，0表示false，1表示true JVM会为局部变量中的每一个Slot都分配一个访问索引，通过这个索引可以访问局部变量中指定的值 ​ 如果需要访问一个64bit的局部变量值时，只需要使用前一个索引即可 如果当前帧是由构造方法或者实例的方法进行创建的，那么该对象引用this将会存放在index为0的Slot处，其余的继续排列 例子：​ *this代表对象实例，而static是随类的加载而加载，先于实例之前就有的，所以不存在于局部变量表中，所以不能使用。 变量的分类 一、按照数据类型分：1、基本数据类型 2、引用数据类型 二、按照在类中声明的位置分： 1、成员变量：在使用前都经过默认初始化赋值 ​ 类变量：linking的prepare阶段，给类变量默认赋值 —&gt; initial阶段，给类变量显式赋值即静态代码块赋值 **实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值** **2、局部变量：使用前必须进行显示赋值，否则编译不通过** 局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中的直接或间接引用的对象都不会被回收 操作数（表达式）栈 每一个独立的栈帧中除了包含局部变量表以外，还包含了一个后进先出的操作数栈，也可以称之为表达式栈 在方法执行的过程中，根据字节码指令，往栈中写入数据（入栈）或提取数据（出栈） 主要用于保存计算过程的中间结果，同时作为计算机过程中变量临时的存储空间 当一个方法开始执行的时候，一个新的栈帧也会被创建出来，这个方法的操作数栈是空的 每一个操作数栈都会拥有一个栈深度用于存储数值（max_stack）32bit类型占用一个栈单位深度，64bit类型占用两个栈单位深度 操作数栈不是通过访问索引的方式来进行数据访问的，而只能通过标准的入栈出栈来进行数据访问 代码追踪12345public void testAddOperation()&#123; byte i = 15; int j = 8; int k = i + j;&#125; 操作数栈的最大深度123456789101112public class OperandStackTest &#123; public void testAddOperation()&#123; //byte、short、char、boolean:都以int型保存 byte i=15; short j=8; int k=i+j; long m=12L; int n=800; //存在宽化类型转换 m=m*n; &#125;&#125; 栈顶缓存技术为了解决指令过多导致频繁地执行内存读&#x2F;写操作，影响执行速度的问题 将栈顶元素全部缓存在物理CPU的寄存器中,以此降低对内存的读&#x2F;写次数 (将计算的操作放到CPU寄存器里面去) 动态链接栈帧内部包含了一个指向运行时常量池中该栈帧所属方法的引用—动态链接 每一个栈帧内部都包含一个指向运行时常量池Constant pool或该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如invokedynamic指令 动态链接的作用就是为了将这些符号引用(#)最终转换为调用方法的直接引用 方法的调用： 静态链接：在字节码文件装载进JVM内部时，被调用的方法在编译期可知，而且在运行的期间保持不变，这时候符号引用就会转换为直接引用。这个过程即为静态链接 动态链接：被调用的方法在编译期不可确定，在程序运行的期间才将符号引用进行转换，这个过程为动态链接 绑定：一个字段，方法，类在符号引用转换为直接引用的过程 早期绑定：被调用的目标方法在编译期内可知，运行期间不变 晚期绑定：调用方法在编译期无法确定，到运行期才确定 非虚方法：在编译器确定调用的版本，这个版本运行时不变，比如：静态方法，私有方法，final方法，实例构造器，父类方法 虚方法：其他 虚方法表每个类中都有一个虚方法表，表中存放着各个方法的实际入口。 如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中 虚方法表会在类加载的链接阶段被创建并开始初始化 ，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。 方法返回地址存储调用该方法的PC寄存器的值 在方法推出后都会返回到该方法被调用的位置。 方法正常退出时，调用者的PC计数器的值作为返回地址（调用该方法的指令的下一条指令的地址） 方法异常退出时，返回地址通过异常表来确定 相关问题1、举例栈溢出的情况：通过-Xss设置栈的大小（OOM） 2、调整栈大小，就能保证不出现溢出吗？不能 3、分配的栈内存越大越好吗？不是，栈空间大了线程数就少了，栈空间和线程数目成反比 4、垃圾回收是否会涉及到虚拟机栈？不会 5、方法中定义的局部变量是否线程安全？看情况 6、代码演示：（内部产生，在内部消亡，线程安全） 12345678910111213141516171819202122232425262728293031//s1的声明方式是线程安全的public static void method1()&#123; //StringBuilder线程不安全 StringBuilder s1 = new StringBuilder(); s1.append(&quot;a&quot;);&#125;//s2的操作过程是线程不安全的public static void method2(StringBuilder s2)&#123; s2.append(&quot;a&quot;);&#125;//s3的操作是线程不安全的public static StringBuilder method3() &#123; StringBuilder s3 = new StringBuilder(); s3.append(&quot;a&quot;); return s3;&#125;//s4的操作是线程安全的,s4其实在内部消亡了public static String method4() &#123; StringBuilder s4 = new StringBuilder(); s4.append(&quot;a&quot;); return s4.toString();&#125;public static void main(String[] args) &#123; StringBuilder s = new StringBuilder(); new Thread(()-&gt; &#123; s.append(&quot;a&quot;); &#125;).start(); method2(s);&#125;","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"04-程序计数器","slug":"04-程序计数器","date":"2022-07-12T01:31:14.000Z","updated":"2022-07-13T11:59:48.005Z","comments":true,"path":"2022/07/12/04-程序计数器/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/04-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/","excerpt":"","text":"程序计数器（PC寄存器）概述既不存在GC也不存在OOM PC寄存器用来存储指向下一条指令的地址，也是即将要执行的指令代码。由执行引擎读取下一条指令 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。 代码演示 通过PC寄存器，我们就可以知道当前程序执行到哪一步了 ​ 使用PC寄存器存储字节码地址有什么用？（为什么要使用PC寄存器记录当前线程的执行地址呢？）1、CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。 2、JVM的字节码解释器需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。 PC寄存器为什么被设定为线程私有的？由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。 这样必然导致经常中断或恢复，为了保证分毫无差。每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。 比如一个cpu负责3个线程，cpu会在3个线程间轮流执行，为了能够保证CPU在切换的过程中，每个线程都可以按照切换之前的指令继续执行，而不影响其他线程，所以PC寄存器设定为线程私有的 CPU时间片（*）","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"03-数据区概述与线程","slug":"03-数据区概述与线程","date":"2022-07-12T01:30:10.000Z","updated":"2022-07-13T11:59:55.762Z","comments":true,"path":"2022/07/12/03-数据区概述与线程/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/03-%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"数据区JVM在执行java程序的过程中会把它管理的内存划分为若干个不同的数据区域（包括5个运行时数据区） 1、方法区 2、虚拟机栈 3、本地方法栈 4、堆 5、程序计数器 ​ 运行时数据区的完整图 ​ Java的内存区域 ​ 灰色的为单独线程私有的，红色的为多个线程共享的。 即： 1、每个线程：独立包括程序计数器、虚拟机栈、本地方法栈。 2、线程间共享：堆、堆外内存（永久代或元空间、代码缓存） ​ 线程的简单介绍线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。 操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。 JVM线程（*） 虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。 GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。 编译线程：这种线程在运行时会将字节码编译成到本地代码。 信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"02-类加载器和类加载过程","slug":"02-类加载器和类加载过程","date":"2022-07-11T01:26:01.000Z","updated":"2022-07-13T12:00:02.178Z","comments":true,"path":"2022/07/11/02-类加载器和类加载过程/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"","text":"类加载过程 加载1、通过一个类的全限定名获取定义此类的二进制字节流 2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 链接：一共分为三个部分，验证、准备和解析一、验证目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身。 验证阶段是十分重要的，直接决定了Java虚拟机是否能承受恶意代码的攻击，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重。 主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证 二、准备1、为类变量分配内存并且设置该变量的默认初始值，即零值。 2、这里不包括含用final修饰的static,因为final在编译的时候就会分配数值了，准备阶段会显式初始化。 3、这里不会为实例变量分配初始化，类变量会分配在方法区，而实例变量是会随着对象一起分配到java堆中。 三、解析1、将常量池内的符号引用转换为直接引用过程 2、实际上，解析操作往往会伴随着JVM在执行完初始化之后再执行。 3、符号引用就是一组符号来描述所引用的目标。符号引用的字面形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 4、主要解析动作针对类或接口、字段、类方法、接口方法、方法类型等。 初始化1）初始化阶段就是执行类构造器方法()的过程该方法不需要定义，而是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来的 构造器方法中的指令按照语句在源文件中出现的顺序来决定 变量已经赋过一次系统要求的初始零值，而在初始化阶段 则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。 2）若该类有父类，JVM会保证子子类的()执行前，父类的()已经执行完毕虚拟机必须保证一个类的()方法在多线程下被同步加锁 3）在类加载的Linking链接的准备阶段，所有类变量以符号引用的方法存储在方法区而当静态代码尝试获取类变量时候需要通过直接引用，这就导致了编译的出错 4）Java编译器并不会为所有的类都产生()初始化方法一个类中并没有声明任何的类变量,也没有静态代码块时 一个类中声明类变量,但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时 一个类中包含static final修饰的基本数据类型的字段,这些类字段初始化语句采用编译时常量表达式 (如果这个static final 不是通过方法或者构造器,则在链接阶段) 5）赋值的阶段性问题 在链接阶段的准备环节赋值的情况: 1、对于基本数据类型的字段来说,如果使用static final修饰,则显式赋值(直接赋值常量,而非调用方法)通常是在链接阶段的准备环节进行 2、对于String来说,如果使用字面量的方式赋值,使用static final修饰的话,则显式赋值通常是在链接阶段的准备环节进行 3、使用static + final修饰,且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值,是在链接阶段的准备环节进行。 在初始化阶段()中赋值的情况: 排除上述的在准备环节赋值的情况之外的情况 类加载器 引导(启动)类加载器这个类加载使用C&#x2F;C++语言实现的,嵌套在JVM内部 1、它用来加载Java的核心类库(JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resource.jar或sum.boot.class.path路径下的内容) 用于提供JVM自身需要的类(String类就是使用的这个类加载器) 2、由于安全考虑,Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 3、并不继承自java.lang.ClassLoader,没有父加载器 4、加载扩展类和应用程序类加载器,并指定为他们的父类加载器 自定义加载器****（将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器） 1、Java语言编写 2、派生于ClassLoader类,父类加载器为启动类加载器 3、从java.ext.dirs系统属性所指定的目录中加载类库,或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录(扩展目录)下加载类库。 如果用户创建的JAR放在此目录下,也会自动由扩展类加载器加载 扩展类加载器1、Java语言编写 2、派生于ClassLoader类,父类加载器为启动类加载器 3、从java.ext.dirs系统属性所指定的目录中加载类库,或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录(扩展目录)下加载类库 如果用户创建的JAR放在此目录下,也会自动由扩展类加载器加载 应用程序(系统)类加载器 AppClassLoader1、java语言编写 2、派生于ClassLoader类,父类加载器为扩展类加载器 3、它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库 4、该类加载是程序中默认的类加载器 5、通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器 用户自定义类加载器目的隔离记载类 修改类的加载方式 扩展加载源 防止源码泄露 方法1）重写 loadClass() 方法（不推荐,这个方法会保证类的双亲委派机制） 2）重写 findClass() 方法 –&gt;推荐 这两种方法本质上差不多,毕竟loadClass()也会调用findClass(),但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法,根据参数指定类的名字,返回对应的Class对象的引用 获取ClassLoader的方法 ​ 双亲委派机制java虚拟机对class文件采用按需加载的方式进行加载，当需要使用该类时才会将它的class文件加载到内存中生成class对象 在加载这个类的时候，采用的就是双亲委派模式。 1、如果 一个类加载收到了类加载请求,它并不会自己先去加载 ,而是把这个请求 委托给父类加载器去执行 2、如果 父类加载器还存在其父类加载器 ,则进一步 向上委托 ,依次递归,请求最终将 到达顶层的启动类加载器 3、如果父类的加载器可以完成类的加载任务,就成功返回,倘若 父类加载器无法完成此加载任务,子加载器才会尝试自己去加载, 这就是双亲委派模式 ​ 源码分析（双亲委派机制在 java.lang.ClassLoader.loadClass(String,boolean) 中体现） 1、先在当前加载器的缓存中*查找有无目标类,如果有,直接返回。* 2、判断当前加载器的父加载器是否为空 ,如果不为空,则调用 parent.loadClass(name, false) 接口进行加载 3、反之,如果当前加载器的父类加载器为空,则调用 findBootstrapClassOrNull(name) 接口,让引导类加载器进行加载 4、如果通过以上3条路径都没能成功加载,则调用 findClass(name) 接口进行加载。该接口最终会调用 java.lang.ClassLoader 接口的 defineClass 系列的native接口加载目标Java类。 双亲委派的模型就隐藏在这第2和第3步中 双亲委派机制的优势1、避免类的重复加载，确保一个类的全局唯一性（当父ClassLoader已经加载了该类的时候,就没有必要子ClassLoader再加载一次） 2、保护程序的安全，防止API随意被篡改 沙箱安全机制Java代码限定在虚拟机JVM特定的运行范围中，并且严格限制代码对本地资源的访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏 ​ 类的使用方式java虚拟机在每个类或接口被java程序“首次主动使用”时才初始化它们。被动使用不会初始化类，但又可能会加载类 在加载的过程中，遇到.class文件的缺失或者存在错误，类加载器只会在首次主动使用它们时才会报错，如果一直没使用，则不会报错 主动使用1、创建类的实例 2、访问某个类或接口的静态变量，或者对该静态变量赋值 3、调用类的静态方法 4、反射 5、初始化一个类的子类 6、java虚拟机启动时被标明为启动类的类 注意： 初始化一个类的子类这条规则，不适用于接口，即：初始化一个类的子类，会先初始化它的父类，但是不一定会初始化它的接口。只有当首次使用该接口的静态变量时，才会初始化。 被动使用除了主动使用的其他使用方式，例如： 1）通过子类引用父类的静态字段，为子类的被动使用，不会导致子类初始化 2）通过数组定义类引用类，为类的被动使用，不会触发此类的初始化 ​ 3）常量在编译阶段会存入调用方法所在的类的常量池中（这个例子存在F类的常量池中） 本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"01-什么是JVM?","slug":"01-什么是JVM","date":"2022-07-10T12:25:14.000Z","updated":"2022-07-13T12:00:10.035Z","comments":true,"path":"2022/07/10/01-什么是JVM/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/10/01-%E4%BB%80%E4%B9%88%E6%98%AFJVM/","excerpt":"","text":"什么是JVM？①. JVM 是 java虚拟机，是用来执行java字节码(二进制的形式)的虚拟计算机 ②. jvm是运行在操作系统之上的，与硬件没有任何关系 Java的跨平台及原理①. 跨平台：由Java编写的程序可以在不同的操作系统上运行：一次编写，多处运行 ②. 原理：编译之后的字节码文件和平台无关，需要在不同的操作系统上安装一个对应版本的虚拟机(JVM) JVM的整体的理解①. 类加载子系统 ②. 运行时数据区(我们核心关注这里 的栈、堆、方法区) ③. 执行引擎(一般都是JIT编译器和解释器共存) java代码执行流程​ java源码—java编译器—生成字节码—进入java虚拟机（类加载器—字节码校验器—翻译字节码—JIT编译器） JVM的架构模型Java编译器输入的指令流基木上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。 基于栈式架构的特点 跨平台性 指令集小 指令多 执行性能比寄存器差 基于寄存器架构的特点 指令集架构则完全依赖硬件，可移植性差 性能优秀和执行更高效 举例 同样执行2+3这种逻辑操作，其指令分别如下： 1、基于栈的计算流程（以Java虚拟机为例) 2、基于寄存器的计算流程 总结 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。 JVM的生命周期虚拟机的启动 Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。 虚拟机的执行 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。 程序开始执行时他才运行，程序结束时他就停止。 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。 虚拟机的退出 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统用现错误而导致Java虚拟机进程终止 某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。 除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]}],"categories":[{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/categories/spring%E9%AB%98%E7%BA%A7/"},{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"},{"name":"nginx","slug":"nginx","permalink":"http://www.hzzzzzy.icu/categories/nginx/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.hzzzzzy.icu/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"java","slug":"java","permalink":"http://www.hzzzzzy.icu/categories/java/"}],"tags":[{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"},{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/tags/spring%E9%AB%98%E7%BA%A7/"},{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"nginx","slug":"nginx","permalink":"http://www.hzzzzzy.icu/tags/nginx/"},{"name":"数据结构基础知识","slug":"数据结构基础知识","permalink":"http://www.hzzzzzy.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.hzzzzzy.icu/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}