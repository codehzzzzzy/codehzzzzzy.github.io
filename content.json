{"meta":{"title":"Z.yang","subtitle":"Z.yang的博客","description":"欢迎访问Z.yang的博客","author":"Z.yang","url":"http://www.hzzzzzy.icu","root":"/"},"pages":[{"title":"关于我","date":"2022-07-10T01:26:06.000Z","updated":"2022-07-10T01:59:51.459Z","comments":true,"path":"about/index.html","permalink":"http://www.hzzzzzy.icu/about/index.html","excerpt":"","text":"Z.yang“ 认识自我，超越自我 “ 那么你就离成功更进了一步 联系我​ QQ：&#50;&#x39;&#51;&#57;&#x32;&#57;&#x34;&#56;&#53;&#52;&#64;&#x71;&#x71;&#x2e;&#99;&#111;&#109;​ WeChat：https://postimg.cc/N2RP6f9K​ Outlook：&#x68;&#x7a;&#122;&#122;&#122;&#122;&#121;&#x40;&#111;&#x75;&#x74;&#108;&#x6f;&#x6f;&#x6b;&#x2e;&#x63;&#111;&#x6d;"},{"title":"分类","date":"2022-07-09T07:59:10.000Z","updated":"2022-07-10T01:13:31.420Z","comments":true,"path":"categories/index.html","permalink":"http://www.hzzzzzy.icu/categories/index.html","excerpt":"","text":""},{"title":"相关链接整理","date":"2022-07-09T08:00:38.000Z","updated":"2022-07-14T08:54:03.684Z","comments":true,"path":"link/index.html","permalink":"http://www.hzzzzzy.icu/link/index.html","excerpt":"","text":""},{"title":"Zyang的标签页","date":"2022-07-09T07:56:18.000Z","updated":"2022-07-09T08:05:44.554Z","comments":true,"path":"tags/index.html","permalink":"http://www.hzzzzzy.icu/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"集合专题","slug":"集合专题","date":"2022-08-21T08:19:44.000Z","updated":"2022-08-22T02:50:38.330Z","comments":true,"path":"2022/08/21/集合专题/","link":"","permalink":"http://www.hzzzzzy.icu/2022/08/21/%E9%9B%86%E5%90%88%E4%B8%93%E9%A2%98/","excerpt":"","text":"ArrayListArrayList无参构造的初始容量为0 ArrayList有参构造的初始容量根据所给的长度进行创建（如果是集合，就根据集合的大小进行创建） 调用add方法触发扩容当往ArrayList添加元素的时候。触发第一次扩容，创建一个长度为10的新数组，然后将元素添加进新数组里面，再用新的数组替换掉旧的空数组。 当数组内元素为10时，进行第二次扩容，扩容为第一次容量的1.5倍，即15（以后每一次扩容都是上一次的1.5倍） 注意：此处的1.5倍其实是上一次容量右移一位，再加上它本身，如第三次扩容：15右移一位是7，7+15为22 调用addAll方法触发扩容在下一次扩容的容量跟实际的元素个数之间选择一个较大值 如：添加元素个数为16个，那么数组容量将会扩容到22 0 10 15 22 33 49 73 109 IteratorFail-Fast策略在通过迭代器遍历的同时如果有人对集合进行修改，那么就抛出异常 ArrayList的迭代器采用了Fail-Fast策略 源码分析增强for循环在首次调用内部会生成一个迭代器，在执行过程中，expectedModCount作为迭代器的成员变量，记录了迭代器刚开始迭代时的修改次数。modCount作为list的成员变量，记录list修改次数，该数会记录在expectedModCount里 接下来调用hasNext方法和next方法，调用next方法之前会进行一次校验（checkForComodification方法） 当在迭代的过程中，对集合进行了修改，此时expectedModCount的值就会变换，导致二者不等，那么就会直接抛出异常 Fail-Save策略在通过迭代器遍历的同时如果有人对集合进行修改，可以采取应对策略而不是抛出异常，如牺牲一致性来让整个遍历正常完成 CopyOnWriteArrayList采用了Fail-Save策略 源码分析在迭代器内部会首先创建一个数组，将要遍历的数组复制过去，然后遍历该数组 当我们在迭代的过程中调用add方法添加新元素的时候，实际上在add方法的内部是先将原来的数组复制一份，然后让长度加一，而新添加的元素加到了新的数组的最后一位，所以遍历的时候使用的是旧数组，而添加元素的时候使用的是新数组，二者互不干扰 LinkedList与ArrayList的比较LinkedList基于双向链表，无需连续内存 随机访问慢（要沿着链表遍历） 头尾插入删除性能高 占用内存多 ArrayList基于数组，需要连续内存 随机访问快（指根据下标访问） 尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低 可以利用 cpu 缓存，局部性原理 随机访问速度 ArrayList内部实现了RandomAccess接口（LinkedList没有），该接口是一个标识接口，如果实现了该接口，那么当获取其中某个元素时就直接根据下标get就行。如果没有实现该接口，那么只能通过迭代器的next方法获取下一个元素 增删速度LinkedList：头尾插入删除性能高 ArrayList：尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低 局部性cpu读取数据是按照缓存行读取到缓存的，就是cpu会把需要的数据加载到缓存中，查找数据时，会先从缓存找，找不到再到内存中去找。 数组作为连续内存，而cpu缓存会把一片连续的内存空间读入，这样连续内存的数组更容易整块读取到缓存中，当进行遍历时，直接命中缓存。 链表是跳跃式的地址，很轻易就会跳出缓存，跑到内存中去查找数据。所以会慢很多 HashMap1.7 数组+链表 1.8 数组+（链表&#x2F;红黑树） 原理在实例化之后，底层创建了一个长度是16的一维数组Entry[] table，在进行put操作时，先获得key的hashCode，通过hash()散列算法得到hash值，进而定位到数组的位置 如果该位置上为空，此时添加成功 如果该位置上不为空，意味着此位置上存在一个或多个数据（以链表的形式存在），此时比较该元素与其他元素的hash值（调用equals方法），当返回false时添加成功，返回true时使用新的value替换掉旧的value 扩容capacity 容量，默认16。 loadFactor 加载因子，默认是0.75 threshold 阈值。阈值&#x3D;容量*加载因子。默认12。当元素数量超过阈值时便会触发扩容。 二次哈希的意义下面是HashMap根据二次Hash计算出的哈希码，计算键值对下标的代码，length是底层数组的长度。HashMap采用了位运算，而非常见的取模运算 123static int indexFor(int h, int length) &#123; return h &amp; (length-1);&#125; 当不进行二次hash的时候，假设数组长度为16，当哈希码为5时，下标Index结果是5\\ 1234 00000000000000000000000000000101&amp;00000000000000000000000000001111=00000000000000000000000000000101=5 当哈希码为65541时，下标Index结果依然是5，不同的哈希码算出相同的下标，出现了哈希碰撞 1234 00000000000000010000000000000101&amp;00000000000000000000000000001111=00000000000000000000000000001101=5 通过例子可以发现哈希码的高位压根就没有参与运算，全部被丢弃了。 不管哈希码的高位是多少，都不会影响最终Index的计算结果，因为只有低位才参与了运算，这样的哈希函数是不好的，它会带来更多的冲突，影响HashMap的效率。 HashMap为了解决这个问题，将哈希码的高16位与低16位进行异或运算，得到一个新的哈希码，这样就可以让高位也参与到运算，这个函数也被称为扰动函数 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 总结：HashMap通过二次哈希，引入扰动函数，拿高16位和低16位做异或运算，把高位的特征和地位的特征组合起来，以此来降低哈希碰撞的概率 注意：二次 hash 是为了配合 容量是 2 的 n 次幂 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash，容量是 2 的 n 次幂 这一设计计算索引效率更好，但 hash 的分散性就不好，需要二次 hash 来作为补偿，没有采用这一设计的典型例子是 Hashtable 数组容量为何是2的n次幂1、当数组容量是2的n次幂时，计算索引时可以用按位与运算代替求模运算，提高运算性能 2、扩容时使用hash &amp; oldCap == 0的元素留在原来位置，否则新位置 = 旧位置 + oldCap 3、可以尽量避免hash冲突的发生。 从HashMap的源码中可以看到HashMap在扩容时选择了位运算，向集合中添加元素时，会使用(n - 1) &amp; hash的计算方法来得出该元素在集合中的位置。 hash表初始数组长度是16进行一次扩容数组长度就会变成32，他们的二进制分别是10000和100000。 (n-1)&amp;hash中n就是hash表原来的长度，n-1就会使二进制发生如下的变化： 1216 10000 -&gt; 15 0111132 100000 -&gt; 31 011111 (n-1)&amp;hash，接下来就会与被插入的对象hash进行按位与运算，看下面几个例子： 1201111 &amp; 01001 = 0100101111 &amp; 01101 = 01101 如果数组扩容不是按2的n次幂来运算，那么就会有hash冲突的情况出现。比如数组长度16进行一次扩容以后变成了25（二进制11001），与带插入新元素进行&amp;运算时就会出现hash冲突，如下： 1211001 &amp; 10111 = 1000111001 &amp; 10011 = 10001 树化与退化树化规则当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;&#x3D;64，才会进行树化 树化意义红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略 hash 表的查找，更新的时间复杂度是 *O(1)*，而红黑树的查找，更新的时间复杂度是 *O(log_2⁡n )*，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表 hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小 退化规则情况1：在扩容时如果拆分树时，树元素个数 &lt;&#x3D; 6 则会退化链表 情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表（在移除之前进行检查） put方法流程总结HashMap 是懒惰创建数组的，首次使用才创建数组 计算索引（桶下标） 如果桶下标还没人占用，创建 Node 占位返回 如果桶下标已经有人占用 ​ 已经是 TreeNode 走红黑树的添加或更新逻辑 ​ 是普通 Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑 返回前检查容量是否超过阈值，一旦超过进行扩容","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.hzzzzzy.icu/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"SpringMVC","slug":"SpringMVC","date":"2022-08-19T07:32:12.000Z","updated":"2022-08-21T08:15:09.206Z","comments":true,"path":"2022/08/19/SpringMVC/","link":"","permalink":"http://www.hzzzzzy.icu/2022/08/19/SpringMVC/","excerpt":"","text":"DispatcherServlet初始化时机 启动类 12345&gt;private static final Logger log = LoggerFactory.getLogger(A20.class);&gt;public static void main(String[] args) throws Exception &#123;&gt;AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext(WebConfig.class);&gt;&#125; Config类 1、创建内嵌的web容器工厂 2、创建 DispatcherServlet 3、注册 DispatcherServlet 12345678910111213141516171819202122&gt;@Configuration&gt;@ComponentScan&gt;public class WebConfig &#123;&gt;// 创建内嵌的web容器工厂&gt;@Bean&gt;public TomcatServletWebServerFactory tomcatServletWebServerFactory() &#123; return new TomcatServletWebServerFactory();&gt;&#125;&gt;// 创建 DispatcherServlet&gt;@Bean&gt;public DispatcherServlet dispatcherServlet() &#123; return new DispatcherServlet();&gt;&#125;&gt;// 注册 DispatcherServlet, Spring MVC 的入口&gt;@Bean&gt;public DispatcherServletRegistrationBean dispatcherServletRegistrationBean(DispatcherServlet dispatcherServlet) &#123; //拦截所有请求，使请求全部进入dispatcherServlet，再进行分发 return new DispatcherServletRegistrationBean(dispatcherServlet,&quot;/&quot;);&gt;&#125;&gt;&#125; DispatcherServlet对象作为Spring容器的一个Bean，是由Spring容器创建的，但是它的初始化不是由Spring容器创建的，而是由tomcat服务器在首次使用到DispatcherServlet时由tomcat进行初始化。 可以通过setLoadOnStartup方法设置优先级，来让tomcat一启动就加载DispatcherServlet （数字越小优先级越高） 一般来说该优先级是写在application.properties文件中，从而避免耦合。所以需要在类上使用注解来读取properties文件 1@PropertySource(&quot;classpath:application.properties&quot;) 还需要使用注解来绑定配置文件中的key，下面绑定的是properties文件中以spring.mvc开头和server开头的值 1@EnableConfigurationProperties(&#123;WebMvcProperties.class,ServerProperties.class&#125;) 初始化DispatcherServlet的类层次如下： 从客户端穿过来的所有请求都需要通过DispatcherServlet前端控制器来进行请求的分发处理，然后把响应结果返回给客户端，它的本质其实也是一个Servlet，和其他Servlet一样有着同样的生命周期（Servlet 简介） 1、初始化 2、运行 3、销毁 下图为DispatcherServlet的初始化过程 DispatcherServlet的初始化工作并没有在DispatcherServlet类中进行，而是在HttpServletBean类中重写了init()方法，代码如下 步骤： 1、init()方法通过实例化ServletConfigPropertyValues对servlet进行参数初始化 2、参数初始化之后，会把DispatcherServlet转换为BeanWrapper，将其当作一个Bean去管理，这样就可以通过Spring的依赖注入对参数的值进行注入（通过bw.setPropertyValues(pvs, true);进行注入） 3、调用的模板方法initBeanWrapper在HttpServletBean的子类中实现 12345678910111213141516171819202122232425262728@Overridepublic final void init() throws ServletException &#123;/** * 加载web.xml中的init-param进行初始化 * ServletConfigPropertyValues是HttpServletBean的一个内部类 * 该类的作用是用来解析web.xml中元素&lt;servlet&gt;的子元素&lt;init-param&gt;的参数值 */ PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties); if (!pvs.isEmpty()) &#123; try &#123; //此处将Servlet转化成BeanWrapper，便于值的注入 BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment())); //此处调用的是模板方法 initBeanWrapper(bw); //把初始配置设置给DispatcherServlet bw.setPropertyValues(pvs, true); &#125; catch (BeansException ex) &#123; if (logger.isErrorEnabled()) &#123; logger.error(&quot;Failed to set bean properties on servlet &#x27;&quot; + getServletName() + &quot;&#x27;&quot;, ex); &#125; throw ex; &#125; &#125; initServletBean();&#125; 4、initBeanWrapper方法在FrameworkServlet类中的重写实现，主要是对web上下文进行初始化，代码如下： 注意：ContextLoaderListener加载的时候已经创建了WebApplicationContext实例，这里是对这个实例的进一步补充初始化 12345678910111213141516171819202122232425262728293031@Overrideprotected final void initServletBean() throws ServletException &#123; getServletContext().log(&quot;Initializing Spring &quot; + getClass().getSimpleName() + &quot; &#x27;&quot; + getServletName() + &quot;&#x27;&quot;); if (logger.isInfoEnabled()) &#123; logger.info(&quot;Initializing Servlet &#x27;&quot; + getServletName() + &quot;&#x27;&quot;); &#125; long startTime = System.currentTimeMillis(); try &#123; //初始化WebApplicationContext this.webApplicationContext = initWebApplicationContext(); //模板方法，在子类中实现 initFrameworkServlet(); &#125; catch (ServletException | RuntimeException ex) &#123; logger.error(&quot;Context initialization failed&quot;, ex); throw ex; &#125; if (logger.isDebugEnabled()) &#123; String value = this.enableLoggingRequestDetails ? &quot;shown which may lead to unsafe logging of potentially sensitive data&quot; : &quot;masked to prevent unsafe logging of potentially sensitive data&quot;; logger.debug(&quot;enableLoggingRequestDetails=&#x27;&quot; + this.enableLoggingRequestDetails + &quot;&#x27;: request parameters and headers will be &quot; + value); &#125; if (logger.isInfoEnabled()) &#123; logger.info(&quot;Completed initialization in &quot; + (System.currentTimeMillis() - startTime) + &quot; ms&quot;); &#125;&#125; 5、initWebApplicationContext方法主要是负责初始化DispatcherServlet自己的应用上下文 先查看FrameworkServlet在构造时，是否传入一个WebApplicationContext，如果不会就会查找，仍然没有查到，则会自己创建一个WebApplicationContext，最后对WebApplicationContext进行onRefresh()操作完成对上下文的创建，onRefresh还是一个模板方法，让子类实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344protected WebApplicationContext initWebApplicationContext() &#123; //获取rootContext，如果在web.xml中配置了ContextLoaderListener，那么这个就是rootContext WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; //判断FrameworkServlet的构造方法是否传入了webApplicationContext，如果有，就使用传入的 if (this.webApplicationContext != null) &#123; wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) &#123; //如果context还没有被refresh，需要设置父context或者设置应用上下文的id等 if (cwac.getParent() == null) &#123; //在没有明确的父context情况下，注入rootContext的实例 cwac.setParent(rootContext); &#125; configureAndRefreshWebApplicationContext(cwac); &#125; &#125; &#125; if (wac == null) &#123; wac = findWebApplicationContext(); &#125; //如果最终没有传入也没有找到WebApplicationContext的话，就自己创建一个 if (wac == null) &#123; wac = createWebApplicationContext(rootContext); &#125; if (!this.refreshEventReceived) &#123; synchronized (this.onRefreshMonitor) &#123;、 //模板方法，让子类实现 onRefresh(wac); &#125; &#125; if (this.publishContext) &#123; // Publish the context as a servlet context attribute. String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); &#125; return wac;&#125; RequestMappingHandlerMappingRequestMappingHandlerMapping 初始化时，会收集所有 @RequestMapping 映射信息，封装为 Map，其中 key 是 RequestMappingInfo 类型，包括请求路径、请求方法等信息 value 是 HandlerMethod 类型，包括控制器方法对象、控制器对象 有了这个 Map，就可以在请求到达时，快速完成映射，找到 HandlerMethod 并与匹配的拦截器一起返回给 DispatcherServlet 123456789101112131415public class A20 &#123; private static final Logger log = LoggerFactory.getLogger(A20.class); public static void main(String[] args) throws Exception &#123; AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext(WebConfig.class); //解析@RequestMapping以及派生注解，生成路径和控制器方法的映射关系，在初始化时就生成了 RequestMappingHandlerMapping handlerMapping = context.getBean(RequestMappingHandlerMapping.class); //获取映射结果（key封装了路径信息和请求类型，value为控制器方法） Map&lt;RequestMappingInfo, HandlerMethod&gt; handlerMethods = handlerMapping.getHandlerMethods(); //请求来了，获取控制器方法，返回一个处理器执行链对象 //HandlerExecutionChain with [com.itheima.a20.Controller1#test1()] and 0 interceptors HandlerExecutionChain chain = handlerMapping.getHandler(new MockHttpServletRequest(&quot;GET&quot;, &quot;/test1&quot;)); &#125;&#125; RequestMappingHandlerAdapter因为RequestMappingHandlerAdapter里面invokeHandlerMethod方法是私有的，所以我们创建一个子类去继承他，然后重写该方法，将该方法改为public 123456public class MyRequestMappingHandlerAdapter extends RequestMappingHandlerAdapter &#123; @Override public ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; return super.invokeHandlerMethod(request, response, handlerMethod); &#125;&#125; RequestMappingHandlerAdapter 内部含有大量的web基础组件来协助完成一整个请求处理，因此它可以被描述为单个请求的调度、处理中心，如： HandlerMethodArgumentResolver 解析控制器方法参数 HandlerMethodReturnValueHandler 处理控制器方法返回值 1234567891011121314151617181920212223 //创建一个虚拟的请求和响应对象 MockHttpServletRequest request = new MockHttpServletRequest(&quot;POST&quot;, &quot;/test2&quot;); request.setParameter(&quot;name&quot;,&quot;张三&quot;); MockHttpServletResponse response = new MockHttpServletResponse();//解析@RequestMapping以及派生注解，生成路径和控制器方法的映射关系，在初始化时就生成了 RequestMappingHandlerMapping handlerMapping = context.getBean(RequestMappingHandlerMapping.class); MyRequestMappingHandlerAdapter handlerAdapter = context.getBean(MyRequestMappingHandlerAdapter.class); //参数一：请求对象 //参数二：响应对象 //参数三：handlerMethod对象 handlerAdapter.invokeHandlerMethod(request,response, (HandlerMethod) chain.getHandler()); //获取多个参数解析器 List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers = handlerAdapter.getArgumentResolvers(); for (HandlerMethodArgumentResolver argumentResolver : argumentResolvers) &#123; System.out.println(argumentResolver); &#125; //获取所有返回值处理器 for (HandlerMethodReturnValueHandler returnValueHandler : handlerAdapter.getReturnValueHandlers()) &#123; System.out.println(returnValueHandler); &#125; 自定义参数解析器 为了让handlerAdapter能够识别自定义的参数解析器，在Config里调用setCustomArgumentResolvers方法将自定义的参数解析器加入到handlerAdapter中 1234567@Beanpublic RequestMappingHandlerAdapter requestMappingHandlerAdapter() &#123; TokenArgumentResolver tokenArgumentResolver = new TokenArgumentResolver(); MyRequestMappingHandlerAdapter handlerAdapter = new MyRequestMappingHandlerAdapter(); handlerAdapter.setCustomArgumentResolvers(List.of(tokenArgumentResolver)); return handlerAdapter;&#125; 创建自定义的参数解析器（实现HandlerMethodArgumentResolver接口） 12345678910111213141516public class TokenArgumentResolver implements HandlerMethodArgumentResolver &#123; @Override // 是否支持某个参数 // 如果参数上标注了@Token注解，那么才需要进行解析 public boolean supportsParameter(MethodParameter parameter) &#123; Token token = parameter.getParameterAnnotation(Token.class); return token != null; &#125; @Override // 解析参数 public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123; return webRequest.getHeader(&quot;token&quot;); &#125;&#125; 创建虚拟请求，并进行测试 1234567891011121314151617181920AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext(WebConfig.class);//创建一个虚拟的请求和响应对象MockHttpServletRequest request = new MockHttpServletRequest(&quot;PUT&quot;, &quot;/test3&quot;);request.addHeader(&quot;token&quot;,&quot;令牌&quot;);MockHttpServletResponse response = new MockHttpServletResponse();MyRequestMappingHandlerAdapter handlerAdapter = context.getBean(MyRequestMappingHandlerAdapter.class);//解析@RequestMapping以及派生注解，生成路径和控制器方法的映射关系，在初始化时就生成了RequestMappingHandlerMapping handlerMapping = context.getBean(RequestMappingHandlerMapping.class);//请求来了，获取控制器方法，返回一个处理器执行链对象HandlerExecutionChain chain = handlerMapping.getHandler(request);MyRequestMappingHandlerAdapter handlerAdapter = context.getBean(MyRequestMappingHandlerAdapter.class);handlerAdapter.invokeHandlerMethod(request,response, (HandlerMethod) chain.getHandler()); 自定义的返回值处理器 创建自定义的返回值处理器（实现HandlerMethodReturnValueHandler接口） 123456789101112131415161718192021222324252627public class YmlReturnValueHandler implements HandlerMethodReturnValueHandler &#123; // 是否支持某个参数 // 如果参数上标注了@Yml注解，那么才需要进行解析 @Override public boolean supportsReturnType(MethodParameter returnType) &#123; Yml yml = returnType.getMethodAnnotation(Yml.class); return yml != null; &#125; /** * @param returnValue 返回值 */ @Override public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; // 1. 转换返回结果为 yaml 字符串 String str = new Yaml().dump(returnValue); // 2. 将 yaml 字符串写入响应 HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class); response.setContentType(&quot;text/plain;charset=utf-8&quot;); response.getWriter().print(str); // 3. 设置请求已经处理完毕 mavContainer.setRequestHandled(true); &#125;&#125; 为了让handlerAdapter能够识别自定义的返回值解析器，在Config里调用setCustomReturnValueHandlers方法将自定义的返回值解析器加入到handlerAdapter中 12345678@Beanpublic RequestMappingHandlerAdapter requestMappingHandlerAdapter() &#123; TokenArgumentResolver tokenArgumentResolver = new TokenArgumentResolver(); YmlReturnValueHandler ymlReturnValueHandler = new YmlReturnValueHandler(); handlerAdapter.setCustomReturnValueHandlers(List.of(ymlReturnValueHandler)); return handlerAdapter;&#125; 创建虚拟请求，并进行测试 123456789101112131415161718192021222324AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext(WebConfig.class);//创建一个虚拟的请求和响应对象MockHttpServletRequest request = new MockHttpServletRequest(&quot;GET&quot;, &quot;/test4&quot;);MockHttpServletResponse response = new MockHttpServletResponse();MyRequestMappingHandlerAdapter handlerAdapter = context.getBean(MyRequestMappingHandlerAdapter.class);//解析@RequestMapping以及派生注解，生成路径和控制器方法的映射关系，在初始化时就生成了RequestMappingHandlerMapping handlerMapping = context.getBean(RequestMappingHandlerMapping.class);//请求来了，获取控制器方法，返回一个处理器执行链对象HandlerExecutionChain chain = handlerMapping.getHandler(request);MyRequestMappingHandlerAdapter handlerAdapter = context.getBean(MyRequestMappingHandlerAdapter.class);handlerAdapter.invokeHandlerMethod(request,response, (HandlerMethod) chain.getHandler());//检查响应结果byte[] content = response.getContentAsByteArray();System.out.println(new String(content, StandardCharsets.UTF_8));//!!com.itheima.a20.Controller1$User &#123;age: 18, name: 张三&#125;","categories":[{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/categories/spring%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"},{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/tags/spring%E9%AB%98%E7%BA%A7/"}]},{"title":"AOP","slug":"AOP","date":"2022-08-16T01:51:12.000Z","updated":"2022-08-19T07:25:09.280Z","comments":true,"path":"2022/08/16/AOP/","link":"","permalink":"http://www.hzzzzzy.icu/2022/08/16/AOP/","excerpt":"","text":"ajc编译器使用aspectj编译器插件来改动class类文件来实现增强（在编译阶段） 编译器增强能突破代理仅能通过方法重写增强的限制：可以对构造方法、静态方法等实现增强 12345678910111213141516171819202122&lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.14.0&lt;/version&gt; &lt;configuration&gt; &lt;complianceLevel&gt;1.8&lt;/complianceLevel&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;showWeaveInfo&gt;true&lt;/showWeaveInfo&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;Xlint&gt;ignore&lt;/Xlint&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;goal&gt;test-compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 因为idea 不会调用 ajc 编译器，所以一定要用 maven 的 compile 来编译 1234567891011121314@SpringBootApplicationpublic class A09 &#123; private static final Logger log = LoggerFactory.getLogger(A09.class); public static void main(String[] args) &#123; ConfigurableApplicationContext context = SpringApplication.run(A09.class, args); MyService service = context.getBean(MyService.class); log.debug(&quot;service class: &#123;&#125;&quot;, service.getClass()); service.foo(); context.close(); &#125;&#125; agent 类加载运行时需要在 VM options 里加入-javaagent:(maven仓库地址)/org/aspectj/aspectjweaver/1.9.7/aspectjweaver-1.9.7.jar 类加载时修改 .class 文件实现增强 Proxy增强（JDK）实现123456789101112131415161718192021222324252627282930313233343536373839public class JdkProxyDemo &#123; interface Foo &#123; void foo(); &#125; static final class Target implements Foo &#123; public void foo() &#123; System.out.println(&quot;target foo&quot;); &#125; &#125; // jdk 只能针对接口代理 public static void main(String[] param) throws IOException &#123; // 目标对象 Target target = new Target(); //类加载器 ClassLoader loader = JdkProxyDemo.class.getClassLoader(); //三个参数分别为 // loader：类加载器，用来加载在运行期间动态生成的字节码 // Class[]&#123;Foo.class&#125;：代理类将要实现的接口 // 代理类将来要调用代理类方法时要执行的行为 Foo proxy = (Foo) Proxy.newProxyInstance(loader, new Class[]&#123;Foo.class&#125;, new InvocationHandler() &#123; //三个参数分别是代理对象本身，正在执行的方法对象，方法传递的参数 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;before...&quot;); //目标.方法(参数); //方法.invoke(目标,参数); Object res = method.invoke(target, args); System.out.println(&quot;after...&quot;); //让代理也返回目标方法执行的结果 return res; &#125; &#125;); proxy.foo(); &#125;&#125; 总结代理对象和目标对象都实现了Foo接口，是兄弟关系。代理对象类型不能强转成目标对象类型 目标类定义的时候可以加final修饰 原理1、先用代码简单模拟一下JDK动态代理。先定义一个Foo接口，里面有一个foo方法，再定义一个Target类来实现这个接口，代码如下： 123456789101112131415161718192021222324252627public interface Foo &#123; void foo();&#125;@Slf4jpublic final class Target implements Foo &#123; public void foo() &#123; log.debug(&quot;target foo&quot;); &#125;&#125;public class $Proxy0 implements Foo &#123; @Override public void foo() &#123; // 1. 功能增强 System.out.println(&quot;before...&quot;); // 2. 调用目标 new Target().foo(); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Foo proxy = new $Proxy0(); proxy.foo(); &#125;&#125; 接下来对Target类中的foo()方法进行增强 首先想再定义一个类实现Foo接口，然后在foo()中编写增强代码，接着再new一个Target对象，调用它的foo()方法，代码如下所示： 1234567891011121314151617public class $Proxy0 implements Foo &#123; @Override public void foo() &#123; // 1. 功能增强 System.out.println(&quot;before...&quot;); // 2. 调用目标 new Target().foo(); &#125;&#125;// 测试运行public class Main &#123; public static void main(String[] args) &#123; Foo proxy = new $Proxy0(); proxy.foo(); &#125;&#125; 2、上面的代码把功能增强的代码和调用目标的代码都固定在了代理类的内部，不太灵活。 因此可以通过定义一个InvocationHandler接口的方式来将这部分代码解耦出来，代码如下： 1234567891011121314151617181920212223242526public interface InvocationHandler &#123; void invoke();&#125;public interface Foo &#123; void foo();&#125;@Slf4jpublic final class Target implements Foo &#123; public void foo() &#123; System.out.println(&quot;target foo&quot;); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Foo proxy = new $Proxy0(new InvocationHandler() &#123; @Override public void invoke() &#123; // 1. 功能增强 System.out.println(&quot;before...&quot;); // 2. 调用目标 new Target().foo(); &#125; &#125;); proxy.foo(); &#125;&#125; 123456789101112public class $Proxy0 implements Foo &#123; private InvocationHandler h; public $Proxy0(InvocationHandler h) &#123; this.h = h; &#125; @Override public void foo() &#123; h.invoke(); &#125;&#125; 3、虽然将功能增强的代码和调用目标的代码通过接口的方式独立出来了，但是如果此时接口中新增了一个方法bar()，Target类和$Proxy0类中都要实现bar()方法，那么调用proxy的foo()和bar()方法都将间接调用目标对象的foo()方法，因为在InvocationHandler的invoke()方法中调用的是target.foo()方法 4、改进为代理类中调用方法的时候，通过反射把接口中对应的方法Method对象作为参数传给InvocationHandler，这样就可以通过保证调用proxy调用方法时一定能在invoke中调用对应的方法 5、同时，修改Foo接口的中的bar()方法，使其具有int类型的返回值，因此InvocationHandler的invoke()方法也得有返回值，同时将代理对象本身作为第一个参数，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738public class A12 &#123; interface Foo &#123; void foo(); int bar(); &#125; static class Target implements Foo &#123; public void foo() &#123; System.out.println(&quot;target foo&quot;); &#125; @Override public int bar() &#123; System.out.println(&quot;target bar&quot;); return 100; &#125; &#125;// interface InvocationHandler &#123;// Object invoke(Object proxy, Method method, Object[] args) throws Throwable;// &#125; public static void main(String[] param) throws NoSuchMethodException &#123; Foo proxy = new $Proxy0(new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException &#123; //1、实现功能增强 System.out.println(&quot;before&quot;); //2、调用目标 return method.invoke(new Target(),args); &#125; &#125;); proxy.foo(); proxy.bar(); &#125;&#125; 当每次调用foo或者bar方法时，多次加载。此处使用静态代码块对foo和bar进行初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//代理类//与目标实现一个共同的接口public class $Proxy0 extends Proxy implements Foo &#123; //通过构造方法传递InvocationHandler public $Proxy0(InvocationHandler h)&#123; super(h); &#125; @Override public void foo() &#123; try &#123; //将foo方法和方法参数进行传递（此处没有参数，使用Object[0]代替） h.invoke(this,foo,new Object[0]); //运行异常直接抛 &#125; catch (RuntimeException | Error e) &#123; throw e; //检查异常，转化后抛 &#125; catch (Throwable e) &#123; throw new UndeclaredThrowableException(e); &#125; &#125; @Override public int bar() &#123; try &#123; //将bar方法和方法参数进行传递（此处没有参数，使用Object[0]代替） Object res = h.invoke(this,bar, new Object[0]); return (int) res; //运行异常直接抛出 &#125; catch (RuntimeException | Error e) &#123; throw e; //检查异常，转化为运行时异常后 &#125; catch (Throwable e) &#123; throw new UndeclaredThrowableException(e); &#125; &#125; //对foo和bar初始化 static Method foo; static Method bar; static &#123; try &#123; //获取 foo方法对象 foo = Foo.class.getMethod(&quot;foo&quot;); //获取 bar方法对象 bar = Foo.class.getMethod(&quot;bar&quot;); &#125; catch (NoSuchMethodException e) &#123; throw new NoSuchMethodError(e.getMessage()); &#125; &#125;&#125; 反射优化前 16 次是调用了java本地的MethodAccessor 的实现类，反射性能较低 第 17 次调用会生成代理类，优化为非反射调用（用 arthas 的 jad 工具反编译第 17 次调用生成的代理类） 123456789101112131415161718192021222324252627public class TestMethodInvoke &#123; public static void main(String[] args) throws Exception &#123; Method foo = TestMethodInvoke.class.getMethod(&quot;foo&quot;, int.class); for (int i = 1; i &lt;= 17; i++) &#123; show(i, foo); foo.invoke(null, i); &#125; System.in.read(); &#125; // 方法反射调用时, 底层 MethodAccessor 的实现类 private static void show(int i, Method foo) throws Exception &#123; Method getMethodAccessor = Method.class.getDeclaredMethod(&quot;getMethodAccessor&quot;); getMethodAccessor.setAccessible(true); Object invoke = getMethodAccessor.invoke(foo); if (invoke == null) &#123; System.out.println(i + &quot;:&quot; + null); return; &#125; Field delegate = Class.forName(&quot;jdk.internal.reflect.DelegatingMethodAccessorImpl&quot;).getDeclaredField(&quot;delegate&quot;); delegate.setAccessible(true); System.out.println(i + &quot;:&quot; + delegate.get(invoke)); &#125; public static void foo(int i) &#123; System.out.println(i + &quot;:&quot; + &quot;foo&quot;); &#125;&#125; Proxy增强（cglib）实现123456789101112131415161718192021222324252627282930313233343536public class CglibProxyDemo &#123; static class Target &#123;` public void foo() &#123; System.out.println(&quot;target foo&quot;); &#125; &#125; // 代理是子类型, 目标是父类型 // 如果目标对象为final，或者代理类执行的方法为final，则无法进行代理 // 而jdk代理都实现了接口，代理类和目标类是平级的关系，所以可以进行代理 public static void main(String[] param) &#123; Target target = new Target(); //MethodInterceptor()决定了代理类中方法执行的行为 Target proxy = (Target) Enhancer.create(Target.class, new MethodInterceptor() &#123; @Override //四个参数分别是： //1、代理对象本身 //2、当前代理类中执行的方法 //3、方法执行时的参数 //4、方法对象（可以避免反射调用方法） public Object intercept (Object p, Method method, Object[] args, MethodProxy methodProxy)throws Throwable &#123; System.out.println(&quot;before...&quot;); // Object res = method.invoke(target, args);// Object res = methodProxy.invoke(target, args);//内部没有用到反射，需要目标 Object res = methodProxy.invokeSuper(p, args);//内部没有用到反射，需要代理 System.out.println(&quot;after...&quot;); return res; &#125; &#125;); proxy.foo(); &#125;&#125; 总结1public Object intercept (Object p, Method method, Object[] args, MethodProxy methodProxy) MethodInterceptor的intercept()方法的第2个参数是method，可以通过反射对目标方法进行调用 1Object result = method.invoke(target, args); // 用方法反射调用目标 第4个参数proxy，可以不用反射就能对目标方法进行调用 12Object result = proxy.invoke(target, args); // 需要传目标类 （spring用的是这种）Object result = proxy.invokeSuper(obj, args); // 不需要目标类，需要代理对象本身 代理类不需要实现接口 代理对象和目标对象是父子关系，代理类继承于目标类； 目标类定义的时候不能加final修饰，否则代理类就无法继承目标类了，会报IllegalArgumentException 目标类方法定义的时候不能加final修饰，否则代理类继承目标类以后就不能重写目标类的方法了 原理代码模拟cglib动态代理先创建一个目标类，其中有三个方法，再创建一个代理类继承目标类，并且通过构造方法传入MethodInterceptor对象用于回调。重写目标类后，通过调用intercept方法实现功能增强（静态代码块作用与jdk动态代理中类似） 12345public class Target &#123; public void save() &#123;System.out.println(&quot;save()&quot;);&#125; public void save(int i) &#123;System.out.println(&quot;save(int)&quot;);&#125; public void save(long j) &#123;System.out.println(&quot;save(long)&quot;);&#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Proxy extends Target &#123; private MethodInterceptor methodInterceptor; public void setMethodInterceptor(MethodInterceptor methodInterceptor) &#123; this.methodInterceptor = methodInterceptor; &#125; @Override public void save()&#123; //第一个参数：代理类对象 //第二个参数：当前正在执行的方法 //第三个参数：实参数组 //第四个参数：方法代理（可以避免反射调用） try &#123; methodInterceptor.intercept(this,save0,new Object[0], null); &#125; catch (Throwable e) &#123; throw new UndeclaredThrowableException(e); &#125; &#125; @Override public void save(int i)&#123; try &#123; methodInterceptor.intercept(this,save1,new Object[]&#123;i&#125;, null); &#125; catch (Throwable e) &#123; throw new UndeclaredThrowableException(e); &#125; &#125; @Override public void save(long j)&#123; try &#123; methodInterceptor.intercept(this,save2,new Object[]&#123;j&#125;, null); &#125; catch (Throwable e) &#123; throw new UndeclaredThrowableException(e); &#125; &#125; static Method save0; static Method save1; static Method save2; static &#123; try &#123; save0 = Target.class.getMethod(&quot;save&quot;); save1 = Target.class.getMethod(&quot;save&quot;,int.class); save2 = Target.class.getMethod(&quot;save&quot;,long.class); &#125; catch (NoSuchMethodException e) &#123; throw new NoSuchMethodError(e.getMessage()); &#125; &#125;&#125; 测试类 12345678910111213141516public static void main(String[] args) &#123; Proxy proxy = new Proxy(); Target target = new Target(); proxy.setMethodInterceptor(new MethodInterceptor() &#123; @Override public Object intercept (Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;before...&quot;); Object res = method.invoke(target, objects); return res; &#125; &#125;); proxy.save(); proxy.save(2); proxy.save(5L);&#125; 创建MethodProxy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static MethodProxy save0Proxy;static MethodProxy save1Proxy;static MethodProxy save2Proxy;static &#123; //第一个参数：目标类型 //第二个参数：代理的类型 //第三个参数：用于描述参数和返回值类型 // ()V表示无参无返回值，(I)V表示参数为整型无返回值，(J)V表示参数为长整型无返回值 //第四个参数：带增强功能的方法名 //第五个参数：带原始功能的方法名 save0Proxy = MethodProxy.create(Target.class,Proxy.class,&quot;()V&quot;,&quot;save&quot;,&quot;saveSuper&quot;); save1Proxy = MethodProxy.create(Target.class,Proxy.class,&quot;(I)V&quot;,&quot;save&quot;,&quot;saveSuper&quot;); save2Proxy = MethodProxy.create(Target.class,Proxy.class,&quot;(J)V&quot;,&quot;save&quot;,&quot;saveSuper&quot;);&#125;//带原始功能的方法 public void saveSuper() &#123;super.save();&#125; public void saveSuper(int i) &#123;super.save(i);&#125; public void saveSuper(long j) &#123;super.save(j);&#125;//带增强功能的方法 @Override public void save()&#123; //第一个参数：代理类对象 //第二个参数：当前正在执行的方法 //第三个参数：实参数组 //第四个参数：代理类对象 try &#123; methodInterceptor.intercept(this,save0,new Object[0], save0Proxy); &#125; catch (Throwable e) &#123; throw new UndeclaredThrowableException(e); &#125; &#125; @Override public void save(int i)&#123; try &#123; methodInterceptor.intercept(this,save1,new Object[]&#123;i&#125;, save1Proxy); &#125; catch (Throwable e) &#123; throw new UndeclaredThrowableException(e); &#125; &#125; @Override public void save(long j)&#123; try &#123; methodInterceptor.intercept(this,save2,new Object[]&#123;j&#125;, save2Proxy); &#125; catch (Throwable e) &#123; throw new UndeclaredThrowableException(e); &#125; &#125; cglib避免反射调用MethodProxy在调用invoke和invokeSuper时不会走反射途经，而是通过FastClass来避免反射，cglib在调用方法时，生成两个代理类（为FastClass的子类），代理类中的方法能避免反射 调用invoke在调用MethodProxy的create静态方法时，底层会创建一个FastClass子类（以下称代理类）来避免反射的调用（因为该代理类实现了fastClas太多功能，所以不直接继承FastClass类，而是选择其中两个功能进行实现） 1、当我们创建MethodProxy时，会传入signature（包括方法名字和参数返回值） 2、代理类中会根据传入的signature编写目标方法的编号（将传入的signature与自定义的signature进行比较） 3、代理类中根据获取方法的编号去调用方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TargetFastClass &#123; static Signature s0 = new Signature(&quot;save&quot;,&quot;()V&quot;); static Signature s1 = new Signature(&quot;save&quot;,&quot;(I)V&quot;); static Signature s2 = new Signature(&quot;save&quot;,&quot;(J)V&quot;); //获取目标方法的编号 /** * Target * save() 0 * save(int) 1 * save(long) 2 */ //signature：包括方法名字、参数返回值 public int getIndex(Signature signature)&#123; //根据方法名字和返回值类型编写编号 if (s0.equals(signature)) &#123; return 0; &#125; else if (s1.equals(signature)) &#123; return 1; &#125; else if (s2.equals(signature)) &#123; return 2; &#125; else &#123; return -1; &#125; &#125; //根据获取方法的编号，去正常调用目标对象的方法，不通过反射 public Object invoke(int index,Object target,Object[] args) &#123; if (index == 0) &#123; ((Target)target).save(); return null; &#125; else if (index == 1) &#123; ((Target)target).save((int) args[0]); return null; &#125; else if (index == 2) &#123; ((Target) target).save((long) args[0]); return null; &#125; else &#123; throw new RuntimeException(&quot;无此方法&quot;); &#125; &#125;&#125; 调用invokeSuper与上面调用invoke时步骤基本相同，唯一不同的是： 获取代理类中的方法编号时，应该获取的是带原始功能的方法了，而且在调用目标对象的方法时，也应该调用带原始功能的方法 原因：MethodProxy调用invokeSuper是在MethodInterceptor中执行的，增强功能已经在外面实现了，当获取到的是增强功能时，里面又间接调用了MethodInterceptor，进入循环调用 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ProxyFastClass &#123; static Signature s0 = new Signature(&quot;saveSuper&quot;,&quot;()V&quot;); static Signature s1 = new Signature(&quot;saveSuper&quot;,&quot;(I)V&quot;); static Signature s2 = new Signature(&quot;saveSuper&quot;,&quot;(J)V&quot;); //获取代理类中方法的编号 /** * Proxy * saveSuper() 0 * saveSuper(int) 1 * saveSuper(long) 2 */ //signature：包括方法名字、参数返回值 public int getIndex(Signature signature)&#123; //根据方法名字和返回值类型编写编号 if (s0.equals(signature)) &#123; return 0; &#125; else if (s1.equals(signature)) &#123; return 1; &#125; else if (s2.equals(signature)) &#123; return 2; &#125; else &#123; return -1; &#125; &#125; //根据获取方法的编号，去正常调用目标对象的方法，不通过反射 public Object invoke(int index,Object proxy,Object[] args) &#123; if (index == 0) &#123; ((Proxy)proxy).saveSuper(); return null; &#125; else if (index == 1) &#123; ((Proxy)proxy).saveSuper((int) args[0]); return null; &#125; else if (index == 2) &#123; ((Proxy) proxy).saveSuper((long) args[0]); return null; &#125; else &#123; throw new RuntimeException(&quot;无此方法&quot;); &#125; &#125; public static void main(String[] args) &#123; //创建对象 ProxyFastClass fastClass = new ProxyFastClass(); int index = fastClass.getIndex(new Signature(&quot;saveSuper&quot;, &quot;()V&quot;)); System.out.println(index); fastClass.invoke(0, new Proxy(), new Object[0]); &#125;&#125; 对比与jdk对比，jdk是调用17次时，针对一个方法产生一个代理类 cglib是MethodProxy调用的时候就产生代理，一个proxy代理类对应两个fastClass的子类 （一个是MethodProxy调用invoke时结合目标使用，一个是MethodProxy调用invokeSuper时结合代理使用） Spring选择代理 切点：增强的匹配规则 通知：增强的逻辑 切面：切点和通知组合 两个切面的概念 aspect &#x3D; ​ 通知1（advice）+ 切点1（pointcut） ​ 通知2（advice）+ 切点2（pointcut） ​ 通知3（advice）+ 切点3（pointcut） asvisor &#x3D; 更细粒度的切面，只包含一个通知和切点 在aspect生效之前，会被拆解成多个advisor 接口及目标类实现先创建一个包含又foo和bar方法的接口，再创建一个Target1目标类实现该接口 12345678910111213141516171819202122interface I1 &#123; void foo(); void bar();&#125;static class Target1 implements I1 &#123; public void foo() &#123; System.out.println(&quot;target1 foo&quot;); &#125; public void bar() &#123; System.out.println(&quot;target1 bar&quot;); &#125;&#125;static class Target2 &#123; public void foo() &#123; System.out.println(&quot;target2 foo&quot;); &#125; public void bar() &#123; System.out.println(&quot;target2 bar&quot;); &#125;&#125; 准备切点创建切点对象，调用setExpression设置切点表达式 12AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();pointcut.setExpression(&quot;execution(* foo())&quot;); 准备通知123456789MethodInterceptor advice = new MethodInterceptor() &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; System.out.println(&quot;before...&quot;); Object res = invocation.proceed();//调用目标 System.out.println(&quot;after...&quot;); return res; &#125;&#125;; 准备切面创建DefaultPointcutAdvisor对象，传入切点和通知 然后再创建ProxyFactory对象，添加目标对象和切面，最后通过代理对象调用方法完成测试 （ProxyFactory内部会根据不同的情况选择cglib或者jdk的代理） 123456789DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut,advice);ProxyFactory factory = new ProxyFactory();factory.setTarget(new Target1());//添加目标factory.addAdvisor(advisor);//添加切面I1 proxy = (I1) factory.getProxy();proxy.foo();proxy.bar(); 选择代理的方式**ProxyFactory内部存在一个成员变量proxyTargetClass决定spring的代理方式** 情况1proxyTargetClass = false，而且目标实现了接口, 使用 JdkDynamicAopProxy 实现（默认proxyTargetClass为alse） 1234567891011121314DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut,advice);Target1 target1 = new Target1();ProxyFactory factory = new ProxyFactory();factory.setTarget(target1);//添加目标factory.addAdvisor(advisor);//添加切面factory.setInterfaces(target1.getClass().getInterfaces());//添加目标类上实现的接口//factory.setProxyTargetClass(false);I1 proxy = (I1) factory.getProxy();proxy.foo();proxy.bar(); 情况2proxyTargetClass = false，而且目标没有接口, 使用 ObjenesisCglibAopProxy 实现 12345678910111213DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut,advice);Target1 target1 = new Target1();ProxyFactory factory = new ProxyFactory();factory.setTarget(target1);//添加目标factory.addAdvisor(advisor);//添加切面//factory.setProxyTargetClass(false);I1 proxy = (I1) factory.getProxy();proxy.foo();proxy.bar(); 情况3proxyTargetClass = true总是使用 ObjenesisCglibAopProxy 实现 12345678910111213DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut,advice);Target1 target1 = new Target1();ProxyFactory factory = new ProxyFactory();factory.setTarget(target1);//添加目标factory.addAdvisor(advisor);//添加切面factory.setProxyTargetClass(true);I1 proxy = (I1) factory.getProxy();proxy.foo();proxy.bar(); 切点匹配 先定义一个静态类T1，其中有用@Transactional注解的foo方法和一个普通的bar方法 再定义一个使用@Transactional注解标注的静态类T2 然后再定义一个用@Transactional注解标注的接口，内有方法foo，最后创建一个类实现该接口 123456789101112131415161718 static class T1 &#123; @Transactional public void foo() &#123; &#125; public void bar() &#123; &#125; &#125; @Transactional static class T2 &#123; public void foo() &#123; &#125; &#125; @Transactional interface I3 &#123; void foo(); &#125; static class T3 implements I3 &#123; public void foo() &#123; &#125; &#125;&gt;&#125; 1、创建AspectJExpressionPointcut对象，然后调用setExpression方法，在其中填写切点表达式（点我） 2、调用matches方法判断是否与切点表达式匹配，第一个参数为对应类的方法名，第二个参数为对应类的class 1234567891011121314public class A16 &#123; public static void main(String[] args) throws NoSuchMethodException &#123; //判断方法是否与切点表达式匹配 AspectJExpressionPointcut pointcut1 = new AspectJExpressionPointcut(); pointcut1.setExpression(&quot;execution(* bar())&quot;); System.out.println(pointcut1.matches(T1.class.getMethod(&quot;foo&quot;), T1.class)); System.out.println(pointcut1.matches(T1.class.getMethod(&quot;bar&quot;), T1.class)); //判断方法上的注解类型是否与切点表达式定义的类型匹配 AspectJExpressionPointcut pointcut2 = new AspectJExpressionPointcut(); pointcut2.setExpression(&quot;@annotation(org.springframework.transaction.annotation.Transactional)&quot;); System.out.println(pointcut2.matches(T1.class.getMethod(&quot;foo&quot;), T1.class)); System.out.println(pointcut2.matches(T1.class.getMethod(&quot;bar&quot;), T1.class)); &#125; 3、为了保证当出现T3类的情况时（实现了被注解标注的接口）@Transactional注解能够被匹配到，在spring内部并不是采用以上方法匹配@Transactional注解，而是创建StaticMethodMatcherPointcut对象并重写matches方法，在方法内部添加匹配注解的逻辑 spring探秘之组合注解的处理（点我） 12345678910111213141516171819202122//匹配@Transactional注解StaticMethodMatcherPointcut pointcut3 = new StaticMethodMatcherPointcut() &#123; @Override public boolean matches(Method method, Class&lt;?&gt; targetClass) &#123; //检查方法上是否添加@Transactional注解 MergedAnnotations annotations = MergedAnnotations.from(method); if (annotations.isPresent(Transactional.class)) &#123; return true; &#125; //检查类上是否添加@Transactional注解，并添加检查策略 annotations = MergedAnnotations.from(targetClass, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY); if (annotations.isPresent(Transactional.class))&#123; return true; &#125; return false; &#125;&#125;;//测试System.out.println(pointcut3.matches(T1.class.getMethod(&quot;foo&quot;), T1.class)); //trueSystem.out.println(pointcut3.matches(T1.class.getMethod(&quot;bar&quot;), T1.class)); //falseSystem.out.println(pointcut3.matches(T2.class.getMethod(&quot;foo&quot;), T2.class)); //trueSystem.out.println(pointcut3.matches(T3.class.getMethod(&quot;foo&quot;), T3.class)); //true @Aspect与Advisor 先准备一个高级切面类Aspect1和一个低级切面类Config，并把两个切面类注册进bean，添加处理@Bean的后处理器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&gt;public static void main(String[] args) &#123; GenericApplicationContext context = new GenericApplicationContext(); context.registerBean(&quot;aspect1&quot;,Aspect1.class); context.registerBean(&quot;config&quot;,Config.class); context.registerBean(ConfigurationClassPostProcessor.class); context.refresh(); for (String name : context.getBeanDefinitionNames()) &#123; System.out.println(name); &#125;&gt;&#125;&gt;static class Target1 &#123; public void foo() &#123; System.out.println(&quot;target1 foo&quot;); &#125;&gt;&#125;&gt;static class Target2 &#123; public void bar() &#123; System.out.println(&quot;target2 bar&quot;); &#125;&gt;&#125;&gt;@Aspect //高级切面类&gt;static class Aspect1 &#123; @Before(&quot;execution(* foo())&quot;) public void before() &#123; System.out.println(&quot;aspect1 before&quot;); &#125; @After(&quot;execution(* foo())&quot;) public void after() &#123; System.out.println(&quot;aspect1 after&quot;); &#125;&gt;&#125;&gt;@Configuration&gt;static class Config &#123; //低级切面：由一个切点和一个通知组成 @Bean public Advisor advisor3(MethodInterceptor advice3)&#123; //定义切点 AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); pointcut.setExpression(&quot;execution(* foo())&quot;); DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, advice3); return advisor; &#125; //定义通知 @Bean public MethodInterceptor advice3() &#123; return new MethodInterceptor() &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; System.out.println(&quot;advice3 before&quot;); Object res = invocation.proceed(); System.out.println(&quot;advice3 after&quot;); return res; &#125; &#125;; &#125;&gt;&#125; AnnotationAwareAspectJAutoProxyCreator 作用自动代理后处理器 AnnotationAwareAspectJAutoProxyCreator 会帮我们创建代理 通常代理创建的活在原始对象初始化后执行, 但碰到循环依赖会提前至依赖注入之前执行 高级的 @Aspect 切面会转换为低级的 Advisor 切面 findEligibleAdvisors方法解析某个类的切面，一部分切面是低级的，如准备代码中的advisor3；另一部分是高级的, 由解析 @Aspect 后获得。解析时会将高级切面解析成多个低级切面 12AnnotationAwareAspectJAutoProxyCreator creator = context.getBean(AnnotationAwareAspectJAutoProxyCreator.class);List&lt;Advisor&gt; advisors = creator.findEligibleAdvisors(Target1.class, &quot;target1&quot;); wrapIfNecessary方法判断是否有必要对目标进行代理，内部调用 findEligibleAdvisors, 只要返回集合不空, 则表示需要创建代理 如下面代码，因为在准备时Target2中的bar方法，没有与切点进行匹配，所以Target2在调用findEligibleAdvisors方法后获取的切面集合为空，所以没必要进行代理 1234Object o1 = creator.wrapIfNecessary(new Target1(), &quot;target1&quot;, &quot;target1&quot;);System.out.println(o1.getClass());Object o2 = creator.wrapIfNecessary(new Target2(), &quot;target2&quot;, &quot;target2&quot;);System.out.println(o2.getClass()); 代理创建时机Bean创建的三个重要阶段分别为：创建 -&gt; (?） 依赖注入 -&gt; 初始化 (?) 代理创建的时机有两个位置，一个是创建Bean和依赖注入之间，另一个是初始化之后 初始化之后下面代码中因为Bean1中有foo方法，所以Bean1将会被代理，而且在Bean2中还注入了Bean1。 在这种单向的依赖关系下（Bean2依赖Bean1），代理在Bean1的初始化之后创建，在代理创建之后，才继续执行Bean2的构造方法，在Bean2中注入Bean1的代理，最后完成Bean2的初始化 123456789101112131415161718192021222324252627282930313233343536//切面@Bean public Advisor advisor(MethodInterceptor advice) &#123; AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); pointcut.setExpression(&quot;execution(* foo())&quot;); return new DefaultPointcutAdvisor(pointcut, advice); &#125; //通知 @Bean public MethodInterceptor advice() &#123; return (MethodInvocation invocation) -&gt; &#123; System.out.println(&quot;before...&quot;); return invocation.proceed(); &#125;; &#125;static class Bean1 &#123; public void foo() &#123; &#125; public Bean1() &#123; System.out.println(&quot;Bean1()&quot;); &#125; @PostConstruct public void init() &#123; System.out.println(&quot;Bean1 init()&quot;); &#125; &#125; static class Bean2 &#123; public Bean2() &#123; System.out.println(&quot;Bean2()&quot;); &#125; @Autowired public void setBean1(Bean1 bean1) &#123; System.out.println(&quot;Bean2 setBean1(bean1) class is: &quot; + bean1.getClass()); &#125; @PostConstruct public void init() &#123; System.out.println(&quot;Bean2 init()&quot;); &#125; &#125; 创建Bean和依赖注入之间下面代码中因为Bean1中有foo方法，所以Bean1将会被代理，而且在Bean1中注入了Bean2，在Bean2中注入了Bean1。在这种循环依赖的关系下，代理在Bean1的构造和Bean1的依赖注入之间创建的。 原因：因为在Bean1中需要注入Bean2，所以执行完Bean1的构造后，就执行Bean2的构造，因为Bean2中需要注入Bean1的代理，所以再创建Bean1的代理。 12345678910111213141516171819202122232425262728293031323334353637383940 @Bean public Advisor advisor(MethodInterceptor advice) &#123; AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); pointcut.setExpression(&quot;execution(* foo())&quot;); return new DefaultPointcutAdvisor(pointcut, advice); &#125; @Bean public MethodInterceptor advice() &#123; return (MethodInvocation invocation) -&gt; &#123; System.out.println(&quot;before...&quot;); return invocation.proceed(); &#125;; &#125;static class Bean1 &#123; public void foo() &#123; &#125; public Bean1() &#123; System.out.println(&quot;Bean1()&quot;); &#125; @Autowired public void setBean2(Bean2 bean2) &#123; System.out.println(&quot;Bean1 setBean2(bean2) class is: &quot; + bean2.getClass()); &#125; @PostConstruct public void init() &#123; System.out.println(&quot;Bean1 init()&quot;); &#125; &#125; static class Bean2 &#123; public Bean2() &#123; System.out.println(&quot;Bean2()&quot;); &#125; @Autowired public void setBean1(Bean1 bean1) &#123; System.out.println(&quot;Bean2 setBean1(bean1) class is: &quot; + bean1.getClass()); &#125; @PostConstruct public void init() &#123; System.out.println(&quot;Bean2 init()&quot;); &#125; &#125; 切面顺序控制使用@Order注解进行控制，默认是最低优先级，值越小优先级越高 注意：可以加在高级切面类上，但对于低级切面类，需要在DefaultPointcutAdvisor类中setOrder 1234567891011121314151617181920212223242526@Configuration static class Config &#123; //低级切面 @Bean public Advisor advisor3(MethodInterceptor advice3)&#123; //定义切点 AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); pointcut.setExpression(&quot;execution(* foo())&quot;); DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, advice3); advisor.setOrder(2); return advisor; &#125; //定义通知 @Bean public MethodInterceptor advice3() &#123; return new MethodInterceptor() &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; System.out.println(&quot;advice3 before&quot;); Object res = invocation.proceed(); System.out.println(&quot;advice3 after&quot;); return res; &#125; &#125;; &#125; &#125; 高级切面转为低级切面(@Before为例)类似的有 AspectJAroundAdvice (环绕通知) AspectJAfterReturningAdvice AspectJAfterThrowingAdvice (环绕通知) AspectJAfterAdvice (环绕通知) 1234567891011121314151617181920212223242526272829303132333435 static class Aspect &#123; @Before(&quot;execution(* foo())&quot;) public void before1() &#123; System.out.println(&quot;before1&quot;); &#125; @Before(&quot;execution(* foo())&quot;) public void before2() &#123; System.out.println(&quot;before2&quot;); &#125; &#125; static class Target &#123; public void foo() &#123; System.out.println(&quot;target foo&quot;); &#125; &#125;public static void main(String[] args) throws Throwable &#123; AspectInstanceFactory factory = new SingletonAspectInstanceFactory(new Aspect()); // 高级切面转低级切面类 List&lt;Advisor&gt; list = new ArrayList&lt;&gt;(); for (Method method : Aspect.class.getDeclaredMethods()) &#123; //判断方法上是否有加@Before注解 if (method.isAnnotationPresent(Before.class)) &#123; // 根据@Before注解的value值来生成一个切点对象 String expression = method.getAnnotation(Before.class).value();//切点表达式 AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();//解析后生成的切点对象 pointcut.setExpression(expression); // 通知类 AspectJMethodBeforeAdvice advice = new AspectJMethodBeforeAdvice(method, pointcut, factory); // 低级切面 Advisor advisor = new DefaultPointcutAdvisor(pointcut, advice); list.add(advisor); &#125; &#125; for (Advisor advisor : list) &#123; System.out.println(advisor); &#125;&#125; 静态通知调用不同的通知统一转换成环绕通知ProxyFactory 在创建代理时，最后调用 advice 的是一个 MethodInvocation 对象（调用链对象）1、因为 advisor 有多个, 且一个套一个调用, 因此需要一个调用链对象2、MethodInvocation调用次序如下 3、为了实现上图所示的调用次序，环绕通知最适合，因此其他 before、afterReturning 都会被转换成环绕通知4、统一转换为环绕通知, 体现的是设计模式中的适配器模式（点击查看设计模式） 统一转换为 MethodInterceptor 环绕通知, 这体现在方法中的 Interceptors 上 MethodBeforeAdviceAdapter 将 @Before AspectJMethodBeforeAdvice 适配为 MethodBeforeAdviceInterceptor AfterReturningAdviceAdapter 将 @AfterReturning AspectJAfterReturningAdvice 适配为 AfterReturningAdviceInterceptor 对外是为了方便使用要区分 before、afterReturning 对内统一都是环绕通知, 统一用 MethodInterceptor 表示 定义了一个高级切面，里面含有多个通知类型 12345678910111213141516171819202122232425262728293031static class Aspect &#123; @Before(&quot;execution(* foo())&quot;) public void before1() &#123;System.out.println(&quot;before1&quot;);&#125; @Before(&quot;execution(* foo())&quot;) public void before2() &#123;System.out.println(&quot;before2&quot;);&#125; public void after() &#123;System.out.println(&quot;after&quot;);&#125; @AfterReturning(&quot;execution(* foo())&quot;) public void afterReturning() &#123;System.out.println(&quot;afterReturning&quot;);&#125; @AfterThrowing(&quot;execution(* foo())&quot;) public void afterThrowing(Exception e) &#123; System.out.println(&quot;afterThrowing &quot; + e.getMessage()); &#125; @Around(&quot;execution(* foo())&quot;) public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; try &#123; System.out.println(&quot;around...before&quot;); return pjp.proceed(); &#125; finally &#123; System.out.println(&quot;around...after&quot;); &#125; &#125;&#125;static class Target &#123; public void foo() &#123;System.out.println(&quot;target foo&quot;); &#125;&#125; 将不同的通知类型统一转换成环绕通知 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@SuppressWarnings(&quot;all&quot;)public static void main(String[] args) throws Throwable &#123; AspectInstanceFactory factory = new SingletonAspectInstanceFactory(new Aspect()); //高级切面转低级切面类 List&lt;Advisor&gt; list = new ArrayList&lt;&gt;(); for (Method method : Aspect.class.getDeclaredMethods()) &#123; if (method.isAnnotationPresent(Before.class)) &#123; // 解析切点 String expression = method.getAnnotation(Before.class).value(); AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); pointcut.setExpression(expression); // 通知类 AspectJMethodBeforeAdvice advice = new AspectJMethodBeforeAdvice(method, pointcut, factory); // 切面 Advisor advisor = new DefaultPointcutAdvisor(pointcut, advice); list.add(advisor); &#125; else if (method.isAnnotationPresent(AfterReturning.class)) &#123; // 解析切点 String expression = method.getAnnotation(AfterReturning.class).value(); AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); pointcut.setExpression(expression); // 通知类 AspectJAfterReturningAdvice advice = new AspectJAfterReturningAdvice(method, pointcut, factory); // 切面 Advisor advisor = new DefaultPointcutAdvisor(pointcut, advice); list.add(advisor); &#125; else if (method.isAnnotationPresent(Around.class)) &#123; // 解析切点 String expression = method.getAnnotation(Around.class).value(); AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); pointcut.setExpression(expression); // 通知类 AspectJAroundAdvice advice = new AspectJAroundAdvice(method, pointcut, factory); // 切面 Advisor advisor = new DefaultPointcutAdvisor(pointcut, advice); list.add(advisor); &#125; &#125; for (Advisor advisor : list) &#123; System.out.println(advisor); &#125; Target target = new Target(); ProxyFactory proxyFactory = new ProxyFactory(); proxyFactory.setTarget(target); //设置目标 proxyFactory.addAdvice(ExposeInvocationInterceptor.INSTANCE); // 准备把 MethodInvocation 放入当前线程 proxyFactory.addAdvisors(list); //关联低级切面 /* * 将除了环绕通知以外的通知，统一转为环绕通知 * 参数一：目标方法对象 * 参数二：目标的class */ List&lt;Object&gt; methodInterceptorList = proxyFactory.getInterceptorsAndDynamicInterceptionAdvice(Target.class.getMethod(&quot;foo&quot;), Target.class); //省略了对低级切面进行排序 for (Object o : methodInterceptorList) &#123; System.out.println(o); &#125;&#125; 调用链执行过程注意：在调用链执行的过程中，某些通知内部有可能会使用到调用链对象。所以必须使用一个最外层的环绕通知，将 MethodInvocation 放入当前线程 1234567891011121314//创建并执行调用链 (多个环绕通知 + 目标)MethodInvocation methodInvocation = new ReflectiveMethodInvocation( /* * 参数一：代理对象 * 参数二：目标对象 * 参数三：目标中对应的方法 * 参数四：目标方法的实参数组 * 参数五：目标类型 * 参数六：环绕通知集合 */ null, target, Target.class.getMethod(&quot;foo&quot;), new Object[0], Target.class, methodInterceptorList);//将环绕通知一层层逐一进行调用methodInvocation.proceed(); 模拟实现调用链在proceed方法内部首先需要将可调用次数count（初始化为1）与通知的list集合比较，如果可调用次数大，说明集合为空，没有通知，则直接调用目标。如果集合不为空，那么就递归调用下一个通知 注意：此处递归调用并不是直接在proceed方法内部调用proceed而是通过interceptor调用invoke，从而间接地在切面中调用proceed方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061static class Target &#123; public void foo() &#123;System.out.println(&quot;Target.foo()&quot;);&#125;&#125;static class Advice1 implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; System.out.println(&quot;Advice1 before...&quot;); Object res = invocation.proceed(); //调用下一个通知或目标 System.out.println(&quot;Advice1 after...&quot;); return res; &#125;&#125;static class Advice2 implements MethodInterceptor &#123; public Object invoke(MethodInvocation invocation) throws Throwable &#123; System.out.println(&quot;Advice2.before...&quot;); Object result = invocation.proceed(); // 调用下一个通知或目标 System.out.println(&quot;Advice2.after...&quot;); return result; &#125;&#125;static class MyInvocation implements MethodInvocation &#123; private Object target; private Method method; private Object[] args; List&lt;MethodInterceptor&gt; methodInterceptorList; // 环绕通知集合 private int count = 1; // 调用次数 public MyInvocation(Object target, Method method, Object[] args, List&lt;MethodInterceptor&gt; methodInterceptorList) &#123; this.target = target; this.method = method; this.args = args; this.methodInterceptorList = methodInterceptorList; &#125; // 调用每一个环绕通知, 调用目标 @Override public Object proceed() throws Throwable &#123; if (count &gt; methodInterceptorList.size())&#123; //调用目标，返回并结束递归 return method.invoke(target, args); &#125; //调用通知，count+1 MethodInterceptor interceptor = methodInterceptorList.get(count++ - 1); return interceptor.invoke(this); &#125; @Override public Method getMethod() &#123;return method;&#125; @Override public Object[] getArguments() &#123;return args;&#125; @Override public Object getThis() &#123;return target;&#125; @Override public AccessibleObject getStaticPart() &#123;return method;&#125;&#125; 测试 123456789public static void main(String[] args) throws Throwable &#123; Target target = new Target(); List&lt;MethodInterceptor&gt; list = List.of( new Advice1(), new Advice2() ); MyInvocation invocation = new MyInvocation(target, Target.class.getMethod(&quot;foo&quot;), new Object[0], list); invocation.proceed();&#125; 动态通知调用","categories":[{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/categories/spring%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"},{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/tags/spring%E9%AB%98%E7%BA%A7/"}]},{"title":"容器与Bean","slug":"容器与Bean","date":"2022-08-09T14:41:36.000Z","updated":"2022-08-10T01:50:44.647Z","comments":true,"path":"2022/08/09/容器与Bean/","link":"","permalink":"http://www.hzzzzzy.icu/2022/08/09/%E5%AE%B9%E5%99%A8%E4%B8%8EBean/","excerpt":"","text":"BeanFactory它是ApplicationContext的父接口 它才是Spring的核心容器，主要的ApplicationContext的实现都组合了它的功能 比如使用ApplicationContext的getBean方法，实际上先拿到BeanFactory对象，再去调用BeanFactory的getBean方法 BeanFactory表面上只有getBean功能实际上，控制反转，基本的依赖注入，直至Bean的生命周期都是由它的实现类提供 ApplicationContext功能 MessageSource：处理国际化资源的能力（翻译） 比如 getMessage方法 RessourcePatternResolver：通配符匹配资源的能力 比如 getResources方法 1234567//表示在resources目录下的META-INF子目录下的spring.factories文件和jar包内的......//*号表示也可以jar内进行搜索Resource[] resources = context.getResources(&quot;classpath*:META-INF/spring.factories&quot;);for (Resource resource : resources) &#123; System.out.println(resource);&#125; ApplicationEventPublisher：发布事件能力 比如 publishEvent方法 1234567891011121314151617181920//获取Component1然后进行注册context.getBean(Component1.class).register();//在Component1中进行声明private static final Logger log = LoggerFactory.getLogger(Component1.class);//该容器对象具备发送事件的功能@Autowiredprivate ApplicationEventPublisher context; //事件发生器public void register() &#123; log.debug(&quot;用户注册&quot;); context.publishEvent(new UserRegisteredEvent(this));&#125;//在Component2中监听该事件private static final Logger log = LoggerFactory.getLogger(Component2.class);@EventListenerpublic void aaa(UserRegisteredEvent event) &#123; log.debug(&quot;&#123;&#125;&quot;, event); log.debug(&quot;发送短信&quot;);&#125; EnvironmentCapable：读取环境信息 比如getProperty方法 123//获取properties文件和系统环境变量对应键的值System.out.println(context.getEnvironment().getProperty(&quot;java_home&quot;));System.out.println(context.getEnvironment().getProperty(&quot;server.port&quot;)); BeanFactory的实现给Bean添加定义并进行注册123456DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();// bean 的定义（class, scope, 初始化, 销毁）AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope(&quot;singleton&quot;).getBeanDefinition();//注册beanFactory.registerBeanDefinition(&quot;config&quot;, beanDefinition); 添加 BeanFactory 后处理器1234567891011121314151617181920212223242526272829303132333435363738394041424344// 给 BeanFactory 添加一些常用的后处理器AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);//如果只是添加后处理器不进行扩展，则无法解析@Confident和@bean注解// BeanFactory 后处理器主要功能，补充了一些 bean 定义// getBeansOfType 根据类型获取多个bean（bean后处理器）beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values().forEach(beanFactoryPostProcessor -&gt; &#123; beanFactoryPostProcessor.postProcessBeanFactory(beanFactory); //执行beanFactory 后处理器&#125;);@Configuration static class Config &#123; @Bean public Bean1 bean1() &#123;return new Bean1();&#125; @Bean public Bean2 bean2() &#123;return new Bean2();&#125; @Bean public Bean3 bean3() &#123;return new Bean3();&#125; @Bean public Bean4 bean4() &#123;return new Bean4();&#125; &#125; interface Inter &#123; &#125; static class Bean3 implements Inter &#123; &#125; static class Bean4 implements Inter &#123; &#125; static class Bean1 &#123; private static final Logger log = LoggerFactory.getLogger(Bean1.class); public Bean1() &#123; log.debug(&quot;构造 Bean1()&quot;); &#125; @Autowired private Bean2 bean2; public Bean2 getBean2() &#123;return bean2;&#125; //同时添加两个注解（后处理器的顺序决定了哪个先被解析） @Autowired @Resource(name = &quot;bean4&quot;) private Inter bean3; public Inter getInter() &#123;return bean3;&#125;&#125; static class Bean2 &#123; private static final Logger log = LoggerFactory.getLogger(Bean2.class); public Bean2() &#123; log.debug(&quot;构造 Bean2()&quot;); &#125; &#125; 添加 Bean 后处理器12345// Bean 后处理器, 针对 bean 的生命周期的各个阶段提供扩展, 例如 @Autowired @Resource ...beanFactory.getBeansOfType(BeanPostProcessor.class).values().stream() .forEach(beanPostProcessor -&gt; &#123; beanFactory.addBeanPostProcessor(beanPostProcessor); //建立Bean工厂和后处理器的关系&#125;); 后处理器器顺序123//默认是Common的后处理器排在前面，Autowired的排在后面System.out.println(&quot;Common:&quot; + (Ordered.LOWEST_PRECEDENCE - 3));System.out.println(&quot;Autowired:&quot; + (Ordered.LOWEST_PRECEDENCE - 2)); 总结BeanFactory总结： 不会主动调用 BeanFactory 后处理器 不会主动添加 Bean 后处理器 不会主动初始化单例 不会解析beanFactory 还不会解析 ${ } 与 #{ } Bean后处理器会有排序的逻辑 ApplicationContext的实现ClassPathXmlApplicationContext在类路径下读取XML配置文件 1234567891011121314private static void testClassPathXmlApplicationContext() &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;a02.xml&quot;); for (String name : context.getBeanDefinitionNames()) &#123; System.out.println(name); &#125; System.out.println(context.getBean(Bean2.class).getBean1()); /** * 结果： * bean1 * bean2 * com.itheima.a02.A02$Bean1@6392827e */&#125; 1234567//a02.xml&lt;!-- 控制反转, 让 bean1和bean2 被 Spring 容器管理 --&gt;&lt;bean id=&quot;bean1&quot; class=&quot;com.itheima.a02.A02.Bean1&quot;/&gt;&lt;bean id=&quot;bean2&quot; class=&quot;com.itheima.a02.A02.Bean2&quot;&gt; &lt;!-- 依赖注入, 让 bean2 建立与 bean1 的依赖关系 --&gt; &lt;property name=&quot;bean1&quot; ref=&quot;bean1&quot;/&gt;&lt;/bean&gt; FileSystemXmlApplicationContext在磁盘路径下读取XML配置文件 1234private static void testFileSystemXmlApplicationContext() &#123; FileSystemXmlApplicationContext context = new FileSystemXmlApplicationContext(&quot;src\\\\main\\\\resources\\\\a02.xml&quot;);&#125; AnnotationConfigApplicationContext基于java配置类来完成 1234567891011121314151617181920212223242526private static void testAnnotationConfigApplicationContext() &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Config.class);&#125;@Configurationstatic class Config &#123; @Bean public Bean1 bean1() &#123;return new Bean1();&#125; @Bean public Bean2 bean2(Bean1 bean1) &#123; Bean2 bean2 = new Bean2(); bean2.setBean1(bean1); return bean2; &#125;&#125;static class Bean1 &#123; &#125;static class Bean2 &#123; private Bean1 bean1; public void setBean1(Bean1 bean1) &#123; this.bean1 = bean1; &#125; public Bean1 getBean1() &#123; return bean1; &#125;&#125; AnnotationConfigServletWebServerApplicationContext基于 java 配置类来创建，用于 web 环境 1234567private static void testAnnotationConfigServletWebServerApplicationContext() &#123; AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext(WebConfig.class); for (String name : context.getBeanDefinitionNames()) &#123; System.out.println(name); &#125;&#125; 123456789101112131415161718@Configurationstatic class WebConfig &#123; @Bean //产生内嵌的 tomcat 容器 public ServletWebServerFactory servletWebServerFactory()&#123;return new TomcatServletWebServerFactory();&#125; @Bean //创建 dispatcherServlet 对象 public DispatcherServlet dispatcherServlet() &#123;return new DispatcherServlet();&#125; @Bean //将 dispatcherServlet 注册到tomcat容器中 public DispatcherServletRegistrationBean registrationBean(DispatcherServlet dispatcherServlet) &#123; return new DispatcherServletRegistrationBean(dispatcherServlet, &quot;/&quot;); &#125; @Bean(&quot;/hello&quot;) public Controller controller1() &#123; return (request, response) -&gt; &#123; response.getWriter().print(&quot;hello&quot;); return null; &#125;; &#125;&#125; bean生命周期 在各个阶段里都会有由bean后处理器提供的功能增强 bean的后处理器 创建前后的增强 postProcessBeforeInstantiation 这里返回的对象若不为 null 会替换掉原本的 bean，并且仅会走 postProcessAfterInitialization 流程 postProcessAfterInstantiation 这里如果返回 false 会跳过依赖注入阶段 依赖注入前的增强 postProcessProperties 如 @Autowired、@Value、@Resource 初始化前后的增强 postProcessBeforeInitialization 这里返回的对象会替换掉原本的 bean 如 @PostConstruct、@ConfigurationProperties postProcessAfterInitialization 这里返回的对象会替换掉原本的 bean 如代理增强 销毁之前的增强 postProcessBeforeDestruction 如 @PreDestroy 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Componentpublic class MyBeanPostProcessor implements InstantiationAwareBeanPostProcessor, DestructionAwareBeanPostProcessor &#123; private static final Logger log = LoggerFactory.getLogger(MyBeanPostProcessor.class); //postProcessBeforeDestruction：在销毁之前执行 bean 后处理器 @Override public void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException &#123; if (beanName.equals(&quot;lifeCycleBean&quot;)) log.debug(&quot;&lt;&lt;&lt;&lt;&lt;&lt; 销毁之前执行, 如 @PreDestroy&quot;); &#125; //postProcessBeforeInstantiation：在实例化之前执行 @Override public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123; if (beanName.equals(&quot;lifeCycleBean&quot;)) log.debug(&quot;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之前执行, 这里返回的对象会替换掉原本的 bean&quot;); return null; &#125; //postProcessAfterInstantiation：实例化之后执行，如果返回 false 会跳过依赖注入阶段，返回true则不会跳过 @Override public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException &#123; if (beanName.equals(&quot;lifeCycleBean&quot;)) &#123; log.debug(&quot;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之后执行&quot;); &#125; return true; &#125; //postProcessProperties：依赖注入阶段执行 @Override public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException &#123; if (beanName.equals(&quot;lifeCycleBean&quot;)) log.debug(&quot;&lt;&lt;&lt;&lt;&lt;&lt; 依赖注入阶段执行, 如 @Autowired、@Value、@Resource&quot;); return pvs; &#125; //postProcessBeforeInitialization：初始化之前执行 @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; if (beanName.equals(&quot;lifeCycleBean&quot;)) log.debug(&quot;&lt;&lt;&lt;&lt;&lt;&lt; 初始化之前执行, 这里返回的对象会替换掉原本的 bean, 如 @PostConstruct、@ConfigurationProperties&quot;); return bean; &#125; //postProcessAfterInitialization：初始化之后执行 @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if (beanName.equals(&quot;lifeCycleBean&quot;)) log.debug(&quot;&lt;&lt;&lt;&lt;&lt;&lt; 初始化之后执行, 这里返回的对象会替换掉原本的 bean, 如代理增强&quot;); return bean; &#125;&#125; 模板方法设计模式12345678910111213141516171819202122232425public static void main(String[] args) &#123; MyBeanFactory beanFactory = new MyBeanFactory(); beanFactory.addBeanPostProcessor(bean -&gt; System.out.println(&quot;解析 @Autowired&quot;)); beanFactory.addBeanPostProcessor(bean -&gt; System.out.println(&quot;解析 @Resource&quot;)); beanFactory.getBean();&#125;static class MyBeanFactory &#123; public Object getBean() &#123; Object bean = new Object(); System.out.println(&quot;构造 &quot; + bean); System.out.println(&quot;依赖注入 &quot; + bean); // @Autowired, @Resource for (BeanPostProcessor processor : processors) &#123; processor.inject(bean); &#125; System.out.println(&quot;初始化 &quot; + bean); return bean; &#125; private List&lt;BeanPostProcessor&gt; processors = new ArrayList&lt;&gt;(); //后处理器集合 public void addBeanPostProcessor(BeanPostProcessor processor) &#123;processors.add(processor);&#125;&#125;static interface BeanPostProcessor &#123; public void inject(Object bean); // 对依赖注入阶段的扩展&#125; Bean后处理器 前言： 1、先创建一个干净容器 1GenericApplicationContext context = new GenericApplicationContext(); 2、用原始形式注入bean 123context.registerBean(&quot;bean1&quot;, Bean1.class);context.registerBean(&quot;bean2&quot;, Bean2.class);context.registerBean(&quot;bean3&quot;, Bean3.class); 3、利用后处理器进行加载测试4、初始化容器，并打印 123//执行beanFactory后处理器, 添加bean后处理器, 初始化所有单例context.refresh();System.out.println(context.getBean(Bean1.class)); 5、销毁容器 1context.refresh(); AutowiredAnnotationBeanPostProcessor后处理器在依赖注入阶段，解析@Autowired和@Value注解 123456//解析@Value注解的值注入问题，暂时不要求掌握context.getDefaultListableBeanFactory() .setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());//解析@Autowired @Valuecontext.registerBean(AutowiredAnnotationBeanPostProcessor.class); 运行过程分析执行依赖注入的 postProcessProperties 方法 1234567891011121314// 1. 查找哪些属性、方法加了 @Autowired, 这称之为 InjectionMetadata AutowiredAnnotationBeanPostProcessor processor = new AutowiredAnnotationBeanPostProcessor(); processor.setBeanFactory(beanFactory); Bean1 bean1 = new Bean1(); Method findAutowiringMetadata = AutowiredAnnotationBeanPostProcessor.class.getDeclaredMethod(&quot;findAutowiringMetadata&quot;, String.class, Class.class, PropertyValues.class); findAutowiringMetadata.setAccessible(true); //2、获取 Bean1 上加了 @Value @Autowired 的成员变量，方法参数信息 InjectionMetadata metadata = (InjectionMetadata) findAutowiringMetadata.invoke(processor, &quot;bean1&quot;, Bean1.class, null); System.out.println(metadata); //3、调用 InjectionMetadata 来进行依赖注入, 注入时按类型查找值 metadata.inject(bean1, &quot;bean1&quot;, null); System.out.println(bean1); 1234567891011121314151617181920212223//4、inject内部//4.1、成员变量注入Field bean3 = Bean1.class.getDeclaredField(&quot;bean3&quot;);//将成员变量信息进行封装DependencyDescriptor dd1 = new DependencyDescriptor(bean3, false);//根据成员变量信息得到类型，进行根据类型找到容器中符合此类型中的一个beanObject o = beanFactory.doResolveDependency(dd1, null, null, null);System.out.println(o);//4.2、方法注入Method setBean2 = Bean1.class.getDeclaredMethod(&quot;setBean2&quot;, Bean2.class);//将方法进行封装（以参数为单位进行封装，此处的0指的是第一个参数）DependencyDescriptor dd2 = new DependencyDescriptor(new MethodParameter(setBean2, 0), true);//根据方法参数的类型在容器中找到符合此类型的beanObject o1 = beanFactory.doResolveDependency(dd2, null, null, null);System.out.println(o1);//4.3、值注入Method setHome = Bean1.class.getDeclaredMethod(&quot;setHome&quot;, String.class);DependencyDescriptor dd3 = new DependencyDescriptor(new MethodParameter(setHome, 0), true);Object o2 = beanFactory.doResolveDependency(dd3, null, null, null);System.out.println(o2); 总结： AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata 用来获取某个 bean 上加了 @Value @Autowired 的成员变量，方法参数的信息，表示为 InjectionMetadata InjectionMetadata 可以完成依赖注入 InjectionMetadata 内部根据成员变量，方法参数封装为 DependencyDescriptor 类型 有了 DependencyDescriptor，就可以利用 beanFactory.doResolveDependency 方法进行基于类型的查找 CommonAnnotationBeanPostProcessor后处理器依赖注入阶段解析@Resource，初始化前解析@PostConstruct，销毁前@PreDestroy注解 1context.registerBean(CommonAnnotationBeanPostProcessor.class); ConfigurationPropertiesBindingPostProcessor后处理器初始化前@ConfigurationProperties 1ConfigurationPropertiesBindingPostProcessor.register(context.getDefaultListableBeanFactory()); BeanFactory后处理器ConfigurationClassPostProcessor后处理器可以用来解析@ComponentScan、@Bean、@Import、@ImportResource注解 1context.registerBean(ConfigurationClassPostProcessor.class); MapperScannerConfigurer后处理器解析@MapperScanner注解 123context.registerBean(MapperScannerConfigurer.class, bd -&gt; &#123; bd.getPropertyValues().add(&quot;basePackage&quot;, &quot;com.itheima.a05.mapper&quot;);&#125;); 模拟实现@ComponentScan注解模拟实现@ComponentScan（点我跳转） 模拟解析Mapper接口解析Mapper接口（点我跳转） 模拟解析@Bean注解解析@Bean注解（点我跳转） Aware接口及InitializingBean 接口Aware 接口用于注入一些与容器相关信息 1、BeanNameAware：注入 bean 的名字 2、BeanFactoryAware：注入 BeanFactory 容器 3、ApplicationContextAware：注入 ApplicationContext 容器 InitializingBean 接口提供了一种内置的初始化手段 为什么有些功能@Autowired可以实现，还要用Aware接口 内置的注入和初始化不受扩展功能的影响，总会被执行 而扩展功能受某些情况影响可能会失效 因此 Spring 框架内部的类常用内置注入和初始化 配置类 @Autowired 失效分析一开始执行beanFactory，而我们配置的beanFactory是通过工厂方法的模式进行配置的，这个方法要进行调用，前提是配置类对象创建了 java配置类包含BeanFactoryPostProcessor的情况，因此要创建其中的BeanFactoryPostProcessor必须提前创建Java配置类，而此时BeanPostProcessor还没准备好，也就导致@Autowired等注解失效 12345678910111213141516171819202122232425262728293031@Configurationpublic class MyConfig1 &#123; private static final Logger log = LoggerFactory.getLogger(MyConfig1.class); @Autowired public void setApplicationContext(ApplicationContext applicationContext) &#123; log.debug(&quot;注入 ApplicationContext&quot;); &#125; @PostConstruct public void init() &#123; log.debug(&quot;初始化&quot;); &#125; @Bean // beanFactory 后处理器 public BeanFactoryPostProcessor processor1() &#123; return beanFactory -&gt; &#123; log.debug(&quot;执行 processor1&quot;); &#125;; &#125;&#125;public class test &#123; private static final Logger log = LoggerFactory.getLogger(test.class); public static void main(String[] args) &#123; GenericApplicationContext context = new GenericApplicationContext(); context.registerBean(&quot;myConfig1&quot;, MyConfig1.class); context.refresh(); // 1. beanFactory 后处理器, 2. 添加 bean 后处理器, 3. 初始化单例 context.close(); &#125;&#125; Bean的初始化和销毁Bean的初始化执行顺序1、@PostConstruct 标注的初始化方法 2、实现InitializingBean 接口的初始化方法 3、@Bean(initMethod) 指定的初始化方法 Bean的销毁执行顺序1、@PreDestroy 标注的销毁方法 2、DisposableBean 接口的销毁方法 3、@Bean(destroyMethod) 指定的销毁方法 Scope singleton是容器默认的scope。scope为singleton的时候，在Spring的IoC容器中只存在一个实例，所有对该对象的引用将共享这个实例。该实例从容器启动，并因为第一次被请求而初始化后，将一直存活到容器退出，也就是说，它与IOC容器“几乎”拥有相同的寿命 singleton：容器启动时创建（未设置延迟），容器关闭时销毁 对于那些请求方不能共享的对象实例，应该将其bean定义的scope设置为prototype。这样，每个请求方可以得到自己对应的一个对象实例。通常，声明为prototype的scope的bean定义类型，都是一些有状态的，比如保存每个顾客信息的对象 prototype，每次使用时创建，不会自动销毁，需要调用 DefaultListableBeanFactory.destroyBean(bean) 销毁 在Spring容器中，即XmlWebApplicationContext会为每个HTTP请求创建一个全新的Request-Processor对象供当前请求使用，当请求结束后，该对象实生命周期就结束。 request，每次请求用到此 bean 时创建，请求结束时销毁 Spring容器会为每个独立的session创建属于它们自己全新的UserPreferences对象实例。放到session中的最普遍的信息就是用户登录信息， session，每个会话用到此 bean 时创建，会话结束时销毁 application，web 容器用到此 bean 时创建，容器停止时销毁 Scope失效分析 存在一个单例对象E 1234567891011121314&gt;@Component&gt;public class E &#123;&gt;private static final Logger log = LoggerFactory.getLogger(E.class);&gt;@Autowired&gt;private F f;&gt;public E() &#123;log.info(&quot;E()&quot;);&#125;&gt;@Autowired&gt;public void setF(F f) &#123; this.f = f; log.info(&quot;setF(F f) &#123;&#125;&quot;, f.getClass());&gt;&#125;&gt;public F getF() &#123;return f;&#125;&gt;&#125; 要注入的对象 F 期望是多例 123456789&gt;@Component&gt;@Scope(&quot;prototype&quot;)&gt;public class F &#123; private static final Logger log = LoggerFactory.getLogger(F.class); public F() &#123; log.info(&quot;F()&quot;); &#125;&gt;&#125; 测试 12345&gt;E e = context.getBean(E.class);&gt;F f1 = e.getF();&gt;F f2 = e.getF();&gt;System.out.println(f1);&gt;System.out.println(f2); 输出 12&gt;com.itheima.demo.cycle.F@6622fc65&gt;com.itheima.demo.cycle.F@6622fc65 发现它们是同一个对象，而不是期望的多例对象 对于单例对象来讲，依赖注入仅发生了一次，后续再没有用到多例的 F，因此 E 用的始终是第一次依赖注入的 F 在注入F时，使用 @Lazy 生成代理（代理对象虽然还是同一个但当每次使用代理对象的任意方法时，由代理创建新的 f 对象） 方法一：使用@Lazy代理 123@Lazy@Autowiredprivate F f; 方法二：在目标类上的Scope注解里添加proxyMode属性proxyMode = ScopedProxyMode.TARGET_CLASS 1234@Scope(value = &quot;prototype&quot;, proxyMode = ScopedProxyMode.TARGET_CLASS)@Componentpublic class F2 &#123;&#125; 方法三：在注入时，通过注入一个对象工厂来完成多例的创建 123456@Autowiredprivate ObjectFactory&lt;F&gt; f;public F getF() &#123; return f.getObject();&#125; 方法四：在注入时，通过注入ApplicationContext的方式来完成多例的创建 123456@Autowiredprivate ApplicationContext context;public F getF() &#123; return context.getBean(F.class);&#125; 方法一和二都是通过反射原理完成多例的创建，性能相比后两种差一点","categories":[{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/categories/spring%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"},{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/tags/spring%E9%AB%98%E7%BA%A7/"}]},{"title":"模拟解析@Bean注解","slug":"模拟解析Bean注解","date":"2022-08-09T13:57:50.000Z","updated":"2022-08-09T14:54:40.428Z","comments":true,"path":"2022/08/09/模拟解析Bean注解/","link":"","permalink":"http://www.hzzzzzy.icu/2022/08/09/%E6%A8%A1%E6%8B%9F%E8%A7%A3%E6%9E%90Bean%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"点此返回 123456789101112131415161718192021222324252627282930313233343536373839404142public class AtBeanPostProcessor implements BeanFactoryPostProcessor &#123; @Override public void postProcessBeanFactory (ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException &#123; try &#123; //读取类信息 CachingMetadataReaderFactory factory = new CachingMetadataReaderFactory(); MetadataReader reader = factory .getMetadataReader(new ClassPathResource(&quot;com/itheima/a05/Config.class&quot;)); //获取被@Bean标注的方法 //1.获取和注解相关的元数据 //2.进一步获取被@Bean注解标注的方法 Set&lt;MethodMetadata&gt; methods = reader .getAnnotationMetadata() .getAnnotatedMethods(Bean.class.getName()); for (MethodMetadata method : methods) &#123; System.out.println(method); //解析@Bean注解中的属性 String initMethod = (String) method.getAnnotationAttributes(Bean.class.getName()).get(&quot;initMethod&quot;); //利用BeanDefinitionBuilder获取BeanDefinition，并加入bean工厂 BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(); builder.setFactoryMethodOnBean(method.getMethodName(),&quot;config&quot;); //指定自动装配模式(因为SqlSessionFactoryBean有一个dataSource参数) builder.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR); if (initMethod.length() &gt; 0)&#123; builder.setInitMethodName(initMethod); &#125; AbstractBeanDefinition bd = builder.getBeanDefinition(); //注册Bean到容器中 if (configurableListableBeanFactory instanceof DefaultListableBeanFactory beanFactory) &#123; beanFactory.registerBeanDefinition(method.getMethodName(),bd); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 当其他类调用时，只需调用容器的registerBean方法，传入对实现类.class文件即可 12345678910111213141516171819public class BeanApp &#123; private static final Logger log = LoggerFactory.getLogger(BeanApp.class); public static void main(String[] args) throws IOException &#123; //创建一个干净容器 GenericApplicationContext context = new GenericApplicationContext(); context.registerBean(&quot;config&quot;, Config.class); //解析@Bean context.registerBean(AtBeanPostProcessor.class); //初始化容器 context.refresh(); for (String name : context.getBeanDefinitionNames()) &#123; System.out.println(name); &#125; //销毁容器 context.close(); &#125;&#125;","categories":[{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/categories/spring%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"},{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/tags/spring%E9%AB%98%E7%BA%A7/"}]},{"title":"模拟解析Mapper接口","slug":"模拟解析Mapper接口","date":"2022-08-09T13:53:05.000Z","updated":"2022-08-09T23:46:07.171Z","comments":true,"path":"2022/08/09/模拟解析Mapper接口/","link":"","permalink":"http://www.hzzzzzy.icu/2022/08/09/%E6%A8%A1%E6%8B%9F%E8%A7%A3%E6%9E%90Mapper%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"点此返回 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MapperPostProcessor implements BeanDefinitionRegistryPostProcessor &#123; @Override public void postProcessBeanDefinitionRegistry (BeanDefinitionRegistry beanFactory) throws BeansException &#123; try &#123; //扫描 mapper 包下的资源（使用通配符解析器） PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); Resource[] resources = resolver .getResources(&quot;classpath:com/itheima/a05/mapper/**/*.class&quot;); //创建名称生成器对象 AnnotationBeanNameGenerator generator = new AnnotationBeanNameGenerator(); //读取类的元数据信息 CachingMetadataReaderFactory factory = new CachingMetadataReaderFactory(); for (Resource resource : resources) &#123; MetadataReader reader = factory.getMetadataReader(resource); ClassMetadata classMetadata = reader.getClassMetadata(); //判断是否是接口 if (classMetadata.isInterface()) &#123; //生成 BeanDefinition AbstractBeanDefinition bd1 = BeanDefinitionBuilder .genericBeanDefinition(MapperFactoryBean.class) //给构造方法设置参数值（接口名称） .addConstructorArgValue(classMetadata.getClassName()) //设置装配模式 .setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE) .getBeanDefinition(); //再生成一个 BeanDefinition AbstractBeanDefinition bd2 = BeanDefinitionBuilder .genericBeanDefinition(classMetadata.getClassName()) .getBeanDefinition(); //根据bd2生成名称，以免覆盖bd1生成的名称 String beanName = generator.generateBeanName(bd2, beanFactory); //注册到Bean工厂 beanFactory.registerBeanDefinition(beanName,bd1); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void postProcessBeanFactory (ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; &#125;&#125; 当其他类调用时，只需调用容器的registerBean方法，传入对实现类.class文件即可 12345678910111213141516171819public class BeanApp &#123; private static final Logger log = LoggerFactory.getLogger(BeanApp.class); public static void main(String[] args) throws IOException &#123; //创建一个干净容器 GenericApplicationContext context = new GenericApplicationContext(); context.registerBean(&quot;config&quot;, Config.class); //解析Mapper接口 context.registerBean(MapperPostProcessor.class); //初始化容器 context.refresh(); for (String name : context.getBeanDefinitionNames()) &#123; System.out.println(name); &#125; //销毁容器 context.close(); &#125;&#125;","categories":[{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/categories/spring%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"},{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/tags/spring%E9%AB%98%E7%BA%A7/"}]},{"title":"模拟实现@ComponentScan","slug":"模拟实现@ComponentScan","date":"2022-08-09T08:20:34.000Z","updated":"2022-08-09T14:54:59.121Z","comments":true,"path":"2022/08/09/模拟实现@ComponentScan/","link":"","permalink":"http://www.hzzzzzy.icu/2022/08/09/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0@ComponentScan/","excerpt":"","text":"点此返回 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//模拟 @ComponentScan 注解的解析//1、让自定义类实现 BeanDefinitionRegistryPostProcessor 接口// 并重写 postProcessBeanFactory 方法public class ComponentScanPostProcessor implements BeanDefinitionRegistryPostProcessor &#123; @Override // context.refresh public void postProcessBeanFactory (ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException &#123; try &#123; //2、使用 AnnotationUtils 工具类从Config类中找到 @ComponentScan 注解对象 ComponentScan componentScan = AnnotationUtils .findAnnotation(Config.class, ComponentScan.class); if (componentScan != null) &#123; //3、不为空，获取包名（包名转换为classpath下的资源路径） // com.itheima.a05.component // -&gt; classpath*:com/itheima/a05/component/**/*.class for (String p : componentScan.basePackages()) &#123; String path = &quot;classpath*:&quot; + p.replace(&quot;.&quot;, &quot;/&quot;) + &quot;/**/*.class&quot;; //4、读取类的元信息 CachingMetadataReaderFactory factory = new CachingMetadataReaderFactory(); Resource[] resources = new PathMatchingResourcePatternResolver().getResources(path); AnnotationBeanNameGenerator generator = new AnnotationBeanNameGenerator(); for (Resource resource : resources) &#123; MetadataReader reader = factory.getMetadataReader(resource); //5、判断是否间接或者直接加了@Component注解 if (reader.getAnnotationMetadata() .hasMetaAnnotation(Component.class.getName()) || reader.getAnnotationMetadata() .hasAnnotation(Component.class.getName())) &#123; //6、创建一个BeanDefinition AbstractBeanDefinition bd = BeanDefinitionBuilder .genericBeanDefinition(reader .getClassMetadata() .getClassName()) .getBeanDefinition(); if (configurableListableBeanFactory instanceof DefaultListableBeanFactory beanFactory) &#123; //7、将BeanDefinition加入到Bean工厂 String beanName = generator.generateBeanName(bd, beanFactory); beanFactory.registerBeanDefinition(beanName,bd); &#125; &#125; &#125; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 当其他类使用时，只需要调用 context的 registerBean方法，并传入自定义类的.class即可 123456789GenericApplicationContext context = new GenericApplicationContext();context.registerBean(ComponentScanPostProcessor.class);//初始化容器context.refresh();//for (String name : context.getBeanDefinitionNames()) &#123;// System.out.println(name);//&#125;//销毁容器context.close();","categories":[{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/categories/spring%E9%AB%98%E7%BA%A7/"}],"tags":[{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"},{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/tags/spring%E9%AB%98%E7%BA%A7/"}]},{"title":"defineClass源码","slug":"defineClass源码","date":"2022-08-09T06:46:52.000Z","updated":"2022-08-09T06:48:49.687Z","comments":true,"path":"2022/08/09/defineClass源码/","link":"","permalink":"http://www.hzzzzzy.icu/2022/08/09/defineClass%E6%BA%90%E7%A0%81/","excerpt":"","text":"点此返回 123456789101112131415161718192021222324252627private Class&lt;?&gt; defineClass(String name, Resource res) throws IOException &#123; long t0 = System.nanoTime(); int i = name.lastIndexOf(&#x27;.&#x27;); URL url = res.getCodeSourceURL(); if (i != -1) &#123; String pkgname = name.substring(0, i); // Check if package already loaded. Manifest man = res.getManifest(); definePackageInternal(pkgname, man, url); &#125; // Now read the class bytes and define the class java.nio.ByteBuffer bb = res.getByteBuffer(); if (bb != null) &#123; // Use (direct) ByteBuffer: CodeSigner[] signers = res.getCodeSigners(); CodeSource cs = new CodeSource(url, signers); sun.misc.PerfCounter.getReadClassBytesTime().addElapsedTimeFrom(t0); return defineClass(name, bb, cs); &#125; else &#123; byte[] b = res.getBytes(); // must read certificates AFTER reading bytes. CodeSigner[] signers = res.getCodeSigners(); CodeSource cs = new CodeSource(url, signers); sun.misc.PerfCounter.getReadClassBytesTime().addElapsedTimeFrom(t0); return defineClass(name, b, 0, b.length, cs); &#125;&#125;","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"findClass方法源码","slug":"findClass方法源码","date":"2022-08-09T06:37:52.000Z","updated":"2022-08-09T06:46:08.320Z","comments":true,"path":"2022/08/09/findClass方法源码/","link":"","permalink":"http://www.hzzzzzy.icu/2022/08/09/findClass%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81/","excerpt":"","text":"点此返回 123456789101112131415161718192021222324252627282930protected Class&lt;?&gt; findClass(final String name) throws ClassNotFoundException&#123; final Class&lt;?&gt; result; try &#123; result = AccessController.doPrivileged( new PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123; public Class&lt;?&gt; run() throws ClassNotFoundException &#123; String path = name.replace(&#x27;.&#x27;, &#x27;/&#x27;).concat(&quot;.class&quot;); Resource res = ucp.getResource(path, false); if (res != null) &#123; try &#123; //defineClass：根据所给的二进制数据和名称，返回一个Class实例 return defineClass(name, res); &#125; catch (IOException e) &#123; throw new ClassNotFoundException(name, e); &#125; &#125; else &#123; return null; &#125; &#125; &#125;, acc); &#125; catch (java.security.PrivilegedActionException pae) &#123; throw (ClassNotFoundException) pae.getException(); &#125; if (result == null) &#123; throw new ClassNotFoundException(name); &#125; return result;&#125;","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"loadClass方法源码剖析","slug":"loadClass方法源码","date":"2022-08-09T01:56:15.000Z","updated":"2022-08-09T07:36:00.339Z","comments":true,"path":"2022/08/09/loadClass方法源码/","link":"","permalink":"http://www.hzzzzzy.icu/2022/08/09/loadClass%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81/","excerpt":"","text":"点此返回 1、先在当前加载器的缓存中*查找有无目标类,如果有,直接返回。* 2、判断当前加载器的父加载器是否为空 ,如果不为空,则调用 parent.loadClass(name, false) 接口进行加载 3、反之,如果当前加载器的父类加载器为空,则调用 findBootstrapClassOrNull(name) 接口,让引导类加载器进行加载 4、如果通过以上3条路径都没能成功加载,则调用 findClass(name) 接口进行加载。该接口最终会调用 java.lang.ClassLoader 接口的 defineClass 系列的native接口加载目标Java类。 双亲委派的模型就隐藏在这第2和第3步中 1234567891011121314151617181920212223242526272829303132333435363738protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; //同步操作，保证只能加载一次 //首先，在缓存中判断是否已经加载同名的类 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; //parent：当前类加载器的父类加载器 if (parent != null) &#123; //如果存在父类加载器，则调用父类加载器进行类的加载 c = parent.loadClass(name, false); &#125; else &#123; //parent为null：父类加载器是引导类加载器 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; //当前类加载器的父类加载器未加载此类 或 当前类加载器被加载 //调用当前ClassLoader long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; //是否进行解析操作 resolveClass(c); &#125; return c; &#125; &#125;","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"16-类的加载器","slug":"16-类的加载器","date":"2022-08-09T00:51:38.000Z","updated":"2022-08-09T07:56:50.861Z","comments":true,"path":"2022/08/09/16-类的加载器/","link":"","permalink":"http://www.hzzzzzy.icu/2022/08/09/16-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/","excerpt":"","text":"类加载的方式显示加载：代码中调用ClassLoader加载class对象，比如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象 隐式加载：不直接在代码中调用ClassLoader加载class对象，而是通过虚拟机自动加载到内存，比如加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存 类的唯一性对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在java虚拟机中的唯一性。每一个类加载器，都拥有一个独立的类名称空间：比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。 12345678910111213141516171819public static void main(String[] args) &#123; String rootDir = &quot;D:\\\\xxx\\\\src\\\\&quot;; try &#123; //创建自定义的类的加载器1 UserClassLoader loader1 = new UserClassLoader(rootDir); Class clazz1 = loader1.findClass(&quot;xxx.java.User&quot;); //创建自定义的类的加载器2 UserClassLoader loader2 = new UserClassLoader(rootDir); Class clazz2 = loader2.findClass(&quot;xxx.java.User&quot;); System.out.println(clazz1 == clazz2); //clazz1与clazz2对应了不同的类模板结构。 System.out.println(clazz1.getClassLoader()); System.out.println(clazz2.getClassLoader()); &#125; //结果为：false // xxx.java.UserClassLoader@1b6d3586 // xxx.java.UserClassLoader@74a14482 命名空间每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成。 在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类 在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。 类加载器分类 引导(启动)类加载器这个类加载使用C&#x2F;C++语言实现的,嵌套在JVM内部 1、它用来加载Java的核心类库JAVA_HOME/jre/lib/rt.jar、resource.jar或sum.boot.class.path路径下的内容用于提供JVM自身需要的类(String类就是使用的这个类加载器) 2、由于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 3、并不继承自java.lang.ClassLoader，没有父加载器 4、加载扩展类和应用程序类加载器，并指定为他们的父类加载器 自定义加载器将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器） 1、Java语言编写 2、派生于ClassLoader类，父类加载器为启动类加载器 3、从java.ext.dirs系统属性所指定的目录中加载类，或从JDK的安装目录的jre/lib/ext子目录(扩展目录)下加载类库。（如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载） 扩展类加载器1、Java语言编写 2、派生于ClassLoader类,父类加载器为启动类加载器 3、从java.ext.dirs系统属性所指定的目录中加载类库,或从JDK的安装目录的jre/lib/ext子目录(扩展目录)下加载类库（如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载） 应用程序(系统)类加载器1、java语言编写 2、派生于ClassLoader类,父类加载器为扩展类加载器 3、它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库 4、该类加载是程序中默认的类加载器 5、通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器 用户自定义类加载器目的隔离记载类 修改类的加载方式 扩展加载源 防止源码泄露 方法1）重写 loadClass() 方法（不推荐,这个方法会保证类的双亲委派机制） 2）重写 findClass() 方法 –&gt;推荐 这两种方法本质上差不多,毕竟loadClass()也会调用findClass(),但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法,根据参数指定类的名字,返回对应的Class对象的引用 获取ClassLoader的方法 注意： loadClass()这个方法收i实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此最好避免重写 loadClass方法过程中必须写双亲委派的重复代码，从代码复用性来说，不直接修改比较好 ClassLoader源码主要方法1public final ClassLoader getParent() 返回该类加载器的超类加载器 1public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException 加载名称为name的类，返回结果为java.lang.Class类的实例（点击查看源码）如果找不到类，则返回ClassNot FoundException 异常。该方法中的逻辑就是双亲委派模式的实现 1protected Class&lt;?&gt; findClass (String name) throws ClassNotFoundException 查找二进制名称为name的类，返回结果为java.lang.Class类的实例（点击查看源码）这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。 1protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) 根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的这是受保护的方法，只有在自定义ClassLoader子类中可以使用（点击查看源码） 1protected final void resolveClass(Class&lt;?&gt; c) 链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析（点击查看源码） SecureClassLoader和URLClassLoader(*)SecureClassLoader扩展了ClassLoader，新增了几个对代码源位置及证书的验证和对class源码的访问权限的方法 URLClassLoader为findClass，findResource等在ClassLoader抽象类中没实现的方法提供具体的实现，新增了协助取得字节码流的功能。在自定义类的加载器时，如果没有复杂的需求，一般直接继承URLClassLoader Class.forName()与ClassLoader.loadClass()1、Class.forName()：是一个静态方法，最常用的是Class.forName(String className) 根据传入的类的全限定名返回一个 Class 对象。该方法在将 Class 文件加载到内存的同时，会执行类的初始化。 2、ClassLoader.loadClass()：这是一个实例方法，需要一个 ClassLoader 对象来调用该方法。 该方法将 Class 文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化 该方法因为需要得到一个 ClassLoader 对象，所以可以根据需要指定使用哪个类加载器 双亲委派机制 双亲委派机制在loadClass方法中的体现 java虚拟机对class文件采用按需加载的方式进行加载，当需要使用该类时才会将它的class文件加载到内存中生成class对象 1、如果一个类加载收到了类加载请求,它并不会自己先去加载，而是把这个请求委托给父类加载器去执行 2、如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归,请求最终将到达顶层的启动类加载器 3、如果父类的加载器可以完成类的加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式 优势 1、避免类的重复加载，确保一个类的全局唯一性（当父ClassLoader已经加载了该类的时候,就没有必要子ClassLoader再加载一次） 2、保护程序的安全，防止API随意被篡改 弊端 顶层的ClassLoader无法访问底层的ClassLoader所加载的类 破坏双亲委派机制第一次破坏双亲委派机制：在双亲委派模型出现之前（JDK 1.2面世以前） 第二次破坏双亲委派机制：线程上下文类加载器ClassLoader.getSystemClassLoader( ) 第二次破坏双亲委派机制：用户对程序动态性的追求而导致的。如：代码热替换(Hot Swap)、模块热部署(Hot Deployment)","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"15-类的生命周期（详细）","slug":"15-类的生命周期（详细）","date":"2022-08-08T00:58:27.000Z","updated":"2022-08-09T00:50:46.320Z","comments":true,"path":"2022/08/08/15-类的生命周期（详细）/","link":"","permalink":"http://www.hzzzzzy.icu/2022/08/08/15-%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E8%AF%A6%E7%BB%86%EF%BC%89/","excerpt":"","text":"概述从class文件到加载到内存中的类,到类卸载出内存为止,它的整个生命周期包括如下7个阶段 注意：基本数据类型由虚拟机预先定义，引用数据类型需要进行类的加载 程序使用类的过程 1、加载将类的.class文件中的二进制数据读取到内存中，存放在运行时数据区的方法区中，并在内存中创建一个Java类原型（类模板对象） 类模板对象：java类在JVM中的一个快照。JVM从字节码文件中解析出常量池、类字段、类方法等存储在类模板中，如此JVM就可以在运行期通过类模板获取java中的任意信息，能够对java类的成员变量进行遍历，也能对方法进行调用（反射机制基于这一基础） 加载的步骤1、通过类的全名，获取类的二进制数据流 2、解析类的二进制数据流为方法区内的数据结构（java类模型） 3、创建java.lang.Class类的实例（作为方法区这个类的各个数据的访问入口） 类模型与Class实例位置类模型的位置：加载的类在JVM中创建相应的类结构，类结构存储在方法区（1.8之前：永久代；1.8之后：元空间） Class实例的位置： .class文件加载后，在堆中创建一个Java.lang.Class对象，封装类位于方法区的数据结构 数组类加载数组类本身并不是由类加载器负责创建，而是JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建 1、数组元素类型是引用类型，遵循定义的加载过程递归加载和创建数组的元素类型 2、JVM使用指定元素类型和数组维度来创建新的数组类 数组元素类型是引用类型，数据类的可访问性由元素类型决定，如果为基本数据类型，可访问性为pubilc 2、链接1）验证确保Class文件的字节流中包含信息符合当前虚拟机要求,保证被加载类的正确性 格式检查1、是否以魔术oxCAFEBABE开头，主版本和副版本是否在当前Java虚拟机的支持范围内，数据中每一项是否都拥有正确的长度等 2、格式检查与类的加载阶段一起执行，验证通过后，类加载器才会成功将类的二进制信息加载到方法区中 3、格式检查之外的验证操作会在方法区中进行 语义检查java虚拟机会进行语义的检查，语义上不通过的，虚拟机也不会给予验证通过 字节码验证验证过程中最复杂的一个过程，通过对字节码流的分析，判断字节码是否可以被正确地执行 栈映射帧（StackMapTbale）就是在这个阶段实现的，用于检测在特定的字节码处，局部变量表和操作数栈是否有正确的数据类型（尽可能检查出可以预知的问题，不能100%） 符号引用验证Class文件在其常量池会通过字符串来记录自己将要使用的其他类或方法，因此在验证阶段，虚拟机就会检查这些类或方法确实是存在的（类没找到：NoClassDefFoundError，方法没找到：NoSuchMethodError） 2）准备为类变量分配内存并且设置该类变量的默认初始化值 非final修饰的变量，解析环节进行默认初始化赋值 这里不包含用final修饰的static，final在编译时就进行分配了，准备阶段会显式赋值 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量会随着对象一起分配到Java堆 注意：Java并不支持boolean类型，对于boolean类型，内部实现是int，由于int的默认值是0，故对应boolean的默认值就是false 3）解析将常量池中的符号引号转换为直接引用的过程（将类、接口、字段和方法的符号引用转为直接引用） 1、实际上，解析操作往往会伴随着JVM在执行完初始化之后再执行 2、直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄（与虚拟机实现的内存布局相关） 3、符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中） 4、主要解析动作针对类或接口、字段、类方法、接口方法、方法类型等 3、初始化为类变量赋予正确的初始化值 初始化阶段就是执行类构造器方法&lt; clinit &gt;()的过程。此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来 若该类具有父类，Jvm会保证子类的() 执行前，父类的&lt; clinit &gt;() 已经执行完成。clinit 不同于类的构造方法(init) （由父及子，静态先行） Java编译器不会在以下情况下生成clinit方法一个类中并没有声明任何的类变量，也没有静态代码块时 一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时 一个类中包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式 (如果这个static final 不是通过方法或者构造器,则在链接阶段) 12345678public class InitializationTest1 &#123; //场景1：对应非静态的字段,不管是否进行了显式赋值,都不会生成&lt;clinit&gt;()方法 public int num = 1; //场景2：静态的字段,没有显式的赋值,不会生成&lt;clinit&gt;()方法 public static int num1; //场景3：比如对于声明为static final的基本数据类型的字段,不管是否进行了显式赋值,都不会生成&lt;clinit&gt;()方法 public static final int num2 = 1;&#125; static+final进行修饰1、在链接阶段的准备环节赋值 2、在初始化阶段赋值 123456789101112131415161718192021/** *1. 对于基本数据类型的字段来说,如果使用static final修饰,则显式赋值(直接赋值常量,而非调用方法)通常是在链接阶段的准备环节进行 * 2. 对于String来说,如果使用字面量的方式赋值,使用static final修饰的话,则显式赋值通常是在链接阶段的准备环节进行 * * 在初始化阶段&lt;clinit&gt;()中赋值的情况: * 排除上述的在准备环节赋值的情况之外的情况。 * 最终结论:使用static + final修饰,且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值,是在链接阶段的准备环节进行。 */public class InitializationTest2 &#123; public static int a = 1;//在初始化阶段&lt;clinit&gt;()中赋值 public static final int INT_CONSTANT = 10;//在链接阶段的准备环节赋值 public static final Integer INTEGER_CONSTANT1 = Integer.valueOf(100);//在初始化阶段&lt;clinit&gt;()中赋值 public static Integer INTEGER_CONSTANT2 = Integer.valueOf(1000);//在初始化阶段&lt;clinit&gt;()中赋值 public static final String s0 = &quot;helloworld0&quot;;//在链接阶段的准备环节赋值 public static final String s1 = new String(&quot;helloworld1&quot;);//在初始化阶段&lt;clinit&gt;()中赋值 public static String s2 = &quot;helloworld2&quot;; public static final int NUM1 = new Random().nextInt(10);//在初始化阶段&lt;clinit&gt;()中赋值&#125; client线程安全性问题 虚拟机会保证一个类的clinit方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的方法，其他线程都需要阻塞等待，直到活动线程执行clinit方法结束 如果在一个类的clinit方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。 4、使用使用参数-XX:+TraceClassLoading：可以追踪类的加载信息并打印出来 主动使用Class只有在必须要首次使用的时候才会被装载。一个类或接口在初次主动使用前，必须要进行初始化。 1、创建一个类的实例时（使用new关键字，通过反射、克隆，反序列化）即使用字节码invokestatic指令 2、使用当前类的静态方法，使用getstatic或者putstatic指令（对应访问变量、赋值变量操作） 3、使用类、接口的静态字段时（final修饰特殊考虑） 4、当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(“xxx.xxx.xxx.test”) 5、当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 6、如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。 12345678910111213141516171819class Father &#123; static &#123;System.out.println(&quot;Father类的初始化过程&quot;);&#125;&#125;class Son extends Father implements CompareB&#123; static &#123;System.out.println(&quot;Son类的初始化过程&quot;); &#125;&#125;interface CompareA&#123; public static final Thread t = new Thread() &#123; &#123;System.out.println(&quot;CompareA的初始化&quot;);&#125; &#125;; public default void method1() &#123;System.out.println(&quot;你好！&quot;);&#125;&#125;@Testpublic void test4() &#123; System.out.println(Son.num);&#125; 7、当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 8、当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。 注意： 初始化一个类的子类这条规则，不适用于接口，即：初始化一个类的子类，会先初始化它的父类，但是不一定会初始化它的接口。只有当首次使用该接口的静态变量时，才会初始化。 被动使用被动使用不会引起类的初始化，即不会调用clinit方法 1、当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。 2、当通过子类引用父类的静态变量，不会导致子类初始化 3、通过数组定义类引用，不会触发此类的初始化 12345678910111213@Testpublic void test2()&#123; Parent[] parents = new Parent[10]; System.out.println(parents.getClass()); //不进行初始化 System.out.println(parents.getClass().getSuperclass()); //不进行初始化 parents[0] = new Parent(); //进行Parent的初始化&#125;class Parent&#123; static&#123;System.out.println(&quot;Parent的初始化过程&quot;);&#125;&#125;class Child extends Parent&#123; static&#123;System.out.println(&quot;Child的初始化过程&quot;);&#125;&#125; 4、引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了 5、调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化 123456@Testpublic void test3()&#123; try &#123; Class clazz = ClassLoader.getSystemClassLoader().loadClass(&quot;xxx.xxx.xxx&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125;&#125; 注意：没有初始化的类，不意味着没有加载 5、卸载 在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另外一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。所以，二者之间是双向关联的 一个类的实例总是引用代表这个类的Class对象，一个类的实例总是引用代表这个类的Class对象 判断一个类是否属于不再使用的类 1、该类所有的实例都已经被回收。也就是]ava堆中不存在该类及其任何派生子类的实例。2、加载该类的类加载器己经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如QSGi、SP的重加载等，否则通常是很难达成的。3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 注意：通常情况下，一个已经加载的类型被卸载的概率很小，而且卸载时间不确定","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"14-垃圾回收器","slug":"14-垃圾回收器","date":"2022-08-04T15:08:05.000Z","updated":"2022-08-08T00:55:54.477Z","comments":true,"path":"2022/08/04/14-垃圾回收器/","link":"","permalink":"http://www.hzzzzzy.icu/2022/08/04/14-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/","excerpt":"","text":"GC分类按线程数：分为串行垃圾回收器和并行垃圾回收器 按工作模式：分为并发式垃圾回收器和独占式垃圾回收器 按碎片处理方式：分为 1、压缩式垃圾回收器：在回收完成后，对存活对象进行压缩整理，清除回收后的碎片（再分配对象空间的使用：指针碰撞） 2、非压缩式垃圾回收器（再分配对象空间的使用：空闲列表） 按工作的内存区间：分为年轻代垃圾回收器和老年代垃圾回收器 GC性能指标吞吐量：运行用户代码·的时间占总运行时间的比例（总运行时间 &#x3D; 程序运行时间 + 内存回收时间） 吞吐量优先，意味着在单位时间内，STW的时间最短 垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间（STW） 暂停时间优先，意味着尽可能让单次STW的时间最短 收集频率：相对于应用程序的执行，收集操作发生的频率 内存占用：Java堆区所占的内存大小 快速：一个对象从诞生到被回收所经历的时间 注意：现在的标准为在最大吞吐量优先的情况下，降低停顿时间 回收器概述新生代收集器：Serial GC、ParNew GC、Parallel Scavenge GC老年代收集器：Serial 0ld GC、 Parallel 0ld GC、 CMS GC整堆收集器：G1 GC GC发展阶段：Seria1&#x3D;&gt;Para11e1(并行)&#x3D;&gt;CMS(并发)&#x3D;&gt;G1&#x3D;&gt;ZGC 查看命令行相关参数（包含使用的垃圾收集器）：-xx:+PrintCommandLineFlags Serial，SerialOld 回收器Serial：串行HotSpot虚拟机Client模式下的默认新生代垃圾收集器（最基本，最悠久） 采用复制算法，串行回收和STW机制方法执行内存回收 优势：简单，高效（没与其他收集器的单线程相比，没有线程交互的开销） Serial Old：串行Serial 0ld是运行在Client模式下默认的老年代垃圾回收器 Serial 0ld收集器同样采用了串行回收和STW机制，只不过内存回收算法使用的是标记一压缩算法 在Server模式下的用途： 1、与新生代的Parallel Scavenge配合使用 2、作为老年代CMS收集器的后备垃圾收集方法 单线程回收：使用一个cpu或一条线程去完成垃圾收集工作而且必须暂停其他所有的工作线程 设置Serial垃圾回收器 使用 -XX:+UseSerialGC 参数可以指定年轻代和老年代都使用串行收集器，等价于新生代用Serial GC，且老年代用Serial 0ld GC Parallel New：并行ParNew收集器是Serial收集器的多线程版本，除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、STW机制。目前只有ParNew GC能与CMS收集器配合工作 设置ParNew垃圾回收器 -XX:+UseParNewGC：指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器， 不影响老年代 -XX:ParallelGCThreads：限制线程数量，默认开启和CPU数据相同的线程数 Parallel Scavenge&#x2F;ParallelOld：吞吐量优先ParallelHotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，还用到Parallel Scavenge。该收集器同样也 采用了复制算法、并行回收和STW机制。在Java8中，默认是此垃圾收集器 Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量，自适应调节策略是Parallel Scavenge与ParNew一个重要区别 高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。常见在服务器环境中使用。例如执行批量处理、订单处理、工资支付、科学计算 Parallel 0ldParallel 0ld收集器采用了标记一压缩算法，但同样也是基于并行回收和STW机制 Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的 Parallel 0ld收集器，用来代替老年代的Serial 0ld收集器 指令-XX:+UseParallelGC：手动指定年轻代使用Parallel并行收集器执行内存回收任务 -XX:+UseParallelOldGC：手动指定老年代都是使用并行回收收集器 默认jdk8是开启的。上面两个参数，默认开启一个，另一个也会被开启。 -XX:ParallelGCThreads：设置年轻代并行收集器的线程数，一般最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能 -XX:MaxGCPauseMillis：设置垃圾收集器最大停顿时间(即STW的时间) -XX:+UseAdaptiveSizePolicy：设置Parallel Scavenge收集器具有自适应调节策略 在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量和停顿时间，让虚拟机自己完成调优工作) CMS：低延迟HotSpot虚拟机中第一款真正意义上的并发收集器。第一次实现了让垃圾收集线程与用户线程同时工作， 也采用标记-清除算法和STW机制。在G1出现之前，CMS使用还是非常广泛的 初始标记标记出和GCRoots能直接关联到的对象，有STW现象（暂时时间非常短） 并发标记阶段从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不用STW。**可以与垃圾收集线程一起并发运行 重新标记阶段有些对象可能开始是垃圾，在并发标记阶段，由于用户线程的影响，导致不是垃圾了，这里需要重新标记的是这部分对象，这个阶段的STW通常会比初始标记阶段稍长一些，但远比并发标记阶段的时间短 注意：重新标记是对已标记过的垃圾进行检测，此时会产生浮动垃圾 并发清除清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。 由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的 总结 在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。 要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial 0ld收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。 CMS收集器的垃圾收集算法采用的是标记一清除算法，这意味着不可避免地将会产生一些内存碎片。 那么CMS在为新对象分配内存空间时，将无法使用指针碰撞，而只能够选择空闲列表执行内存分配。 最小化使用内存和并行开销：Serial GC（young）+ Serial Old GC（old） 最大化应用程序吞吐量：Parallel GC（young）+ Parallel Old GC（old） 最小化GC中断或停顿时间：Parallel New GC（young）+ CMS GC（old） 优点：1）低延迟（最耗费时间的并发标记和并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的） 2）并发收集 缺点1）产生内存碎片 2）CMS收集器对CPU资源很敏感（并发阶段，占用一部分线程，吞吐量降低） 3）CMS收集器无法处理浮动垃圾 在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间 参数设置 -XX:+UseConcMarkSweepGC：手动指定使用CMS收集器执行内存回收任务（老年代）（开启该参数后会自动将-XX:+UseParNewGc打开。即: ParNew (Young区用) +CMS (0ld区用) +Serial 0ld的组合） -XX:CMSlnitiatingOccupanyFraction：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收 JDK5以前默认为68，即当老年代的空间使用率达到68%时，会执行一次CMS 回收。JDK6及以上默认为92% 通过该选项便可以有效降低Full GC的执行次数 -XX:+UseCMSCompactAtFullCollection：用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生 -XX:CMSFullGCsBeforeCompaction：设置在执行多少次Full GC后对内存空间进行压缩整理 -XX:ParallelCMSThreads：设置CMS的线程数量 G1：区域化分代式并行与并发并行性：G1在回收期间，可以有多个GC线程同时工作（此时用户线程STW） 并发性：G1拥有与应用程序交替执行的能力， 部分工作可以和应用程序同时执行，因此，不会在整个回收阶段发生完全阻塞应用程序的情况 分代收集G1仍然属于分代型垃圾回收器。它区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再有固定大小和固定数量 将堆空间分为若干个区域（region），这些区域中包含了逻辑上的年轻代和老年代。 空间整合G1将内存划分为一个个region，内存的回收以region为单位，region之间是复制算法。整体上可看作标记-压缩算法，两种算法都可以避免内存碎片。而且当分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。 可预测的停顿时间模型软实时（soft real-time） G1能建立可预测的停顿时间模型，让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒，可以通过参数-XX:MaxGCPauseMillis进行设置 由于分区的原因，G1可以只选取部分区域进行内存回收，缩小了回收的范围，对于全局停顿情况的发生也能得到较好的控制。 G1 跟踪各个Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。 注意：在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间 参数设置-XX:+UseG1GC：手动指定使用G1收集器执行内存回收任务 -XX:G1HeapRegionSize：设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000 -XX:MaxGCPauseMillis：设置期望达到的最大GC停顿时间指标（JVM会尽力实现,但不保证达到）默认200ms**(如果这个值设置很小，如20ms，那么它收集的region会少，这样长时间后，堆内存会满。产生FullGC从而出现STW)** -XX:ParallelGCThread：设置STW时GC线程数的值。最多设置为8（垃圾回收线程） -XX:ConcGCThreads：设置并发标记的线程数。将n设置为并行垃圾回收线程数的1&#x2F;4左右 -XX:InitiatingHeapOccupancyPercent：设置触发并发GC周期的Java堆占用率阈值。超过此值,就触发GC（默认45） 开启G1垃圾收集器 设置堆的最大内存 设置最大的停顿时间 region 1、使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小为2的N次幂。可以通过-XX:G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变 2、一个region 有可能属于任何一块内存区域。但是一个region只可能属于一个角色。 3、Humongous内存区域（图中的H块）主要用于存储大对象，如果超过1. 5个region，就放到Humongous区 对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区,它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，可以启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待 记忆集 一个region中的对象可能被其他任意region中对象引用，因此在判断对象是否存活的时候，需要扫描整个堆才能保证准确（出现STW）。所以使用每一个region对应一个记忆集（Remembered Set）来避免全局扫描 每次Reference类型数据写操作时，都会产生一个写屏障（Write Barrier）暂时中止操作，然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region （其他收集器：检查老年代对象是否引用了新生代对象）如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set G1回收过程1、YoungGC 2、老年代并发标记过程 3、混合回收 （作为一种失败保护机制，Full GC还是存在的） 年轻代GC 当Eden空间耗尽时,G1会启动一次年轻代垃圾回收过程年轻代垃圾回收只会回收Eden区和Survivor区 1、扫描根（根引用连同RSet记录的外部引用作为扫描存活对象的入口） 2、更新RSet（ 此阶段完成后,RSet可以准确的反映老年代对所在的内存分段中对象的引用） 3、处理RSet（t:识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象） 4、复制对象（对象树被遍历，Eden区内存中存活的对象复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄+1，达到阈值则被复制到Old区中空的内存分段。如果Survivor空间不够，Eden的部分数据会直接晋升到Old区） 5、处理引用 并发标记过程1、初始标记阶段：标记从根节点直接可达的对象（STW+一次YoungGC） 2、根区域扫描：扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成（YoungGC时，会动Survivor区，所以这一过程必须在YoungGC之前完成） 3、并发标记：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被YoungGC中断。在并发标记阶段,若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例） 4、再次标记：由于应用程序持续进行，需要修正上一次的标记结果（STW） 5、独占清理：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域（STW，不会实际上去做垃圾的收集） 6、并发清理阶段：识别并清理完全空闲的区域 混合回收 当越来越多对象晋升到老年代时，为避免堆内存耗尽，虚拟机会触发一个混合的垃圾收集器 混合回收除了回收整个Young region外，还会回收一部分的Old Region（可以选择哪些Old region被回收，从而对整个垃圾回收的耗时进行控制） G1优化建议1、年轻代发送GC频率高，避免使用-Xmn或-XX:NewRatio 2、暂停时间目标不要太过严苛（影响吞吐量） GC日志分析-XX:+PrintGC：输出GC日志 -XX:+PrintGCDetails：输出GC详细日志 -XX:+PrintGCTimeStamps：输出GC时间戳（以基准时间形式） -XX:+PrintGCDateStamps：输出GC时间戳（以日期的形式） -XX:+PrintHeapAtGC：在GC前后打印堆信息 -Xloggc:..&#x2F;logs&#x2F;gc.log：日志文件的输出路径","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"13-垃圾回收","slug":"13-垃圾回收","date":"2022-08-04T14:05:02.000Z","updated":"2022-08-04T15:14:23.562Z","comments":true,"path":"2022/08/04/13-垃圾回收/","link":"","permalink":"http://www.hzzzzzy.icu/2022/08/04/13-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","excerpt":"","text":"相关概述垃圾：运行程序中没有任何指针指向的对象。这个对象就是需要被回收的垃圾 GC的作用：释放没用的对象，清楚内存里的记录碎片，以便JVM可以将整理出来的内存分配给新的对象，没有GC就不能保证应用程序的正常进行 内存泄露：对象在程序运行期间无法被回收 java自动内存管理：降低内存泄漏和内存溢出的风险 GC的作用范围：方法区和堆区（重点） 分类：频繁收集Young区，较少收集Old区，基本不动Perm区（元空间） 相关算法注意：在GC执行垃圾回收之前，需要先区分出内存中哪些是存活的对象，哪些是死亡的对象，只有被标记为已经死亡的对象，GC才会在执行垃圾回收的时候，释放掉它的内存空间。当一个对象已经不再被任何存活的对象继续引用时，就可以宣判为死亡 标记阶段：引用计数算法对每个对象保留一个整型的引用计数器属性。用来记录对象被引用的情况 对于一个对象A，只要任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收 优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性 缺点：1、需要单独的字段存储计数器，增加存储空间的开销2、每次赋值都需要更新计数器，增加时间的开销3、无法处理循环引用（致命缺陷） 标记阶段：可达性分析算法以根对象集合（GC Roots：一组必须活跃的引用）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达 使用该算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径（引用链），如果目标对象没有任何引用链相连，则不可达，也就意味着该对象已经死亡。只有能够被根对象集合直接或者间接连接的对象才是存活对象 有效地解决了在引用技术算法中循环引用的问题，防止内存泄露的发生 注意：由于栈方式存放变量和指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那么它就是一个Root 扩展：除了固定的GC Roots集合以外，还可以有其他对象”临时性“地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收 1、如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证 2、这也是GC进行时必须STW的一个重要原因，枚举根节点时也是必须要停顿 对象的finalization机制 1、java提供了对象终止机制来允许开发人员提供对象被销毁之前的自定义处理逻辑 2、垃圾回收该对象之前（垃圾回收器发现没有引用指向一个对象），总会先调用这个对象的finalize()方法 3、finalize()方法允许在子类中被重写，用于在对象被回收时进行资源的释放（通常在这个方法内进行一些资源释放和清理工作） 注意：永远不要主动调用某个对象的 finalize方法，应该交给垃圾回收机制调用 理由： 1、在调用时可能会导致对象复活 2、在方法的执行时间是没有保障，它完全由GC线程决定，极端情况下，如果不发生GC，则finalize方法将没有执行机会 对象的三种状态由于finalize方法的存在，虚拟机中的对象一般处于三种可能的状态 一个无法触及的对象有可能在某一个条件下“复活”自己 1、可触及的：从根节点开始，可以到达这个对象 2、可复活的：对象的所有引用都被释放，但是对象有可能在调用finalize方法后复活 3、不可触及的：对象的finalize方法被调用，并且没有复活，那么就会进入不可触及的状态。不可触及的对象不可能被复活，因为finalize方法只会被调用一次（对象只有在这个状态才能被回收） 判断对象回收的具体过程1、判断对象到 GC Roots 是否有引用链，没有则进行第一次标记 2、判断对象是否执行finalize方法 1）如果对象没有重写或者finalize方法已经被虚拟机调用过，则该对象判定为不可触及 2）如果对象重写了finalize方法，但是还没有执行过，那么对象将插入到F-Queue队列中，执行方法 3）GC将会对F-Queue队列中的对象进行第二次标记，如果对象在finalize方法中与引用链中的任何一个对象建立了联系，那么在第二次回收时，将会被移除队列。任何对象会再次出现没有引用的情况，直接变成不可触及的状态 清除阶段：标记-清除算法基础且常见的垃圾收集算法，当堆中有效内存空间被耗尽的时候，就会进行STW，任何进行标记和清除 标记：Collector从引用根节点进行遍历，标记所有被引用的对象，一般是在对象的Header中记录为可达的对象 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在Header中没有标记为可达对象，则将其回收 缺点： 1、效率不高 2、在进行GC的时候，需要STW 3、清理出来的空间内存是不连续的，产生内存碎片。需要维护一个空闲列表 注意：此处清除的本质是将需要清除的对象地址保存在空闲的地址列表中，当下次有新对象加载时，判断垃圾的位置空间是否够，如果够，就进行存放 清除阶段：复制算法将活着的内存空间分为两块,每次只使用其中一块,在垃圾回收时将正在.使用的内存中的存活对象复制到未被使用的内存块中,之后清除正在使用的内存块中的所有对象,交换两个内存的角色,最后完成垃圾回收。 优点： 1、没有标记和清除过程,，实现简单，运行高效 2、不会产生内存碎片，且对象完整不丢缺点： 1、浪费空间 2、对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，内存占用和时间开销大。 注意：如果垃圾对象很多，复制算法则不太理想。所以在 新生代 中使用复制算法是非常好的 清除阶段：标记-压缩算法 1、从根节点开始标记所有被引用对象. 2、将所有的存活对象压缩到内存的一端,按顺序排放。 3、清理边界外所有的空间。 优点： 消除了标记一清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可 消除了复制算法当中，内存减半的代价 缺点： 从效率上来说，标记一整理算法要低于复制算法。 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。移动过程中需要进行STW 总结清除阶段 Mark-Sweep Mark-Compact Copying 速度 中等 最慢 最快 空间开销 少（会存在堆积碎片） 少（不堆积碎片） 通常需要或对象的两倍大小（不堆积碎片） 移动对象 多 是 是 分代收集算法分代算法是针对对象的不同特征，而使用合适的算法，实际上没有新算法产生，而是对前三个算法的实际应用，在新生代使用复制算法，老年代使用标记清除&#x2F;标记压缩算法清除 老年代中： Mark阶段的开销与存活对象的数量成正比 Sweep阶段的开销与所管理区域的大小成正相关 Compact阶段的开销与存活对象的数据成正比 增量收集算法为了避免STW影响用户体验或者系统的稳定性，让垃圾收集线程和应用程序线程交替执行，每次垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程，直到垃圾收集完成 注意：增量收集算法基础还是传统的标记—清除和复制算法，只是通过对线程冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作 缺点：因为线程切换和上下文转换的小号，使得垃圾回收的总体成本上升，造成系统吞吐量下降、 分区算法一般堆空间越大，一次GC的时间就越长，GC产生的停顿就越长，为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据停顿时间去回收小区间，而不是整个堆空间，从而减少一个GC所产生的停顿。 相关概念System.gc()通过System.gc()或Runtime.getRuntime().gc()的调用，会显式触发Full GC同时对新生代和老年代进行回收（无法保证马上执行GC） 12345678910public static void main(String[] args) &#123; new SystemGCTest(); System.gc();//无法保证马上执行GC //System.runFinalization();//强制调用使用引用的对象的finalize()方法&#125;@Overrideprotected void finalize() throws Throwable &#123; super.finalize(); System.out.println(&quot;SystemGCTest 重写了finalize()&quot;);&#125; 内存溢出1）java虚拟机堆内存设置不够 2）代码中创建了大量对象，并且长时间不能被垃圾收集器收集（存在或被引用） 3）在OOM之前，通常垃圾收集器会被触发，尽可能去清理出空间 内存泄露严格来说：只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄露 实际上：一些操作会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义的内存泄露 发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现0utOfMemory异常，导致程序崩溃。 比如： 单例模式的生命周期和应用程序是一样的，如果在单例程序中持有堆外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄露的产生 STW在GC事件发生的过程中会产生应用程序的停顿。停顿产生时整个应用程序都会被暂停，没有任何响应 所有GC都有这个事件，是由JVM在后台自动发起和完成的 程序的并行和并发并发一个时间段中有几个程序都是在同一个处理器上运行，并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段，然后在这几个时间区间之间来回切换。 并行当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行 取决于CPU的核心数量 垃圾回收的并行和并发并行：指多条垃圾收集线程并行工作,但此时用户线程仍处于等待状态 串行：单线程执行。如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。 并发：用户线程和垃圾收集线程同时执行（不一定是并行的，可能会交替执行）垃圾回收线程在执行时不会停顿用户程序的运行 安全点与安全区域安全点程序执行时只有在特定位置才能停顿下来开始GC，这些位置被称为安全点 安全点如果太少可能会导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。 如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来？ （*） 抢先式中断（没有虚拟机采用）：中断所有线程，如果还有线程不在安全点，就恢复线程，让线程跑到安全点 主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起 安全区域在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。 引用强引用最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值。即类似“0bject obj&#x3D;new object( )”这种引用关系。只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。（强引用可以直接访问目标对象） StringBuffer str = new StringBuffer(&quot;hello&quot;); 局部变量str指向Stringbuffer实例所在堆空间，通过str可操作该实例，那么str就是StringBuffer实例的强引用 软引用在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常内存不足即回收 内存足够时，不会回收软引用的可达对象；内存不足时，会回收软引用的可达对象 123Object obj = new Object(); //声明强引用SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; //销毁强引用 弱引用只被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。但是由于垃圾回收器的线程通常优先级很低，因此不一定能很快发现持有弱引用的对象，这种情况下，弱引用对象可以存在较长时间。 123Object obj = new Object(); //声明强引用WeakReference&lt;Object&gt; wr = new WeakReference&lt;Object&gt;(obj);obj = null; //销毁强引用 虚引用一个对象是否有虛引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虛引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知（跟踪垃圾回收过程） 虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虛引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。 1234object obj = new object();ReferenceQueuephantomQueue = new ReferenceQueue( ) ;PhantomReference&lt;object&gt; pf = new PhantomReference&lt;object&gt;(obj, phantomQueue); obj = null; 终结器引用（*）用以实现对象的finalize方法，无需手动编码，内部配合引用队列使用。在GC时，终结器引用入队。由Finalize线程通过终结器引用找到被引用对象并调用它的finalize方法，第二次GC时才能回收被引用对象","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"5-nginx-负载均衡","slug":"5-nginx-负载均衡","date":"2022-07-18T16:03:38.000Z","updated":"2022-07-18T16:15:54.564Z","comments":true,"path":"2022/07/19/5-nginx-负载均衡/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/19/5-nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","excerpt":"","text":"Nginx八层负载均衡upstream指令该指令是用来定义一组服务器，它们可以是监听不同端口的服务器，并且也可以是同时监听TCP和Unix socket的服务器。 服务器可以指定不同的权重，默认为1 server指令该指令用来指定后端服务器的名称和一些参数，可以使用域名、IP、端口或者Unix socket 负载均衡案例 客户端发送请求，通过nginx进行负载均衡到各个服务器上（proxy_pass指令） 负载均衡状态代理服务器在负责均衡调度中的状态有以下几个： 1）down：将该服务器标记为永久不可用，该代理服务器不参与负载均衡 down状态一般会对需要停机维护的服务器进行设置 2）backup将该服务器标记为备份服务器，当主服务器不可用时，将用来传递请求 当正常访问时，因为此时9002已经作为了备份服务器，所以nginx只负载均衡到9003端口。 当9003端口不可用时，9002将传递请求，此时nginx负载均衡到9002端口 3）max_fails 和 fail_timeout max_fails=number 设置允许请求代理服务器失败的次数，默认为1 fail_timeout=time 设置经过max_fails失败后，服务暂停的时间，默认为10s 案例 当9003服务器出问题后，如果访问失败的次数达到3次后，在15s内 9003服务器将不再提供服务 4）max_connsmax_conns=number 用来设置代理服务器同时活动链接的最大数量，默认为0，表示不限制 使用该配置可以根据后端服务器处理请求的并发量来进行设置，防止后端服务器被压垮。 负载均衡策略 算法名称 说明 轮询 默认方式 weight 权重方式 ip_hash 依据ip分配方式 least_conn 依据最少连接方式 url_hash 依据URL分配方式 fair 依据响应时间方式 轮询是upstream模块负载均衡默认的策略，每个请求会按时间顺序注意分配到不同的后端服务器 weight加权[加权轮询]weight=number：用来设置服务器的权重 权重数据越大，被分配到的概率就越高 ip_hash当对后端的多台动态应用服务器做负载均衡时，ip_hash指令能够将某个客户端IP的请求通过哈希算法定位到同一台后端服务器上 least_conn最少连接，把请求转发给连接数较少的后端服务器。轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同 但是，有些请求占用的时间很长，会导致其所在的后端负载较高 在这种情况下，使用least_conn可以达到更好的方法（适合请求长短不一导致服务器过载的情况） url_hash按访问的url的hash结果来分配请求，使某个url定向到同一个后端服务器，要配合缓存命中来使用。 使用url_hash，可以使得同一个url（也就是同一个资源请求）会到达同一台服务器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取 fairfair采用的不是内建负载均衡使用的轮换的均衡算法，而是可以根据页面大小、加载时间长短智能的进行负载均衡。 安装 nginx-upstream-fair 模块 下载nginx-upstream-fair模块：https://github.com/gnosek/nginx-upstream-fair 将下载的文件上传到服务器并进行解压缩：unzip nginx-upstream-fair-master.zip 重命名资源：mv nginx-upstream-fair-master fair 将资源添加到Nginx模块中：./configure --add-module=/root/fair 编译：make 案例一：对所有请求实现一般轮询规则的负载均衡 案例二：对所有请求实现加权轮询规则的负载均衡 案例三：对特定资源实现负载均衡 案例四：对不同域名实现负载均衡 案例五：实现带有URL重写的负载均衡 Nginx四层负载均衡需要添加stream模块的支持 将原有&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx进行备份 拷贝nginx之前的配置信息 在nginx的安装源码进行配置指定对应模块 .&#x2F;configure –with-stream 通过make模板进行编译 将objs下面的nginx移动到&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin下 在源码目录下执行 make upgrade进行升级，这个可以实现不停机添加新模块的功能 stream指令和upstream指令 该指令提供在其中指定流服务器指令的配置文件上下文。和http指令同级 案例：","categories":[],"tags":[]},{"title":"4-nginx-反向代理","slug":"4-nginx-反向代理","date":"2022-07-18T15:34:35.000Z","updated":"2022-07-18T15:55:45.767Z","comments":true,"path":"2022/07/18/4-nginx-反向代理/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/18/4-nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/","excerpt":"","text":"Nginx反向代理的配置语法Nginx反向代理模块的指令是由ngx_http_proxy_module模块进行解析 proxy_pass用来设置被代理服务器地址，可以是主机名称、IP地址加端口号形式 URL：需要进行设置的被代理服务器地址，包含传输协议(http,https:&#x2F;&#x2F;)、主机名称或IP地址加端口号、URI等要素 当proxy_pass时，要注意是否要在URL后面加 &#x2F; 的问题： 当客户端访问 http://localhost/index.html，效果是一样的 当客户端访问 http://localhost/server/index.html 的时候 第一个proxy_pass就变成了 http://localhost/server/index.html 第二个proxy_pass就变成了 http://localhost/index.html 效果就不一样了 当没有斜杠时，location后的路径会加上去，有斜杠时，则不会。 proxy_set_header更改Nginx服务器接收到的客户端请求的请求头信息，然后将新的请求头发送给代理的服务器 测试案例：以140为代理服务器，141为被代理服务器，发送请求头信息username为HZY 代理服务器 [192.168.174.140] 被代理服务器 [192.168.174.141] proxy_redirect重置头信息中的”Location”和”Refresh”的值 测试案例： 当发送192.168.174.140:8081&#x2F;add.html请求时，代理服务端（140）将请求代理到 141 服务端（141）判断当前请求的资源路径是否为空，如果为空，则返回状态码302，临时重定向到192.168.174.141:80，访问默认的index.html 反向代理案例 如图所示，当用户发送请求到代理服务器端，http://192.168.174.140:8082/server1，请求将会被代理到http://192.168.174.141:9001/上面 反向代理系统调优反向代理值：Buffer（缓冲）和Cache（缓存） 相同点：两种方式都是提高IO吞吐效率，提升nginx代理的性能 不同点： Buffer是用来解决不同设备之间数据传递速度不一致导致的性能低的问题，BUffer中的数据一旦此次操作完成后，就可以删除 Cache主要是备份，将被代理服务器的数据缓存一份到代理服务器上去。当客户端再次获取相同的数据时，就只需要从代理服务器上去获取，而不需要再次通过被代理服务器，效率高，缓存中的数据可以重复使用，只有满足特定的条件才会删除 Proxy Buffer相关指令1）proxy_buffering该指令用来开启或者关闭代理服务器的缓冲区 2）proxy_buffers指定单个连接从代理服务器读取响应的缓存区的个数和大小 number：缓存区的个数 size：每个缓存区的大小，缓存区的总大小为number*size 3）proxy_buffer_size设置从被代理服务器获取的第一部分响应数据的大小。保持与proxy_buffers中的size一致即可，当然也可以更小。 4）proxy_busy_buffers_size用来限制同时处于BUSY状态的缓冲总大小。 5）proxy_temp_path当缓冲区存满后，仍未被Nginx服务器完全接受，响应数据就会被临时存放在磁盘文件上，该指令设置文件路径 注意path最多设置三层 6）proxy_temp_file_write_size用来设置磁盘上缓冲文件的大小 通用网站的配置1234proxy_buffering on;proxy_buffer_size 4 32k;proxy_busy_buffers_size 64k;proxy_temp_file_write_size 64k;","categories":[{"name":"nginx","slug":"nginx","permalink":"http://www.hzzzzzy.icu/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.hzzzzzy.icu/tags/nginx/"}]},{"title":"12-String相关","slug":"12-String相关","date":"2022-07-16T05:46:25.000Z","updated":"2022-07-19T12:06:22.850Z","comments":true,"path":"2022/07/16/12-String相关/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/16/12-String%E7%9B%B8%E5%85%B3/","excerpt":"","text":"String具有不可变性1）当对字符串进行重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值 2）当对现有的字符串进行连接操作的时候，也需要重新指定内存区域赋值，不能使用原有的value进行赋值 3）当调用String的 replace() 方法修改指定字符或字符串的时候，也需要重新指定内存区域赋值，不能使用原有的value进行赋值 注意：String声明为final，不可被继承 123456@Testpublic void test1() &#123; String s1 = &quot;abc&quot;;//字面量定义的方式，&quot;abc&quot;存储在字符串常量池中 String s2 = &quot;abc&quot;; System.out.println(s1 == s2) //true&#125; 1234567@Testpublic void test2() &#123; String s1 = &quot;abc&quot;;//字面量定义的方式，&quot;abc&quot;存储在字符串常量池中 String s2 = &quot;abc&quot;; s1 = &quot;hello&quot; System.out.println(s1 == s2) //false&#125; 12345678@Testpublic void test3() &#123; String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;; s2 += &quot;def&quot;; System.out.println(s2);//abcdef System.out.println(s1);//abc&#125; 1234567@Testpublic void test4() &#123; String s1 = &quot;abc&quot;; String s2 = s1.replace(&#x27;a&#x27;, &#x27;m&#x27;); System.out.println(s1);//abc System.out.println(s2);//mbc&#125; 字符串常量池不会存储相同内容的字符串1、String的String Pool是一个固定大小的 Hashtable，如果放进String Pool的String非常多，就会造成Hash冲突严重，导致链表会很长，而链表长了之后直接会造成的影响是当调用String.intern时性能会下降 2、jdk6中StringTable的长度是固定的（1009），jdk7中StringTable的长度默认是60013，jdk8的可设置的最小值是1009。两个版本都可以**调整StringTable的值，使用 -XX:StringTableSize ** String的内存分配概述8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种：1、直接使用双引号声明出来的String对象会直接存储在常量池中（比如： String info = “abc” ）2、也可以使用String提供的intern()方法手动将字符串加入常量池中 12345678910public static void main(String[] args) &#123;//line 1 int i = 1;//line 2 Object obj = new Object();//line 3 Memory mem = new Memory();//line 4 mem.foo(obj);//line 5&#125;//line 9private void foo(Object param) &#123;//line 6 String str = param.toString();//line 7 System.out.println(str);&#125;//line 8 注意：完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量) 并且必须是指向同一个String类实例。 1234567891011121314151617public static void main(String[] args) &#123; System.out.println();//2293 System.out.println(&quot;1&quot;);//2294 System.out.println(&quot;2&quot;);System.out.println(&quot;3&quot;); System.out.println(&quot;4&quot;);System.out.println(&quot;5&quot;); System.out.println(&quot;6&quot;);System.out.println(&quot;7&quot;); System.out.println(&quot;8&quot;);System.out.println(&quot;9&quot;); System.out.println(&quot;10&quot;);//2303 //如下的字符串&quot;1&quot; 到 &quot;10&quot;不会再次加载 System.out.println(&quot;1&quot;);//2304 System.out.println(&quot;2&quot;);//2304 System.out.println(&quot;3&quot;);System.out.println(&quot;4&quot;); System.out.println(&quot;5&quot;);System.out.println(&quot;6&quot;); System.out.println(&quot;7&quot;);System.out.println(&quot;8&quot;); System.out.println(&quot;9&quot;);//2304 System.out.println(&quot;10&quot;);//2304&#125; 字符串拼接操作常量与常量的拼接结果在常量池，原理是编译器优化常量池中不会存在相同内容的常量 拼接中只有其中有一个是变量，拼接后的结果就在堆中。变量拼接的原理是 StringBulider 如果拼接的结果调用 intern方法，则主动将常量池中还没有的字符串对象放到池中，并返回此对象的地址 测试1常量与常量拼接 12345678910111213//在反编译出来后的文件中也可以看到s1是“abc”//从字节码文件中也可以看出开始就将abc放到字符串常量池里面public void test1()&#123; String s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;//编译期优化：等同于&quot;abc&quot; String s2 = &quot;abc&quot;; //&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2 /* * 最终.java编译成.class,再执行.class * String s1 = &quot;abc&quot;; * String s2 = &quot;abc&quot; */ System.out.println(s1 == s2); //true System.out.println(s1.equals(s2)); //true&#125; 测试2常量与常量，常量与变量，变量与变量拼接 123456789101112131415161718192021222324@Testpublic void test2()&#123; String s1 = &quot;javaEE&quot;; String s2 = &quot;hadoop&quot;; String s3 = &quot;javaEEhadoop&quot;; String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;;//编译期优化 //如果拼接符号的前后出现了变量，则相当于在堆空间中new String() String s5 = s1 + &quot;hadoop&quot;; String s6 = &quot;javaEE&quot; + s2; String s7 = s1 + s2; System.out.println(s3 == s4);//true System.out.println(s3 == s5);//false System.out.println(s3 == s6);//false System.out.println(s3 == s7);//false System.out.println(s5 == s6);//false System.out.println(s5 == s7);//false System.out.println(s6 == s7);//false //intern():判断字符串常量池中是否存在javaEEhadoop值 //如果存在，则返回常量池中javaEEhadoop的地址； //如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。 String s8 = s6.intern(); System.out.println(s3 == s8);//true&#125; 测试312345678@Testpublic void test3()&#123; String s1 = &quot;a&quot;; String s2 = &quot;b&quot;; String s3 = &quot;ab&quot;; String s4 = s1 + s2;// System.out.println(s3 == s4);//false&#125; 如下的s1 + s2 的执行细节：① StringBuilder s3 = new StringBuilder();② s3.append(&quot;a&quot;)③ s3.append(&quot;b&quot;)④ s3.toString() –&gt; 约等于 new String(&quot;ab&quot;) 补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer 测试41、字符串拼接操作不一定使用的是StringBuilder。如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。 2、针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。 12345678910111213141516171819@Testpublic void test4()&#123; final String s1 = &quot;a&quot;; final String s2 = &quot;b&quot;; String s3 = &quot;ab&quot;; String s4 = s1 + s2; System.out.println(s3 == s4);//true&#125;@Testpublic void test5()&#123; String s1 = &quot;javaEEhadoop&quot;; String s2 = &quot;javaEE&quot;; String s3 = s2 + &quot;hadoop&quot;; System.out.println(s1 == s3);//false final String s4 = &quot;javaEE&quot;;//s4:常量 String s5 = s4 + &quot;hadoop&quot;; System.out.println(s1 == s5);//true&#125; 测试51234567891011121314151617181920212223@Testpublic void test6()&#123; long start = System.currentTimeMillis(); method1(100000);//4503 method2(100000);//8 long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间为：&quot; + (end - start));&#125;//方法一：public void method1(int highLevel)&#123; String src = &quot;&quot;; for(int i = 0;i &lt; highLevel;i++)&#123; src = src + &quot;a&quot;;//每次循环都会创建一个StringBuilder、String &#125;&#125;//方法二：public void method2(int highLevel)&#123; //只需要创建一个StringBuilder StringBuilder src = new StringBuilder(); for (int i = 0; i &lt; highLevel; i++) &#123; src.append(&quot;a&quot;); &#125;&#125; 执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式1、StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象2、使用String的字符串拼接方式：创建过多个StringBuilder和String的对象3、使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用更大；如果进行GC，需要花费额外的时间。 intern()的用法 1、intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放到字符串常量池里面 2、在任意字符串上调用intern方法，其返回结果所指向的类实例必须和直接以常量形式出现的字符串实例完全相同 ​ 如：(&quot;a&quot;+&quot;b&quot;+&quot;c&quot;).intern() == &quot;abc&quot; 3、其实intern方法就是确保字符串在内存中只有一份拷贝。这样可以节约内存空间，加快字符串操作任务的执行速度（该值会存放在字符串常量池） 保证变量指向字符串常量池的方法字面量定义的方式1String s = &quot;test&quot;; 调用intern()12String s = new String(&quot;test&quot;).intern();String s = new StringBuilder(&quot;test&quot;).toString().intern(); 问题案例1、new String(&quot;&quot;)会创建几个对象1String str = new String(&quot;ab&quot;); 两个对象，一个对象是：new关键字在堆空间创建的。另一个对象是：字符串常量池中的对象”ab”。 字节码指令：ldc 注意：此时在字符串常量池中，存在”ab” 2、new String(&quot;a&quot;)+new String(&quot;b&quot;)会创建几个对象 对象1：new StringBuilder() 对象2： new String(“a”) 对象3： 常量池中的”a” 对象4： new String(“b”) 对象5： 常量池中的”b” 对象6 ：new String(“ab”) 注意：toString()的调用，在字符串常量池中，没有生成”ab” 测试1234567891011121314public static void main(String[] args) &#123; String s1 = new String(&quot;1&quot;); s1.intern();//调用此方法之前，字符串常量池中已经存在了&quot;1&quot; String s2 = &quot;1&quot;; System.out.println(s1 == s2);//jdk6：false jdk7/8：false String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);//s3变量记录的地址为：new String(&quot;11&quot;) //执行完上一行代码以后，字符串常量池中，不存在&quot;11&quot; s3.intern();//在字符串常量池中生成&quot;11&quot;。 //jdk6:创建了一个新的对象&quot;11&quot;,也就有新的地址。 //jdk7:字符串常量池在堆空间中，为了节省内存。此时常量中并没有创建&quot;11&quot;,而是创建一个指向堆空间中new String(&quot;11&quot;)的地址 String s4 = &quot;11&quot;;//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址 System.out.println(s3 == s4);//jdk6：false jdk7/8：true&#125; 123456789public static void main(String[] args) &#123; //StringIntern.java中练习的拓展： String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);//new String(&quot;11&quot;) //执行完上一行代码以后，字符串常量池中，不存在“11” String s4 = &quot;11&quot;;//在字符串常量池中生成对象&quot;11&quot; String s5 = s3.intern(); System.out.println(s3 == s4);//false System.out.println(s5 == s4);//true&#125; 总结instern方法jdk1.6中将这个字符串对象尝试放入字符串常量池 如果字符串常量池有，则不会放入。返回已有的串池中的对象的地址 如果没有，会把此对象复制一份，放入字符串常量池，返回字符串常量池中的对象地址 jdk1.7中将这个字符串对象尝试放入字符串常量池 如果字符串常量池有，则不会放入。返回已有的串池中的对象的地址 如果没有，会把此对象的引用地址复制一份，放入字符串常量池，返回字符串常量池中的对象地址 intern()练习1234567891011public static void main(String[] args) &#123; String x = &quot;ab&quot;; String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);//new String(&quot;ab&quot;) //在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot; String s2 = s.intern();//jdk6中：在串池中创建一个字符串&quot;ab&quot; //jdk8中：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，将此引用返回 System.out.println(s2 == &quot;ab&quot;);//jdk6:true jdk8:true System.out.println(s == &quot;ab&quot;);//jdk6:false jdk8:true&#125; 1234567public static void main(String[] args) &#123; String s1 = new String(&quot;ab&quot;);//执行完以后，会在字符串常量池中会生成&quot;ab&quot;// String s1 = new String(&quot;a&quot;) + new String(&quot;b&quot;);////执行完以后，不会在字符串常量池中会生成&quot;ab&quot; s1.intern(); String s2 = &quot;ab&quot;; System.out.println(s1 == s2); &#125;","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"11-执行引擎","slug":"11-执行引擎","date":"2022-07-15T12:50:19.000Z","updated":"2022-07-16T05:46:38.641Z","comments":true,"path":"2022/07/15/11-执行引擎/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/15/11-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/","excerpt":"","text":"概述1、执行引擎是Java虚拟机的核心组成部分之一 2、执行引擎的任务是将字节码指令解释&#x2F;编译为对应平台上的本地机器指令 （其实执行引擎就是将高级语言翻译为机器语言） 3、执行引擎的工作过程 输入的是字节码二进制流 处理过程是字节码解析执行的等效过程 输出是执行结果 4、执行引擎在执行的过程中需要执行的字节码指令完全 依赖于PC寄存器 5、每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址 6、在方法的执行过程中，执行引擎有可能会通过存储在局部变量表中的对象引用定位到存储在java堆中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息 7、执行引擎包括解释器，及时编译器，垃圾回收器 java代码编译和执行的过程大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图的各个步骤 解释器： ​ 当java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行 ​ 将字节码文件中的内容翻译为对应平台的本地机器指令执行 JIT编译器： ​ 虚拟机将源代码直接编译成和本地机器平台相关的机器语言 机器码、指令、汇编语言机器码各种用二进制编码方式表示的指令称为机器指令码（机器语言） 编写的程序输入计算机，CPU直接读取运行，执行速度相比其他语言最快，而且机器指令和CPU密切相关，不同种类的CPU机器指令不同 指令由于机器码是由0，1组成的二进制序列，为了增加可读性，将机器码中特定的0，1序列简化为对应的指令。 不同的硬件平台的同一种指令，对应的机器码也可能不同 指令集每个平台所支持的指令称为对应平台的指令集 例如： x86指令集 -&gt; 对应x86架构的平台 ARM指令集 -&gt; 对应ARM架构的平台 汇编语言使用助记符代替机器指令的操作码，用地址符号或标号替代指令或操作数的地址 高级语言计算机执行高级语言编写的程序时，需要将程序解释和编译成机器的指令码。（这个过程称为解释程序或编译程序） 字节码1、字节码其实是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能称为机器码 2、字节码的实现方式是编译器和虚拟机器（编译器将源码翻译成字节码，特定平台上的虚拟机器将字节码转义为可以直接执行的指令） 主要目的是为了实现跨平台性 解释器1、利用解释器来逐行解析字节码文件，其实解释器的作用就是将字节码文件中的内容翻译为对应平台的本地机器指令执行 2、当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作 分类（*）字节码解释器：执行时通过纯软件代码模拟字节码执行，效率低下 模板解释器：将每一条字节码和一个模板函数相关联，模板函数直接产生该字节码执行时的机器码，效率较高 注意：1、无论是哪种解释器，效率还是比即时编译器低的 2、解释器存在的必要性：程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。在一定时间过后，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。 JIT编译器前端编译器：将 .java 文件转变成 .class 文件的过程 后端编译器（JIT编译器）：将字节码转变成机器码的过程 静态提前编译器（AOT编译器）：直接将 .java 文件编译成本地机器代码的过程 热点代码及探测方式1、决定是否启用 JIT 编译器需要根据代码被调用执行的频率而定。关于需要被编译为本地代码的字节码，称为”热点代码“ 2、JIT 编译器运行时会针对那些频繁被调用的热点代码做深度优化，将其直接编译为对应平台的本地机器指令，提高执行性能 热点代码：一个多次调用的方法或者方法体内循环次数较多的循环体都可以称为热点代码（这种编译方式由于发生在方法的执行过程中，因此也被称为栈上替换，OSR） 基于计数器的热点探测判断一个方法被调用多少次，或循环体循环多少次才能称为热点代码的标准 HotSpot虚拟机为每个方法都创建两个不同类型的计数器 方法调用计数器统计方法的调用次数，可以通过参数 -XX:CompileThreshold进行设定，Client默认是1500次，Server默认是10000次，超过阈值，触发 JIT 编译 热度衰减 方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率 （一段时间内方法的执行频率）当超过一定限度时，如果方法的调用次数不足让它提交给即时编译器，那么这个方法的调用计数器就会减少一半，这个过程称为调用计数器热度的衰减，这段时间就称为该方法统计的半衰周期 关闭热度衰减：-XX:UseCounterDecay 设置半衰期的时间：-XX:CounterHalfLifeTime（单位为s） 回边计数器统计循环体的循环次数 设置程序执行方式-Xint：完全采用解释器模式执行程序 -Xcomp：完全采用即时编译器（如果即时编译器出现问题，解释器会介入执行） -Xmixed：采用解释器+即时编译器的混合模式 JIT分类Client Compiler和Server Compiler（简称为C1和C2） C1-client：指定运行在Client模式下，C1会对字节码进行简单可靠的优化，耗时短 C2-server：指定运行在Server模式下，C2进行耗时较长的优化以及激进优化，但优化的代码执行效率更高 C1和C2的优化策略（*） Graal编译器与AOT编译器（*）","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"10-直接内存","slug":"10-直接内存","date":"2022-07-15T11:34:48.000Z","updated":"2022-07-15T12:49:26.656Z","comments":true,"path":"2022/07/15/10-直接内存/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/15/10-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/","excerpt":"","text":"1、直接内存不是虚拟机运行时数据区的一部分，而是在Java堆外，直接向系统申请的内存空间 2、来源于NIO，通过存在堆中的 DirectByteBuffer 操作本地内存 123456789private static final int BUFFER = 1024 * 1024 * 1024;//1GBpublic static void main(String[] args)&#123; //直接分配本地内存空间 ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER); System.out.println(&quot;直接内存分配完毕&quot;); byteBuffer = null; System.out.println(&quot;直接内存开始释放！&quot;); System.gc();&#125; 3、通常访问直接内存的速度会优于访问java堆的速度（读写性能更高，适用于读写频繁的场合） 4、java的NIO库运行java程序使用直接内存用于数据缓冲 5、直接内存大小可以通过MaxDirectMemorySize设置，如果不指定，默认与堆的最大值-Xmx参数值一致，但是由于直接内存在java堆外，因此它不会直接受限于-Xmx指定的最大堆大小，它和java堆受限于操作系统能给出的最大内存 6、简单理解： java process memory = java heap + native memory","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"09-对象的实例化，内存布局和访问定位","slug":"09-对象的实例化，内存布局和访问定位","date":"2022-07-14T08:02:22.000Z","updated":"2022-07-15T11:32:44.968Z","comments":true,"path":"2022/07/14/09-对象的实例化，内存布局和访问定位/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/14/09-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%8C%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"对象实例化与创建对象实例化的概述（点我） 测试对象实例化的过程 ①加载类元信息 ②为对象分配内存 ③处理并发问题 ④属性的默认初始化（零值初始化） ⑤设置对象头信息 ⑥属性的显示初始化、代码块中初始化、构造器中初始化 创建的过程（字节码角度） 对象的内存布局内存布局（点我） 对象的访问定位对象访问定位概述（点我）","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"08-方法区","slug":"08-方法区","date":"2022-07-14T06:34:12.000Z","updated":"2022-07-14T08:56:23.555Z","comments":true,"path":"2022/07/14/08-方法区/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/14/08-%E6%96%B9%E6%B3%95%E5%8C%BA/","excerpt":"","text":"方法区的演变 只有HotSpot虚拟机才有永久代 1、jdk1.6之前：又永久代，静态变量存储在永久代上 2、jdk1.7：又永久代，字符串常量池，静态变量移除，保存在堆中 3、jdk1.8以后：无永久代，类型信息、字段、方法、常量池保存在本地内存的元空间，但字符串常量池，静态变量仍在堆 永久代为什么要被元空间替换？1、为永久代设置空间大小是很难确定的如果动态加载类过多，容易产生永久代的OOM，而元空间使用本地内存，只受本地内存的影响 2、对永久代调优困难 字符串常量池为什么要放到堆空间？因为永久代的回收率很低，在进行full GC的时候才会触发，而full GC是老年代空间不足、永久代不足时才会触发，所以导致回收效率不高。但是实际中又有大量字符会被创建，回收效率低导致永久代空间不足。放到堆里，可以及时回收。 方法区的概述1、方法区在JVM启动的时候被创建，它的实际的物理内存空间可以是不连续的（关闭 JVM 就会释放这个区域的内存） 2、方法区时逻辑上是堆的一个组成部分，但是在不同虚拟机里头实现是不一样的，最典型的就是永久代(PermGen space)和元空间(Metaspace)（注意：方法区是一种规范，而永久代和元空间是它的一种实现方式） 3、方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类,导致方法区溢出，虚拟机同样会抛出内存溢出错误：(java.lang.OutOfMemoryError:PermGen space、java.lang.OutOfMemoryError:Metaspace) 加载过多的jar包 tomcat部署的过程过多 反射类太多 4、jdk7及以前，将方法区的实现称为永久代，jdk8之后，使用元空间取代了永久代 5、元空间和永久代的区别：元空间不在虚拟机设置的内存中，而是使用本地内存 设置方法区大小与OOMjdk7及以前 -XX:PermSize=100m（默认值是20.75M） -XX:MaxPermSize=100m（32位机器默认是64M，64位是82M） jdk1.8及以后 -XX:MetaspaceSize=100m（windows默认约等于21M） -XX:MaxMetaspaceSize=100m（默认是-1,即没有限制） 方法区的内部结构存储已被虚拟机记载的类型信息、常量、静态变量、即时编译器编译后的代码缓存、域信息、方法信息 类型信息对每个加载的类型（类，接口，枚举，注解）JVM 必须在方法区中存储以下类型信息 1、类型的完整有效名称（全名&#x3D;包名.类名） 2、直接父类的完整有效名（接口和Object类没有） 3、修饰符 4、直接接口的一个有序列表 域信息域名称，域修饰符（public，private……），域类型 方法信息1、方法名称 2、方法返回类型 3、方法参数的数量和类型（按顺序） 4、方法的字节码，操作数栈和局部变量表的大小 non-final的类变量1、静态变量和类关联在一起，随着类的加载而加载 2、类变量被所有类的实例共享，即使没有类实例也可以访问它 以下代码不会报空指针异常 123456789101112131415public class MethodAreaTest &#123; public static void main(String[] args) &#123; Order order = null; order.hello(); System.out.println(order.count); &#125;&#125;class Order &#123; public static int count = 1; public static final int number = 2; public static void hello() &#123; System.out.println(&quot;hello!&quot;); &#125;&#125; 全局常量：static final每个全局常量在编译的时候就会被分配 常量池与运行时常量池方法区内部包含了运行时常量池 字节码文件中包含了常量池 当类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址 常量池的理解常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型、字面量等信息（主要是字面量和符号引用） 一个 java 程序编译生成字节码文件后，字节码文件需要大量数据支持进行解析，如果将数据直接存进字节码，文件过大所以将数据存进常量池，字节码中包含了指向常量池的引用 运行时常量池字节码文件中的常量池表经过类加载器放到方法区后，对应的结构就称为运行时常量池 当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址 注意： 1、运行时常量池是方法区的一部分。 2、运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用 此时不再是常量池中的符号地址了，这里换为真实地址。 3、运行时常量池相较于Class文件中的常量池的特征：动态性 4、符号地址变为真实地址其实就是，在*.class文件被加载到内存以后，将*.class文件中常量池中的#x符号地址，转化为内存中的地址。 方法区的垃圾收集 前言： 方法区内常量池之中主要存放的两大类常量：字面量和符号引用。 字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。 符号引用则属于编译原理方面的概念，包括 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 方法区中主要回收 1、常量池中废弃的常量 2、不再使用的类型 只要常量池中的常量没有被任何地方引用，就可以被回收（与堆中回收对象类似） 判断一个类是否要进行回收（*）","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"3-nginx-静态资源部署","slug":"3-nginx-静态资源部署","date":"2022-07-13T13:21:21.000Z","updated":"2022-07-13T13:31:08.808Z","comments":true,"path":"2022/07/13/3-nginx-静态资源部署/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/13/3-nginx-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2/","excerpt":"","text":"静态资源的配置指令listen指令： 用来配置监听端口 default_server属性是标识符，用来将此虚拟主机设置成默认主机 所谓的默认主机指的是如果没有匹配到对应的address:port，则会默认执行的。 如果不指定默认使用的是第一个server server_name指令：用来设置虚拟主机服务名称 三种匹配方式：精确匹配、通配符匹配、正则表达式匹配 精确匹配 域名是要收取一定的费用，所以可以使用修改hosts文件来制作一些虚拟域名来使用。需要修改 /etc/hosts 文件来添加 通配符匹配server_name中支持通配符”*“,但需要注意的是通配符不能出现在域名的中间，只能出现在首段或尾段 (*)代表任意字符 正则表达式匹配server_name中可以使用正则表达式，并且使用 ~ 作为正则表达式字符串的开始标记 括号取值 匹配执行顺序1、准确匹配 2、通配符在开始时匹配 3、通配符在结束时匹配 4、正则表达式匹配 5、被默认的default_server处理，如果没有指定默认找第一个server","categories":[{"name":"nginx","slug":"nginx","permalink":"http://www.hzzzzzy.icu/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.hzzzzzy.icu/tags/nginx/"}]},{"title":"2-nginx-配置到系统服务和系统环境","slug":"2-nginx-配置到系统服务和系统环境","date":"2022-07-13T13:06:05.000Z","updated":"2022-07-13T13:10:46.355Z","comments":true,"path":"2022/07/13/2-nginx-配置到系统服务和系统环境/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/13/2-nginx-%E9%85%8D%E7%BD%AE%E5%88%B0%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83/","excerpt":"","text":"一、将nginx配置到系统服务1、在 /usr/lib/systemd/system 目录下添加nginx.service,内容如下 12345678910111213141516[Unit]Description=nginx web serviceDocumentation=http://nginx.org/en/docs/After=network.target[Service]Type=forkingPIDFile=/usr/local/nginx/logs/nginx.pidExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.confExecStart=/usr/local/nginx/sbin/nginxExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s stopPrivateTmp=true[Install]WantedBy=default.target 2、添加完成后如果权限有问题需要进行权限设置 1chmod 755 /usr/lib/systemd/system/nginx.service 3、使用系统命令来操作Nginx服务 二、将nginx命令配置到系统环境1、修改 /etc/profile 文件 123vim /etc/profile在最后一行添加export PATH=$PATH:/usr/local/nginx/sbin 2、使配置立即生效 1source /etc/profile","categories":[{"name":"nginx","slug":"nginx","permalink":"http://www.hzzzzzy.icu/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.hzzzzzy.icu/tags/nginx/"}]},{"title":"07-堆","slug":"07-堆","date":"2022-07-13T00:46:19.000Z","updated":"2022-07-13T11:59:26.367Z","comments":true,"path":"2022/07/13/07-堆/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/13/07-%E5%A0%86/","excerpt":"","text":"堆的核心概述一个进程对应一个JVM实例，一个JVM实例中有一个运行时数据区，一个运行时数据区中只有一个堆空间 进程中的多个线程各自拥有一套程序计数器，本地方法栈，虚拟机栈，但是多个线程共享同一个堆空间 一个JVM实例只存在一个堆内存，堆是Java内存管理的核心区域 堆区在JVM启动的时候就被创建，其空间大小也确定了（JVM管理的最大一块内存区域，大小可调节） 堆可以处于物理上不连续的内存空间，但在逻辑上它应该被视为连续的 多个线程共享一个堆区，容易造成并发性能差的问题，所以堆划分出线程私有的缓冲区，每个线程占一份 几乎所有的对象实例都在这里分配内存 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，指向对象或数组在堆中的位置 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾回收的时候会被移除（只是移除了方法区指向堆空间的索引，如果方法结束就移除堆中的对象的话，当方法多次调用时，会因为多次 GC而影响系统性能） 123456789101112public class SimpleHeap &#123; private int id; public SimpleHeap(int id) &#123;this.id = id;&#125; public void show() &#123; System.out.println(&quot;My ID is &quot; + id); &#125; public static void main(String[] args) &#123; SimpleHeap sl = new SimpleHeap(1); SimpleHeap s2 = new SimpleHeap(2); &#125;&#125; 堆内存结构概述和OOM堆空间细分为 JDK 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区 JDK 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间 新生区&lt;&#x3D;&gt;新生代&lt;&#x3D;&gt;年轻代 养老区&lt;&#x3D;&gt;老年区&lt;&#x3D;&gt;老年代 永久代&lt;&#x3D;&gt;永久区 堆空间大小的设置 -Xms -Xmx-Xms（默认：物理内存的1&#x2F;64）：表示堆空间（新生代＋老年代）的起始内存 -Xmx（默认：物理内存的1&#x2F;4）：则用于表示堆空间的最大内存 通常会将-Xms和-Xmx两个参数配置相同的值，目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提升性能 新生代与老年代堆区可细分为新生代和老年代，新生代又可划分为Eden空间，Survivor1空间和Survivor2空间（from区，to区） 配置新生代和老年代在堆结构中的占比（一般不进行调整） 默认情况下 -XX:NewRatio=2，表示新生代占1，老年代占2，即新生代占整个堆的1&#x2F;3 配置年轻代中的Eden和Survivor区的比例 -XX:SurvivorRatio=8，表示调整这个空间比例（Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1） 配置新生代的空间的大小：-Xmn，一般不设置 几乎所有的Java对象都是在Eden区被new出来的，大部分的Java对象的销毁都在新生代进行的 对象分配一般过程 首先对象先存储到Eden区，当Eden区存满的时候，会触发Young GC（Minor GC），此时会把用户工作进程停止，称为STW（stop the world），然后判断Eden区里面哪些对象需要回收。（如图所示，红色为回收的对象） 然后将不需要回收的对象放到from区，并加上年龄计数器1 当from区存满的时候，如果对象还不需要回收，那么就会转入到to区，然后在年龄计数器上加上1，此时Eden里面不需要回收的对象也会存储在to区 此时，form区为空，from和 to区就互相转换 当年龄计数器上的值为阈值时（默认为15）对象就会转存到老年区 采用-XX:MaxTenuringThreshold，参数可以设置对象在经过多少次GC后会被放入老年代 实际上时对 Eden区到 Survivor区过度的一种策略，是为了保证 Eden区到 Survivor区不会频繁的进行复制一直存活的对象且对Survivor区也能保证不会具有太多的一直占据的内存 关于垃圾回收，频繁在新生区进行收集，很少在养老区收集，几乎不在永久区 &#x2F; 元空间收集 特殊过程当存在一个超大对象，导致Eden区放不下的时候，该对象则会直接放到老年区 如果老年区放不下： 如果老年区本来的空间够放得下该对象，但是一部分被占用了。则进行Full GC，之后如果空间还是放不下，则直接OOM 如果老年区本来的空间就放不下该对象，直接返回OOM GC关于HotSpot VM的实现，GC按照回收区域可以分为部分收集和整堆收集 一、部分收集（Partial GC）：不是完整收集整个Java堆的垃圾收集，其中分为 新生代收集（Minor GC &#x2F; Young GC）：只是新生代（Eden&#x2F;S0&#x2F;S1）的垃圾收集 老年代收集（Major GC &#x2F; Old GC）：只是老年代的垃圾收集 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集 二、整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集 注意： 1、目前只有CMS GC会有单独收集老年代的行为 2、很多时候Major GC会和Full GC一起混合使用，需要具体分辨是老年代回收还是整堆回收 新生代GC（Minor GC）触发机制当新生代空间不足时，就会触发，这里的新生代空间不足指的是Eden区已满 注意： Survivor满不会引发GC（每次Minor GC都会清理新生代的内存） Minor GC非常频繁，回收速度较快 会引发STW 老年代GC（Major GC &#x2F; Full GC）触发机制当发生在老年代的GC，对象从老年代消失时，我们说老年代GC触发了 注意： 当老年代空间不足时，会尝试先触发Minor GC。如果之后空间还不足，则触发Major GC Major GC的速度比Minor GC满10倍以上，STW时间更长 Major GC后，如果内存还是不足，直接返回OOM Full GC触发机制（*）1、调用 System.gc() 时，系统建议执行Full GC，但是不必然执行 2、老年代空间不足 3、方法区空间不足 ………… 堆空间分代的思想分代的唯一目的就是优化GC的性能 如果没有分代，那么所有的对象都在一块，当要进行GC的时候，判断哪些对象需要回收，哪些不需要的时候，就需要对整个空间进行扫描。如果进行分代处理的话，就可以把新创建的一些对象，放在同一块区域，GC的时候就可以针对性地进行搜索，而且还可以腾出一大块区域 内存分配策略 优先分配到Eden区 大对象直接分配到老年代 长期存活的对象分配到老年代 动态对象的年龄判断：如果Survivor区中相同年龄的所有对象的和大于其空间的一般，年龄大于或等于该年龄的对象直接进入老年代 空间分配担保（*） TLAB为对象分配内存为什么要有TLAB？1、对象的创建在JVM中很频繁，所以在并发环境下从堆区中划分内存空间是线程不安全的 2、为了避免多个线程操作同一个地址，需要加锁，从而影响分配的速度 什么是TLAB？1、在Eden区域进行划分，为每个线程分配了一个私有缓存的区域 2、多个线程共同操作时，可以避免线程安全问题，提升内存分配吞吐量 注意： 1、JVM将TLAB作为内存分配的首选 2、TLAB只占 Eden的1%，当对象在TLAB空间分配内存失败后，JVM在Eden直接分配内存，而且通过加锁来确保原子性 3、TLAB大小可以通过 -XX:TLABWasteTargetPercent + 参数进行设置 总结堆空间参数设置1、-XX:+PrintFlagsInitial : 查看所有的参数的默认初始值 2、-XX:+PrintFlagsFinal : 查看所有的参数的最终值(可能会存在修改(:表示修改了),不再是初始值) 3、具体查看某个参数的指令: jps:查看当前运行中的进程 jinfo -flag SurvivorRatio 进程id 4、-Xms:初始堆空间内存 (默认为物理内存的1&#x2F;64) 5、-Xmx:最大堆空间内存(默认为物理内存的1&#x2F;4) 6、-Xmn:设置新生代的大小。(初始值及最大值) 7、-XX:NewRatio:配置新生代与老年代在堆结构的占比 默认:-XX:NewRatio=2,表示新生代占1,老年代占2,新生代占整个堆的1&#x2F;3 可以修改-XX:NewRatio=4,表示新生代占1,老年代占4,新生代占整个堆的1&#x2F;5 8、-XX:SurvivorRatio:设置新生代中Eden和S0&#x2F;S1空间的比例(Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1) 9、-XX:MaxTenuringThreshold设置新生代垃圾的最大年龄 10、-XX:+PrintGCDetails:输出详细的GC处理日志(如下这两种方式是简单的打印 gc 简要信息： 1） -XX:+PrintGC *2） -verbose:gc* 11、-XX:HandlePromotionFailure:是否设置空间分配担保(JDK6之后,只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC,否则将进行Full GC) 逃逸分析概述将堆上的对象分配到栈，需要使用逃逸分析手段 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸 当一个对象在方法中被定义后，它被外部方法所引用,则认为发生逃逸。例如作为调用参数传递到其他地方中 其实就是看new出来的对象是否有可能在方法外被调用 12345678910111213141516171819public EscapeAnalysis object; /** * 方法返回 EscapeAnalysis 对象，发生逃逸 */ public EscapeAnalysis getInstance() &#123; return object == null ? new EscapeAnalysis() : object; &#125; /** * 对象的作用域仅在当前方法中有效，没有发生逃逸 */ public void useEscapeAnalysis1() &#123; EscapeAnalysis e = new EscapeAnalysis(); &#125; /** * 引用成员变量的值，发生逃逸 */ public void useEscapeAnalysis2() &#123; EscapeAnalysis instance = getInstance(); &#125; 在jdk7及之后，可以通过 1、-XX:+DoEscapeAnalysis 显式开启逃逸分析 2、通过 -XX:+PrintEscapeAnalysis 查看逃逸分析的筛选结果 代码优化栈上分配 成员变量赋值 方法返回值 实例引用传递 在开启逃逸分析后执行时间变，而且没有发生GC 12345678910111213141516171819202122//栈上分配测试//-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetailspublic static void main(String[] args) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10000000; i++) &#123; alloc(); &#125; //查看执行时间 long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间为：&quot;+(end-start)+&quot;ms&quot;); //为了方便查看堆内存中对象的个数，线程sleep try &#123; Thread.sleep(1000000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; private static void alloc() &#123; User user = new User(); //未发生逃逸 &#125; static class User &#123; 同步省略也叫做锁消除，指在动态编译同步块时，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能被一个线程访问而没有被发布到其他线程，如果没有，那么在编译这个同步块的时候，就会取消这部分代码的同步，大大提高并发性和性能。 代码中堆obj进行加锁，但是obj对象的生命周期只在test1方法中，并不会被其他线程访问到，所以在JIT编译阶段就会优化成test2的 12345678910public void test1() &#123; Object obj = new Object(); synchronized (obj) &#123; System.out.println(obj); &#125;&#125;public void test2() &#123; Object obj = new Object(); System.out.println(obj);&#125; 分离对象或标量替换标量：一个无法再分解成更小的数据的数据，如基本数据类型 聚合量：还可以继续分解的数据，如对象 如果一个对象不会被外界访问的话，经过JIT的优化，就会把对象拆解成若干个成员变量来替代，这就是标量替换 标量替换可以大大减少堆内存的占用，因为不需要创建对象，也就不需要分配堆内存 参数：-XX:+EliminateAllocations开启标量替换，允许将对象打散分配在栈上（默认打开） 12345678910public static void main(String[] args) &#123; alloc();&#125; private static void alloc() &#123; Point point = new Point(1,2); System.out.println(&quot;x&quot; + point.x + &quot;;&quot; + &quot;y&quot; + point.y); &#125; static class Point&#123; private int x; private int y; public Point(int i, int i1) &#123;&#125; &#125; 12345private static void alloc() &#123; int x = 1; int y = 2; System.out.println(&quot;x&quot; + x + &quot;;&quot; + &quot;y&quot; + y);&#125;","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"1-nginx-目录，配置文件","slug":"1-nginx-目录，配置文件","date":"2022-07-12T23:44:07.000Z","updated":"2022-07-13T00:43:53.262Z","comments":true,"path":"2022/07/13/1-nginx-目录，配置文件/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/13/1-nginx-%E7%9B%AE%E5%BD%95%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"","text":"使用 工具tree查看目录结构1、安装tree工具： yum install -y tree 2、 tree &#x2F;usr&#x2F;local&#x2F;nginx (tree后面跟的是Nginx的安装目录) ​ 查看进程的PID1、查看nginx的master进程和worker进程： ps -ef | grep nginx 2、nginx的.&#x2F;configure的配置参数的时候，有一个参数是–pid-path&#x3D;PATH默认是 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid 所以可以通过查看该文件来获取nginx的master进程ID ​ ​ ​ 信号 信号 作用 TERM或INT 立即关闭整个服务 QUIT “优雅”地关闭整个服务 HUP 重读配置文件并使用服务对新配置项生效 USR1 重新打开日志文件，可以用来进行日志切割 USR2 平滑升级 到最新版的nginx WINCH 所有子进程不在接收处理新连接相当于给work进程发送QUIT指令 调用命令为 kill -signal PID1、发送 TERM 或 INT 信号给master进程，会将Nginx服务 立即关闭 。 2、发送 QUIT 信号给master进程，master进程会控制所有的work进程不再接收新的请求， 等所有请求处理完后，在把进程都关闭掉 3、发送 HUP 信号给master进程，master进程会把控制旧的work进程不再接收新的请求，等处理完请求后将旧的work进程关闭掉，然后根据nginx的配置文件重新启动新的work进程 4、发送 USR1 信号给master进程，告诉Nginx重新开启日志文件 5、 发送 USR2 信号给master进程， 重新开启对应的master进程和work进程 ，这时系统里会有两个master进程和四个master进程 新的master进程的PID会被记录在 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid 而之前的旧的master进程PID会被记在 &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid.oldbin文件中 最后再发送 QUIT 信号给旧的master进程 6、发送 WINCH 信号给master进程,让master进程控制不让所有的work进程在接收新的请求了 请求处理完后关闭work进程。 注意master进程不会被关闭掉 nginx命令行控制在sbin目录下，可以对nginx进行状态控制 ​ .&#x2F;nginx-v 查看版本号信息 .&#x2F;nginx-V 查看版本号信息和配置信息 .&#x2F;nginx-t 测试配置文件语法是否正确 .&#x2F;nginx-T 测试nginx的配置文件语法是否正确并列出用到的配置文件信息然后退出 .&#x2F;nginx-q 在配置测试期间禁止显示非错误消息 .&#x2F;nginx-s s即signal信号，后面可以跟 stop[快速关闭，类似于TERM&#x2F;INT信号的作用] quit[优雅的关闭，类似于QUIT信号的作用] reopen[重新打开日志文件类似于USR1信号的作用] reload[类似于HUP信号的作用] .&#x2F;nginx-p 指定Nginx的prefix路径 .&#x2F;nginx-c 指定Nginx的配置文件路径 .&#x2F;nginx-g 补充Nginx配置文件，向Nginx服务指定启动时应用全局的配置 nginx.conf配置文件结构nginx.conf配置文件中默认有三大块：全局块、events块、http块 http块中可以配置多个server块，每个server块又可以配置多个location块 ​ 全局块一、user指令可以指定启动运行工作进程的用户及用户组，这样对于系统的权限访问控制的更加精细，也更加安全 二、work process指令1、master_process:用来指定是否开启工作进程 ​ 2、worker _ processes:用于配置Nginx生成工作进程的数量 ，这个是Nginx服务器实现并发处理服务的关键所在 process的值越大，可以支持的并发处理量也越多 但事实上这个值的设定是需要受到来自服务器自身的限制建议将该值和服务器CPU的内核数保存一致 ​ ​ 三、其他指令1、deamon： 设定Nginx是否以守护进程的方式启动 守护进程是linux后台一种服务进程，特点是独立于控制终端，不会随着终端的关闭而停止 ​ ​ 2、pid： 配置nginx当前master进程的进程号ID存储的文件路径 ​ 3、error_log： 配置nginx错误日志存放路径 ​ 日志级别的值有：debug|info|notice|warn|error|crit|alert|emerg ​ 调试 |信息| 通知 | 警告 | 错误 |临界|警报|紧急 4、include： 引入其他配置文件 ​ 测试：1）创建一个main.conf，在里面写上配置文件 ​ 2）引入配置文件 ​ 3）加载成功 ​ events块1、 accept_mutex： 设置nginx网络连接序列化​ 如果设置为on，将会对多个Nginx进程接收连接进行序列号，一个个来唤醒接收， 防止了多个进程对连接的争抢 2、 multi_accept： 用来设置是否允许同时接收多个网络连接​ 如果multi_accept被禁止了，nginx一个工作进程只能同时接受一个新的连接。否则，一个工作进程可以同时接受所有的新连接 3、 worker_connections： 用来配置单个worker进程最大的连接数​ 连接数不仅仅包括和前端用户建立的连接数，而是包括所有可能的连接数 4、 use：用来设置Nginx服务器选择哪种事件驱动来处理网络消息​ HTTP块自定义MIME-Type（网络资源的媒体类型）​ default_type:用来配置Nginx响应前端请求默认的MIME类型​ ​ 自定义服务日志1、access_log:用来设置用户访问日志的相关属性 ​ ​ 2、log_format:用来指定日志的输出格式。 ​ ​ 3、sendfile:用来设置Nginx服务器是否使用sendfile()传输文件 该属性可以大大提高Nginx处理静态资源的性能 ​ 4、keepalive_timeout:用来 设置长连接的超时时间 ​ 5、keepalive_requests:用来设置一个keep-alive 连接使用的次数","categories":[{"name":"nginx","slug":"nginx","permalink":"http://www.hzzzzzy.icu/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.hzzzzzy.icu/tags/nginx/"}]},{"title":"3-2-选择排序","slug":"3-2-选择排序","date":"2022-07-12T03:17:30.000Z","updated":"2022-07-12T03:20:37.606Z","comments":true,"path":"2022/07/12/3-2-选择排序/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/3-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","excerpt":"","text":"排序原理： 1.每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较 ​ **如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引 ** 2.交换第一个索引处和最小值所在的索引处的值 ​ 原始数据到第一趟排序：假定4是最小值，让4分别与数据的其他7位元素进行比较，如果有比4小的数，交换二者位置让那个数成为最小值放在第一位，然后继续比较，直到到了元素的最后一位 第六趟到第7趟排序：假定8是最小值，与后面的10，9进行比较，如果有比4小的数，交换二者位置让那个数成为最小值放在第一位，然后继续比较，直到到了元素的最后一位 ​ 123456789101112131415161718192021222324public static void sort(Comparable[] a)&#123; for (int i = 0; i &lt; a.length - 1; i++) &#123; //定义一个变量，记录最小元素所在的索引，默认为参与选择排序的第一个元素所在的位置 int min = i; for (int j = i + 1; j &lt; a.length; j++) &#123; //需要比较最小索引min处的值和j索引处的值 if (greater(a[min],a[j]))&#123; min = j; &#125; &#125; //交换最小元素所在的索引min处的值和j索引处的值 exch(a, i, min); &#125;&#125;private static boolean greater(Comparable v,Comparable w)&#123; return v.compareTo(w)&gt;0;&#125;private static void exch(Comparable[] a,int i,int j)&#123; Comparable temp; temp = a[i]; a[i] = a[j]; a[j] = temp;&#125; 假设数组长度为n 最开始，将数组的第一个元素作为最小值所在的索引，定义为min 用两个for循环进行嵌套，第一个for循环表示，需要进行n-1趟排序 第二个for循环为了比较最小索引的值min 与 后面元素的索引值。 如果存在比最小索引min的值小的元素，则交换min与该元素的索引，使其成为最小值的索引 注意： 第二个for循环中定义 j &#x3D; i + 1 是为了在排好顺序的元素的后一位才开始进行比较 而且 j 不能越界访问，所以 j 要小于数组的长度 选择排序的时间复杂度分析： 选择排序使用了双层for循环，其中外层循环完成了数据交换，内层循环完成了数据比较， 分别统计数据 交换次数和数据比较次数： 数据比较次数： (N-1)+(N-2)+(N-3)+…+2+1&#x3D;((N-1)+1)*(N-1)&#x2F;2&#x3D;N^2&#x2F;2-N&#x2F;2; 数据交换次数： N-1 时间复杂度：N^2&#x2F;2-N&#x2F;2+（N-1）&#x3D;N^2&#x2F;2+N&#x2F;2-1; 根据大O推导法则，保留最高阶项，去除常数因子，时间复杂度为O(N^2);","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.hzzzzzy.icu/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构基础知识","slug":"数据结构基础知识","permalink":"http://www.hzzzzzy.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"3-1-冒泡排序","slug":"3-1-冒泡排序","date":"2022-07-12T03:02:22.000Z","updated":"2022-07-12T03:16:34.797Z","comments":true,"path":"2022/07/12/3-1-冒泡排序/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/3-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","excerpt":"","text":"排序原理： 1. 比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。 2. 对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值。 **初始状态到第一次冒泡 : ** 比较 4,5，5比4大，不变。 比较5,6，6比5大，不变 比较6,3，3比6小，交换二者位置 4,5,3,6,2,1 比较6,2，2比6小，交换二者位置 4,5,3,2,6,1 比较6,1，1比6小，交换二者位置 4,5,3,2,1,6 假设数组长度为n，冒泡排序必须实现n-1次冒泡（令k &#x3D; n） 第一次冒泡要有k-1次比较 第二次冒泡要有k-2次比较 第n-1次冒泡要有k-n-1次比较 123456789public static void sort(Comparable[] a)&#123; for (int i = a.length-1;i &gt; 0;i--)&#123; for (int j = 0; j &lt; i; j++) &#123; if (greater(a[j],a[j+1]))&#123; exch(a,j,j+1); &#125; &#125; &#125;&#125; 使用两个for循环进行遍历，第一个for循环表示冒泡的次数为：数组长度-1 第二个for循环表示相邻数组元素依次比较，j &lt; i 表示排序完的元素放在数组的后面，不需要再次进行排序 123456789101112131415161718192021222324252627282930313233343536373839404142package SORT;/** * @author Hzy * @create 2022/1/14 * 10:59 */// 1.public static void sort(Comparable[] a)：对数组内的元素进行排序// 2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w// 3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值public class Bubble &#123; //对数组内的元素进行排序 public static void sort(Comparable[] a)&#123; for (int i = a.length-1;i &gt; 0;i--)&#123; for (int j = 0; j &lt; i; j++) &#123; if (greater(a[j],a[j+1]))&#123; exch(a,j,j+1); &#125; &#125; &#125; &#125; //判断v是否大于w private static boolean greater(Comparable v,Comparable w)&#123; int result = v.compareTo(w); if (result&gt;0) &#123; return true; &#125; else &#123; return false; &#125;// return result&gt;0; &#125; //交换a数组中，索引i和索引j处的值 private static void exch(Comparable[] a,int i,int j)&#123; Comparable temp; temp = a[i]; a[i] = a[j]; a[j] = temp; &#125;&#125; 冒泡排序的时间复杂度分析 冒泡排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码 **所以， 分析冒泡排序的时间复杂度，主要分析一下内层循环体的执行次数即可。 ** 在最坏情况下，也就是假如要排序的元素为{6,5,4,3,2,1}逆序， 那么： 元素比较的次数为： (N-1)+(N-2)+(N-3)+…+2+1&#x3D;((N-1)+1)*(N-1)&#x2F;2&#x3D;N^2&#x2F;2-N&#x2F;2; 元素交换的次数为： (N-1)+(N-2)+(N-3)+…+2+1&#x3D;((N-1)+1)*(N-1)&#x2F;2&#x3D;N^2&#x2F;2-N&#x2F;2; 总执行次数为： (N^2&#x2F;2-N&#x2F;2)+(N^2&#x2F;2-N&#x2F;2)&#x3D;N^2-N; 按照大O推导法则，保留函数中的最高阶项那么最终冒泡排序的时间复杂度为O(N^2)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.hzzzzzy.icu/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构基础知识","slug":"数据结构基础知识","permalink":"http://www.hzzzzzy.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"2-3-算法的空间复杂度分析","slug":"2-3-算法的空间复杂度分析","date":"2022-07-12T02:58:57.000Z","updated":"2022-07-12T03:15:09.881Z","comments":true,"path":"2022/07/12/2-3-算法的空间复杂度分析/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/2-3-%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","excerpt":"","text":"一、java中常见内存占用1.基本数据类型内存占用情况： ​ 2.计算机访问内存的方式都是一次一个字节 3.一个引用（机器地址）需要8个字节表示： 例如： Date date &#x3D; new Date(),则date这个变量需要占用8个字节来表示 4.创建一个对象，比如new Date()，除了Date对象内部存储的数据(例如年月日等信息)占用的内存，该对象本身也 有内存开销，每个对象的自身开销是16个字节，用来保存对象的头信息。 5.一般内存的使用，如果不够8个字节，都会被自动填充为8字节 6.java中数组被被限定为对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要24字节的头信息 (16个自己的对象开销，4字节用于保存长度以及4个填充字节)再加上保存值所需的内存。 二、算法的空间复杂度算法的空间复杂度计算公式记作：S(n)&#x3D;O(f(n)),其中n为输入规模，f(n)为语句关于n所占存储空间的函数。 案例： 对指定的数组元素进行反转，并返回反转的内容。 ​ ​ 根据大O推导法则，算法一的空间复杂度为O(1) 算法二的空间复杂度为O(n) 所以从空间占用的角度讲，算法一要优于算法二。 由于java中有内存垃圾回收机制，并且jvm对程序的内存占用也有优化（例如即时编译），我们无法精确的评估一 个java程序的内存占用情况，但是了解了java的基本内存占用，使我们可以对java程序的内存占用情况进行估算。 由于现在的计算机设备内存一般都比较大，基本上个人计算机都是4G起步，大的可以达到32G 所以内存占用一般 情况下并不是我们算法的瓶颈，普通情况下直接说复杂度，默认为算法的时间复杂度。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.hzzzzzy.icu/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构基础知识","slug":"数据结构基础知识","permalink":"http://www.hzzzzzy.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"2-2-函数调用时间复杂度分析","slug":"2-2-函数调用时间复杂度分析","date":"2022-07-12T02:53:17.000Z","updated":"2022-07-12T03:15:24.813Z","comments":true,"path":"2022/07/12/2-2-函数调用时间复杂度分析/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/2-2-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","excerpt":"","text":"案例一：123456789public static void main(String[] args) &#123; int n=100; for (int i = 0; i &lt; n; i++) &#123; show(i); &#125;&#125;private static void show(int i) &#123; System.out.println(i);&#125; show方法的时间复杂度为O(1),main方法的时间复杂度是O(n) 案例二：1234567891011public static void main(String[] args) &#123; int n=100; for (int i = 0; i &lt; n; i++) &#123; show(i); &#125;&#125;private static void show(int i) &#123; for (int j = 0; j &lt; i; i++) &#123; System.out.println(i); &#125;&#125; 在main方法中，有一个for循环，循环体调用了show方法，由于show方法内部也有一个for循环 所以show方法 的时间复杂度为O(n)，main方法的时间复杂度为O(n^2) 案例三：1234567891011121314151617public static void main(String[] args) &#123; int n=100; show(n); for (int i = 0; i &lt; n; i++) &#123; show(i); &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; System.out.println(j); &#125; &#125;&#125;private static void show(int i) &#123; for (int j = 0; j &lt; i; i++) &#123; System.out.println(i); &#125;&#125; 在show方法中，有一个for循环，所以show方法的时间复杂度为O(n),在main方法中，show(n)这行代码内部执行 的次数为n，第一个for循环内调用了show方法，所以其执行次数为n^2,第二个嵌套for循环内只执行了一行代码， 所以其执行次数为n^2,那么main方法总执行次数为n+n^2+n^2&#x3D;2n^2+n。 根据大O推导规则，去掉n保留最高阶 项，并去掉最高阶项的常数因子2，所以最终main方法的时间复杂度为O(n^2) 最坏情况123456789public int search(int num)&#123; int[] arr=&#123;11,10,8,9,7,22,23,0&#125;; for (int i = 0; i &lt; arr.length; i++) &#123; if (num==arr[i])&#123; return i; &#125; &#125; return -1;&#125; 最好情况： 查找的第一个数字就是期望的数字，那么算法的时间复杂度为O(1) 最坏情况： 查找的最后一个数字，才是期望的数字，那么算法的时间复杂度为O(n) 平均情况： 任何数字查找的平均成本是O(n&#x2F;2) 最坏情况是一种保证，在应用中，这是一种最基本的保障，即使在最坏情况下，也能够正常提供服务，所以，除非 特别指定， 我们提到的运行时间都指的是最坏情况下的运行时间。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.hzzzzzy.icu/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构基础知识","slug":"数据结构基础知识","permalink":"http://www.hzzzzzy.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"2-1-算法时间复杂度分析","slug":"2-1-算法时间复杂度分析","date":"2022-07-12T02:43:58.000Z","updated":"2022-07-12T03:15:29.298Z","comments":true,"path":"2022/07/12/2-1-算法时间复杂度分析/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/2-1-%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","excerpt":"","text":"最高次项的指数大的，随着n的增长，结果也会变得增长特别快 算法函数中n最高次幂越小，算法效率越高 1.算法函数中的常数可以忽略； 2.算法函数中最高次幂的常数因子可以忽略； 3.算法函数中最高次幂越小，算法效率越高。 大O记法在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随着n的变化情况并确定T(n)的 量级。算法的时间复杂度，就是算法的时间量度，记作:T(n)&#x3D;O(f(n))。 它表示随着问题规模n的增大，算法执行时间 的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度，其中f(n)是问题规模n的某个函数。 执行次数&#x3D;执行时间 算法一：12345678910public static void main(String[] args) &#123; int sum = 0;//执行1次 int n=100;//执行1次 sum = (n+1)*n/2;//执行1次 System.out.println(&quot;sum=&quot;+sum);&#125; 算法二：1234567891011121314public static void main(String[] args) &#123; int sum = 0;//执行1次 int n=100;//执行1次 for (int i = 1; i &lt;= n; i++) &#123; sum += i;//执行了n次 &#125; System.out.println(&quot;sum=&quot; + sum);&#125; 算法三：1234567891011121314151617public static void main(String[] args) &#123; int sum=0;//执行1次 int n=100;//执行1次 for (int i = 1; i &lt;=n ; i++) &#123; for (int j = 1; j &lt;=n ; j++) &#123; sum+=i;//执行n^2次 &#125; &#125; System.out.println(&quot;sum=&quot;+sum);&#125; **算法一：3次 ** **算法二：n+3次 ** 算法三：n^2+2次 推导大O阶 的表示法以下几个规则可以使用： **1.用常数1取代运行时间中的所有加法常数； ** 2.在修改后的运行次数中，只保留高阶项； 3.如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数； 所以，上述算法的大O记法分别为： ​ 算法一：O(1) ​ 算法二：O(n) ​ 算法三：O(n^2) 常见的大O阶1.线性阶一般含有非嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长，例如： 123456public static void main(String[] args) &#123; int sum = 0;//执行1次 int n=100;//执行1次 sum = (n+1)*n/2;//执行1次 System.out.println(&quot;sum=&quot;+sum);&#125; 上面这段代码，它的循环的时间复杂度为O(n),因为循环体中的代码需要执行n次 2.平方阶一般嵌套循环属于这种时间复杂度 123456789public static void main(String[] args) &#123; int sum=0,n=100; for (int i = 1; i &lt;=n ; i++) &#123; for (int j = 1; j &lt;=n ; j++) &#123; sum+=i; &#125; &#125; System.out.println(sum);&#125; 上面这段代码，n&#x3D;100，也就是说，外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环 中出来，就需要执行100100次，也就是n的平方次，所以*这段代码的时间复杂度是O(n^2). 3.立方阶一般三层嵌套循环属于这种时间复杂度 1234567891011public static void main(String[] args) &#123; int x = 0, n = 100; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i; j &lt;= n; j++) &#123; for (int j = i; j &lt;= n; j++) &#123; x++; &#125; &#125; &#125; System.out.println(x);&#125; 上面这段代码，n&#x3D;100，也就是说，外层循环每执行一次，中间循环循环就执行100次，中间循环每执行一次，最 内层循环需要执行100次，那总共程序想要从这三个循环中出来，就需要执行100100100次，也就是n的立方，所 以这段代码的时间复杂度是O(n^3). 4.对数阶12345int i=1,n=100;while(i&lt;n)&#123; i = i * 2; &#125; 由于每次i2之后，就距离n更近一步，假设有x个2相乘后大于n，则会退出循环。由于是2^x&#x3D;n,得到x&#x3D;log(2)n,所 以*这个循环的时间复杂度为O(logn); 对于对数阶，由于随着输入规模n的增大，不管底数为多少，他们的增长趋势是一样的，所以我们会忽略底数。 5.常数阶一般不涉及循环操作的都是常数阶，因为它不会随着n的增长而增加操作次数。例如： 12345public static void main(String[] args) &#123; int n=100; int i=n+2; System.out.println(i);&#125; 上述代码，不管输入规模n是多少，都执行2次，根据大O推导法则，常数用1来替换，所以上述代码的时间复杂度为O(1) ​ 他们的复杂程度从低到高依次为： ​ 所以，我们的算法，尽可能的追求的是O(1),O(logn),O(n),O(nlogn)这几种时间复杂度，而如果发现算法的时间复杂度为平方阶、 立方阶或者更复杂的，那我们可以分为这种算法是不可取的，需要优化。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.hzzzzzy.icu/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构基础知识","slug":"数据结构基础知识","permalink":"http://www.hzzzzzy.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"1-1-数据结构分类","slug":"1-1-数据结构分类","date":"2022-07-12T02:32:40.000Z","updated":"2022-07-12T03:15:35.885Z","comments":true,"path":"2022/07/12/1-1-数据结构分类/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/1-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB/","excerpt":"","text":"数据结构分类： 顺序存储结构： 把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的 ，比如我们常用的数组就是顺序存储结构。 ​ 链式存储结构： 是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。此时，数据元素之间并 不能反映元素间的逻辑关系，因此在链式存储结构中引进了一个指针存放数据元素的地址，这样通过地址就可以找 到相关联数据元素的位置 逻辑结构分类： 集合结构：集合结构中数据元素除了属于同一个集合外，他们之间没有任何其他的关系。 线性结构：线性结构中的数据元素之间存在一对一的关系 树形结构：树形结构中的数据元素之间存在一对多的层次关系 图形结构：图形结构的数据元素是多对多的关系","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.hzzzzzy.icu/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构基础知识","slug":"数据结构基础知识","permalink":"http://www.hzzzzzy.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"01-设计模式的原则","slug":"01-设计模式的原则","date":"2022-07-12T02:13:01.000Z","updated":"2022-07-13T00:44:11.530Z","comments":true,"path":"2022/07/12/01-设计模式的原则/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/","excerpt":"","text":"设计模式的目的1、代码重用性 2、可读性 3、可扩展性（增加功能时，对原来的功能没有影响） 4、可靠性（增加功能时，对原来的功能没有影响） 5、高内聚，低耦合 单一职责原则一个类应该只负责一项职责 如：类 A 负责两个不同职责：职责 1，职责 2。 当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2 注意： 降低类的复杂度，一个类负责一个职责 提高类的可读性 降低变更的风险 只有类中方法数量足够少时，可以在方法级别保持单一职责原则 ​ ​ ​ 接口隔离的原则客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上 类A和类C只需要依赖接口1的一部分接口，而不需要实现全部，所以可以将接口 Interface1 拆分为独立的几个接口(这里我们拆分成 3 个接口)，类 A 和类 C 分别与他们需要的接口建立依赖关系 ​ ​ 依赖倒转原则1）高层模块不应该依赖底层模块，二者都应该依赖其抽象 2）抽象不应该依赖细节，细节应该依赖抽象 3）核心思想：面向接口编程 三种方式：接口传递，构造方法传递，setter方法传递 ​ ​ 里氏替换原则继承给程序设计带来便利也带来了弊端： 使用继承会给程序带来侵入性 可移植性降低 增加对象间的耦合 当这个类要修改时，必须考虑到所有的子类 正确使用继承： 使用继承时，在子类中尽量不要重写父类的方法 在适当的情况，可以使用聚合，组合，依赖来解决 解决方法：让原来的子类和父类都继承一个更通俗的基类，将原有的继承关系去掉，采用聚合，组合，依赖等关系来代替 ​ ​ 开闭原则 （最基础，最重要）比如一个类，模块和函数一个对扩展开发（对提供方），对修改关闭（对使用方）。 当软件需要变化，尽量通过扩展代码，而不是通过修改已有代码的方法实现 案例： 如果需要增加新的功能，绘制别的图形，需要在使用方处修改代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Ocp &#123; public static void main(String[] args) &#123; //使用看看存在的问题 GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); graphicEditor.drawShape(new Triangle()); &#125;&#125;//这是一个用于绘图的类 [使用方]class GraphicEditor &#123; //接收Shape对象，然后根据type，来绘制不同的图形 public void drawShape(Shape s) &#123; if (s.m_type == 1) drawRectangle(s); else if (s.m_type == 2) drawCircle(s); else if (s.m_type == 3) drawTriangle(s); &#125; //绘制矩形 public void drawRectangle(Shape r) &#123; System.out.println(&quot; 绘制矩形 &quot;); &#125; //绘制圆形 public void drawCircle(Shape r) &#123; System.out.println(&quot; 绘制圆形 &quot;); &#125; //绘制三角形 public void drawTriangle(Shape r) &#123; System.out.println(&quot; 绘制三角形 &quot;); &#125;&#125;//Shape类，基类class Shape &#123; int m_type;&#125;class Rectangle extends Shape &#123; Rectangle() &#123; super.m_type = 1; &#125;&#125;class Circle extends Shape &#123; Circle() &#123; super.m_type = 2; &#125;&#125;//新增画三角形class Triangle extends Shape &#123; Triangle() &#123; super.m_type = 3; &#125;&#125; 改进： 创建一个抽象类Shape，提供一个抽象方法drow，然后让子类去继承该抽象方法，重写该抽象方法，当需要增加新的功能的时候，只需要创建一个新的类去继承抽象方法并重写即可，无需对使用方代码进行改动 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Ocp &#123; public static void main(String[] args) &#123; //使用看看存在的问题 GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); graphicEditor.drawShape(new Triangle()); graphicEditor.drawShape(new OtherGraphic()); &#125;&#125;//这是一个用于绘图的类 [使用方]class GraphicEditor &#123; //接收Shape对象，调用draw方法 public void drawShape(Shape s) &#123; s.draw(); &#125;&#125;//Shape类，基类abstract class Shape &#123; int m_type; public abstract void draw();//抽象方法&#125;class Rectangle extends Shape &#123; Rectangle() &#123; super.m_type = 1; &#125; @Override public void draw() &#123; System.out.println(&quot; 绘制矩形 &quot;); &#125;&#125;class Circle extends Shape &#123; Circle() &#123; super.m_type = 2; &#125; @Override public void draw() &#123; System.out.println(&quot; 绘制圆形 &quot;); &#125;&#125;//新增画三角形class Triangle extends Shape &#123; Triangle() &#123; super.m_type = 3; &#125; @Override public void draw() &#123; System.out.println(&quot; 绘制三角形 &quot;); &#125;&#125;//新增一个图形class OtherGraphic extends Shape &#123; OtherGraphic() &#123; super.m_type = 4; &#125; @Override public void draw() &#123; System.out.println(&quot; 绘制其它图形 &quot;); &#125;&#125; 迪米特法则 （最少知道原则） 一个对象应该对其他对象保持最少的了解 每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，则这两个对象之间是朋友关系 其中，出现成员变量，方法参数，方法返回值中的类为直接的朋友 迪米特法则只要要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系 合成复用原则尽量使用合成或者聚合的方式，而不是使用继承 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起 针对接口编程，而不是针对具体实现编程 松耦合设计 ​","categories":[{"name":"java","slug":"java","permalink":"http://www.hzzzzzy.icu/categories/java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.hzzzzzy.icu/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"06-本地方法栈和本地方法","slug":"06-本地方法栈和本地方法","date":"2022-07-12T01:37:44.000Z","updated":"2022-07-13T11:59:34.325Z","comments":true,"path":"2022/07/12/06-本地方法栈和本地方法/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/06-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95/","excerpt":"","text":"本地方法实际上是一个java调用非java代码的一个接口 （ 使用native关键字进行修饰 ） 本地方法的作用： 1、Java应用与Java外面的环境交互 2、与操作系统进行交互 3、Sun公司解释器由C实现 本地方法栈 （线程私有）Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用 本地方法栈中登记本地方法，然后执行引擎执行时，加载本地方法库 当某一个线程调用本地方法时 本地方法可通过本地方法接口来访问虚拟机内部的运行时数据区 可以使用本地处理器中的寄存器 ……（和虚拟机拥有一样的权限）","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"05-虚拟机栈及相关问题","slug":"05-虚拟机栈及相关问题","date":"2022-07-12T01:35:21.000Z","updated":"2022-07-13T11:59:42.423Z","comments":true,"path":"2022/07/12/05-虚拟机栈及相关问题/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/05-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","excerpt":"","text":"虚拟机栈 （线程私有） 不存在GC，存在OOM 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个栈帧，对应着一次次的方法调用 虚拟机栈的生命周期和线程一致。作用是主管java程序的运行，保存方法的局部变量（8种基本数据类型，对象的引用地址，对象实际存储在堆空间中），部分结果，并参与方法的调用和返回 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器 JVM直接对栈的操作：1、每个方法执行，伴随着进栈（入栈，压栈） 2、执行结束后的出栈操作 设置栈内存的大小使用参数-Xss选项设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度 栈的存储单位1）栈中的数据都是以栈帧为基本单位存在 2）在这个线程上正在执行的每个方法都各自对应着一个栈帧 3）栈帧是一个内存区块，是一个数据集，****维系着方法执行过程中的各种数据信息 4）在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧，与当前栈帧相对应的方法就是当前方法，定义这个方法的类就是当前类。 5）执行引擎运行的所有字节码指令只针对当前栈帧进行操作。 6）如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。 ​ 栈帧的内部结构每个栈帧都存储着： 局部变量表 操作数栈（表达式栈） 动态链接（或指向运行时常量池的方法引用） 方法返回地址（或方法正常退出或异常退出的定义） 一些附加信息 方法嵌套调用的次数由栈的大小决定，栈越大，方法嵌套调用的次数就越多。 对于一个函数，参数和局部变量越多，局部变量表就会膨胀，栈帧就越大 局部变量表1、存放编译器的各种基本数据类型（8种）引用类型（reference）returnAddress类型的变量 2、定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量 3、由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题 4、局部变量表所需的容量大小是在编译器就确定下来的（一旦确定就不会更改） 注意：局部变量表中的变量只在当前方法调用中有效，当方法调用结束后，随着方法栈帧的销毁，局部变量表也会销毁 123456789101112131415161718/** * @Description 字节码中方法内部结构的剖析 * @Author hzy * @Date 2022/7/11 14:54 * @Version 1.0 **///使用javap -v 类.class 或者使用jclasslibpublic class LocalVariableTest &#123; public static void main(String[] args) &#123; LocalVariableTest test=new LocalVariableTest(); int num=10; test.test1(); &#125; public static void test1()&#123; Date date = new Date(); String name=&quot;xiaozhi&quot;; &#125;&#125; ​ ​ ​ 比如此处，num对应的起始pc是8，对应代码的实际行数第14行，字节码指令长度是17 所以起始pc加上长度就是字节码的指令长度 textcolor{red}{局部变量表的基本存储单元是Slot(变量槽) 32位以内的类型只占用一个Slot（包括returnAddress类型） 64位的类型占用两个Slot（long和double） byte，short，char在存储前转化为int boolean也被转换为int，0表示false，1表示true JVM会为局部变量中的每一个Slot都分配一个访问索引，通过这个索引可以访问局部变量中指定的值 ​ 如果需要访问一个64bit的局部变量值时，只需要使用前一个索引即可 如果当前帧是由构造方法或者实例的方法进行创建的，那么该对象引用this将会存放在index为0的Slot处，其余的继续排列 例子：​ *this代表对象实例，而static是随类的加载而加载，先于实例之前就有的，所以不存在于局部变量表中，所以不能使用。 变量的分类 一、按照数据类型分：1、基本数据类型 2、引用数据类型 二、按照在类中声明的位置分： 1、成员变量：在使用前都经过默认初始化赋值 ​ 类变量：linking的prepare阶段，给类变量默认赋值 —&gt; initial阶段，给类变量显式赋值即静态代码块赋值 **实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值** **2、局部变量：使用前必须进行显示赋值，否则编译不通过** 局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中的直接或间接引用的对象都不会被回收 操作数（表达式）栈 每一个独立的栈帧中除了包含局部变量表以外，还包含了一个后进先出的操作数栈，也可以称之为表达式栈 在方法执行的过程中，根据字节码指令，往栈中写入数据（入栈）或提取数据（出栈） 主要用于保存计算过程的中间结果，同时作为计算机过程中变量临时的存储空间 当一个方法开始执行的时候，一个新的栈帧也会被创建出来，这个方法的操作数栈是空的 每一个操作数栈都会拥有一个栈深度用于存储数值（max_stack）32bit类型占用一个栈单位深度，64bit类型占用两个栈单位深度 操作数栈不是通过访问索引的方式来进行数据访问的，而只能通过标准的入栈出栈来进行数据访问 代码追踪12345public void testAddOperation()&#123; byte i = 15; int j = 8; int k = i + j;&#125; 操作数栈的最大深度123456789101112public class OperandStackTest &#123; public void testAddOperation()&#123; //byte、short、char、boolean:都以int型保存 byte i=15; short j=8; int k=i+j; long m=12L; int n=800; //存在宽化类型转换 m=m*n; &#125;&#125; 栈顶缓存技术为了解决指令过多导致频繁地执行内存读&#x2F;写操作，影响执行速度的问题 将栈顶元素全部缓存在物理CPU的寄存器中,以此降低对内存的读&#x2F;写次数 (将计算的操作放到CPU寄存器里面去) 动态链接栈帧内部包含了一个指向运行时常量池中该栈帧所属方法的引用—动态链接 每一个栈帧内部都包含一个指向运行时常量池Constant pool或该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如invokedynamic指令 动态链接的作用就是为了将这些符号引用(#)最终转换为调用方法的直接引用 方法的调用： 静态链接：在字节码文件装载进JVM内部时，被调用的方法在编译期可知，而且在运行的期间保持不变，这时候符号引用就会转换为直接引用。这个过程即为静态链接 动态链接：被调用的方法在编译期不可确定，在程序运行的期间才将符号引用进行转换，这个过程为动态链接 绑定：一个字段，方法，类在符号引用转换为直接引用的过程 早期绑定：被调用的目标方法在编译期内可知，运行期间不变 晚期绑定：调用方法在编译期无法确定，到运行期才确定 非虚方法：在编译器确定调用的版本，这个版本运行时不变，比如：静态方法，私有方法，final方法，实例构造器，父类方法 虚方法：其他 虚方法表每个类中都有一个虚方法表，表中存放着各个方法的实际入口。 如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中 虚方法表会在类加载的链接阶段被创建并开始初始化 ，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。 方法返回地址存储调用该方法的PC寄存器的值 在方法推出后都会返回到该方法被调用的位置。 方法正常退出时，调用者的PC计数器的值作为返回地址（调用该方法的指令的下一条指令的地址） 方法异常退出时，返回地址通过异常表来确定 相关问题1、举例栈溢出的情况：通过-Xss设置栈的大小（OOM） 2、调整栈大小，就能保证不出现溢出吗？不能 3、分配的栈内存越大越好吗？不是，栈空间大了线程数就少了，栈空间和线程数目成反比 4、垃圾回收是否会涉及到虚拟机栈？不会 5、方法中定义的局部变量是否线程安全？看情况 6、代码演示：（内部产生，在内部消亡，线程安全） 12345678910111213141516171819202122232425262728293031//s1的声明方式是线程安全的public static void method1()&#123; //StringBuilder线程不安全 StringBuilder s1 = new StringBuilder(); s1.append(&quot;a&quot;);&#125;//s2的操作过程是线程不安全的public static void method2(StringBuilder s2)&#123; s2.append(&quot;a&quot;);&#125;//s3的操作是线程不安全的public static StringBuilder method3() &#123; StringBuilder s3 = new StringBuilder(); s3.append(&quot;a&quot;); return s3;&#125;//s4的操作是线程安全的,s4其实在内部消亡了public static String method4() &#123; StringBuilder s4 = new StringBuilder(); s4.append(&quot;a&quot;); return s4.toString();&#125;public static void main(String[] args) &#123; StringBuilder s = new StringBuilder(); new Thread(()-&gt; &#123; s.append(&quot;a&quot;); &#125;).start(); method2(s);&#125;","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"04-程序计数器","slug":"04-程序计数器","date":"2022-07-12T01:31:14.000Z","updated":"2022-07-13T11:59:48.005Z","comments":true,"path":"2022/07/12/04-程序计数器/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/04-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/","excerpt":"","text":"程序计数器（PC寄存器）概述既不存在GC也不存在OOM PC寄存器用来存储指向下一条指令的地址，也是即将要执行的指令代码。由执行引擎读取下一条指令 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。 代码演示 通过PC寄存器，我们就可以知道当前程序执行到哪一步了 ​ 使用PC寄存器存储字节码地址有什么用？（为什么要使用PC寄存器记录当前线程的执行地址呢？）1、CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。 2、JVM的字节码解释器需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。 PC寄存器为什么被设定为线程私有的？由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。 这样必然导致经常中断或恢复，为了保证分毫无差。每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。 比如一个cpu负责3个线程，cpu会在3个线程间轮流执行，为了能够保证CPU在切换的过程中，每个线程都可以按照切换之前的指令继续执行，而不影响其他线程，所以PC寄存器设定为线程私有的 CPU时间片（*）","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"03-数据区概述与线程","slug":"03-数据区概述与线程","date":"2022-07-12T01:30:10.000Z","updated":"2022-07-13T11:59:55.762Z","comments":true,"path":"2022/07/12/03-数据区概述与线程/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/12/03-%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E4%B8%8E%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"数据区JVM在执行java程序的过程中会把它管理的内存划分为若干个不同的数据区域（包括5个运行时数据区） 1、方法区 2、虚拟机栈 3、本地方法栈 4、堆 5、程序计数器 ​ 运行时数据区的完整图 ​ Java的内存区域 ​ 灰色的为单独线程私有的，红色的为多个线程共享的。 即： 1、每个线程：独立包括程序计数器、虚拟机栈、本地方法栈。 2、线程间共享：堆、堆外内存（永久代或元空间、代码缓存） ​ 线程的简单介绍线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。 操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。 JVM线程（*） 虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。 GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。 编译线程：这种线程在运行时会将字节码编译成到本地代码。 信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"02-类加载器和类加载过程","slug":"02-类加载器和类加载过程","date":"2022-07-11T01:26:01.000Z","updated":"2022-08-09T06:54:26.583Z","comments":true,"path":"2022/07/11/02-类加载器和类加载过程/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/11/02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"","text":"类加载过程 加载1、通过一个类的全限定名获取定义此类的二进制字节流 2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 链接：一共分为三个部分，验证、准备和解析一、验证目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身。 验证阶段是十分重要的，直接决定了Java虚拟机是否能承受恶意代码的攻击，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重。 主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证 二、准备1、为类变量分配内存并且设置该变量的默认初始值，即零值。 2、这里不包括含用final修饰的static,因为final在编译的时候就会分配数值了，准备阶段会显式初始化。 3、这里不会为实例变量分配初始化，类变量会分配在方法区，而实例变量是会随着对象一起分配到java堆中。 三、解析1、将常量池内的符号引用转换为直接引用过程 2、实际上，解析操作往往会伴随着JVM在执行完初始化之后再执行。 3、符号引用就是一组符号来描述所引用的目标。符号引用的字面形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 4、主要解析动作针对类或接口、字段、类方法、接口方法、方法类型等。 初始化1）初始化阶段就是执行类构造器方法()的过程该方法不需要定义，而是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来的 构造器方法中的指令按照语句在源文件中出现的顺序来决定 变量已经赋过一次系统要求的初始零值，而在初始化阶段 则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。 2）若该类有父类，JVM会保证子子类的()执行前，父类的()已经执行完毕虚拟机必须保证一个类的()方法在多线程下被同步加锁 3）在类加载的Linking链接的准备阶段，所有类变量以符号引用的方法存储在方法区而当静态代码尝试获取类变量时候需要通过直接引用，这就导致了编译的出错 4）Java编译器并不会为所有的类都产生()初始化方法一个类中并没有声明任何的类变量,也没有静态代码块时 一个类中声明类变量,但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时 一个类中包含static final修饰的基本数据类型的字段,这些类字段初始化语句采用编译时常量表达式 (如果这个static final 不是通过方法或者构造器,则在链接阶段) 5）赋值的阶段性问题 在链接阶段的准备环节赋值的情况: 1、对于基本数据类型的字段来说,如果使用static final修饰,则显式赋值(直接赋值常量,而非调用方法)通常是在链接阶段的准备环节进行 2、对于String来说,如果使用字面量的方式赋值,使用static final修饰的话,则显式赋值通常是在链接阶段的准备环节进行 3、使用static + final修饰,且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值,是在链接阶段的准备环节进行。 在初始化阶段()中赋值的情况: 排除上述的在准备环节赋值的情况之外的情况 类加载器 引导(启动)类加载器这个类加载使用C&#x2F;C++语言实现的,嵌套在JVM内部 1、它用来加载Java的核心类库(JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resource.jar或sum.boot.class.path路径下的内容) 用于提供JVM自身需要的类(String类就是使用的这个类加载器) 2、由于安全考虑,Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 3、并不继承自java.lang.ClassLoader,没有父加载器 4、加载扩展类和应用程序类加载器,并指定为他们的父类加载器 自定义加载器 （将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器） 1、Java语言编写 2、派生于ClassLoader类,父类加载器为启动类加载器 3、从java.ext.dirs系统属性所指定的目录中加载类库,或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录(扩展目录)下加载类库。 如果用户创建的JAR放在此目录下,也会自动由扩展类加载器加载 扩展类加载器1、Java语言编写 2、派生于ClassLoader类,父类加载器为启动类加载器 3、从java.ext.dirs系统属性所指定的目录中加载类库,或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录(扩展目录)下加载类库 如果用户创建的JAR放在此目录下,也会自动由扩展类加载器加载 应用程序(系统)类加载器 AppClassLoader1、java语言编写 2、派生于ClassLoader类,父类加载器为扩展类加载器 3、它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库 4、该类加载是程序中默认的类加载器 5、通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器 用户自定义类加载器目的隔离记载类 修改类的加载方式 扩展加载源 防止源码泄露 方法1）重写 loadClass() 方法（不推荐,这个方法会保证类的双亲委派机制） 2）重写 findClass() 方法 –&gt;推荐 这两种方法本质上差不多,毕竟loadClass()也会调用findClass(),但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法,根据参数指定类的名字,返回对应的Class对象的引用 获取ClassLoader的方法 双亲委派机制java虚拟机对class文件采用按需加载的方式进行加载，当需要使用该类时才会将它的class文件加载到内存中生成class对象 在加载这个类的时候，采用的就是双亲委派模式。 1、如果 一个类加载收到了类加载请求,它并不会自己先去加载 ,而是把这个请求 委托给父类加载器去执行 2、如果 父类加载器还存在其父类加载器 ,则进一步 向上委托 ,依次递归,请求最终将 到达顶层的启动类加载器 3、如果父类的加载器可以完成类的加载任务,就成功返回,倘若 父类加载器无法完成此加载任务,子加载器才会尝试自己去加载, 这就是双亲委派模式 ​ 源码分析（双亲委派机制在 java.lang.ClassLoader.loadClass(String,boolean) 中体现） 1、先在当前加载器的缓存中*查找有无目标类,如果有,直接返回。* 2、判断当前加载器的父加载器是否为空 ,如果不为空,则调用 parent.loadClass(name, false) 接口进行加载 3、反之,如果当前加载器的父类加载器为空,则调用 findBootstrapClassOrNull(name) 接口,让引导类加载器进行加载 4、如果通过以上3条路径都没能成功加载,则调用 findClass(name) 接口进行加载。该接口最终会调用 java.lang.ClassLoader 接口的 defineClass 系列的native接口加载目标Java类。 双亲委派的模型就隐藏在这第2和第3步中 双亲委派机制的优势1、避免类的重复加载，确保一个类的全局唯一性（当父ClassLoader已经加载了该类的时候,就没有必要子ClassLoader再加载一次） 2、保护程序的安全，防止API随意被篡改 沙箱安全机制Java代码限定在虚拟机JVM特定的运行范围中，并且严格限制代码对本地资源的访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏 ​ 类的使用方式java虚拟机在每个类或接口被java程序“首次主动使用”时才初始化它们。被动使用不会初始化类，但又可能会加载类 在加载的过程中，遇到.class文件的缺失或者存在错误，类加载器只会在首次主动使用它们时才会报错，如果一直没使用，则不会报错 主动使用1、创建类的实例 2、访问某个类或接口的静态变量，或者对该静态变量赋值 3、调用类的静态方法 4、反射 5、初始化一个类的子类 6、java虚拟机启动时被标明为启动类的类 注意： 初始化一个类的子类这条规则，不适用于接口，即：初始化一个类的子类，会先初始化它的父类，但是不一定会初始化它的接口。只有当首次使用该接口的静态变量时，才会初始化。 被动使用除了主动使用的其他使用方式，例如： 1）通过子类引用父类的静态字段，为子类的被动使用，不会导致子类初始化 2）通过数组定义类引用类，为类的被动使用，不会触发此类的初始化 ​ 3）常量在编译阶段会存入调用方法所在的类的常量池中（这个例子存在F类的常量池中） 本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]},{"title":"01-什么是JVM?","slug":"01-什么是JVM","date":"2022-07-10T12:25:14.000Z","updated":"2022-07-13T12:00:10.035Z","comments":true,"path":"2022/07/10/01-什么是JVM/","link":"","permalink":"http://www.hzzzzzy.icu/2022/07/10/01-%E4%BB%80%E4%B9%88%E6%98%AFJVM/","excerpt":"","text":"什么是JVM？①. JVM 是 java虚拟机，是用来执行java字节码(二进制的形式)的虚拟计算机 ②. jvm是运行在操作系统之上的，与硬件没有任何关系 Java的跨平台及原理①. 跨平台：由Java编写的程序可以在不同的操作系统上运行：一次编写，多处运行 ②. 原理：编译之后的字节码文件和平台无关，需要在不同的操作系统上安装一个对应版本的虚拟机(JVM) JVM的整体的理解①. 类加载子系统 ②. 运行时数据区(我们核心关注这里 的栈、堆、方法区) ③. 执行引擎(一般都是JIT编译器和解释器共存) java代码执行流程​ java源码—java编译器—生成字节码—进入java虚拟机（类加载器—字节码校验器—翻译字节码—JIT编译器） JVM的架构模型Java编译器输入的指令流基木上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。 基于栈式架构的特点 跨平台性 指令集小 指令多 执行性能比寄存器差 基于寄存器架构的特点 指令集架构则完全依赖硬件，可移植性差 性能优秀和执行更高效 举例 同样执行2+3这种逻辑操作，其指令分别如下： 1、基于栈的计算流程（以Java虚拟机为例) 2、基于寄存器的计算流程 总结 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。 JVM的生命周期虚拟机的启动 Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。 虚拟机的执行 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。 程序开始执行时他才运行，程序结束时他就停止。 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。 虚拟机的退出 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统用现错误而导致Java虚拟机进程终止 某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。 除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"}]}],"categories":[{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/categories/spring%E9%AB%98%E7%BA%A7/"},{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/categories/JVM/"},{"name":"nginx","slug":"nginx","permalink":"http://www.hzzzzzy.icu/categories/nginx/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.hzzzzzy.icu/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"java","slug":"java","permalink":"http://www.hzzzzzy.icu/categories/java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.hzzzzzy.icu/tags/%E9%9D%A2%E8%AF%95/"},{"name":"底层源码","slug":"底层源码","permalink":"http://www.hzzzzzy.icu/tags/%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/"},{"name":"spring高级","slug":"spring高级","permalink":"http://www.hzzzzzy.icu/tags/spring%E9%AB%98%E7%BA%A7/"},{"name":"JVM","slug":"JVM","permalink":"http://www.hzzzzzy.icu/tags/JVM/"},{"name":"nginx","slug":"nginx","permalink":"http://www.hzzzzzy.icu/tags/nginx/"},{"name":"数据结构基础知识","slug":"数据结构基础知识","permalink":"http://www.hzzzzzy.icu/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.hzzzzzy.icu/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}